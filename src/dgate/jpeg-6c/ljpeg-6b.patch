diff -cN ../jpeg-6b/README ./README
*** ../jpeg-6b/README	Fri Mar 27 18:34:59 1998
--- ./README	Tue Apr 27 14:58:14 1999
***************
*** 74,85 ****
  low-quality image.  For more details, see the references, or just experiment
  with various compression settings.
  
! This software implements JPEG baseline, extended-sequential, and progressive
! compression processes.  Provision is made for supporting all variants of these
! processes, although some uncommon parameter settings aren't implemented yet.
! For legal reasons, we are not distributing code for the arithmetic-coding
! variants of JPEG; see LEGAL ISSUES.  We have made no provision for supporting
! the hierarchical or lossless processes defined in the standard.
  
  We provide a set of library routines for reading and writing JPEG image files,
  plus two sample applications "cjpeg" and "djpeg", which use the library to
--- 74,85 ----
  low-quality image.  For more details, see the references, or just experiment
  with various compression settings.
  
! This software implements JPEG baseline, extended-sequential, progressive
! and lossless compression processes.  Provision is made for supporting all
! variants of these processes, although some uncommon parameter settings aren't
! implemented yet. For legal reasons, we are not distributing code for the
! arithmetic-coding variants of JPEG; see LEGAL ISSUES.  We have made no
! provision for supporting the hierarchical processes defined in the standard.
  
  We provide a set of library routines for reading and writing JPEG image files,
  plus two sample applications "cjpeg" and "djpeg", which use the library to
diff -cN ../jpeg-6b/TODO ./TODO
*** ../jpeg-6b/TODO
--- ./TODO	Tue Apr 27 14:58:15 1999
***************
*** 0 ****
--- 1,13 ----
+ List of things to complete for lossless codec:
+ 
+ * How to deal with data_precision vs. BITS_PER_JSAMPLE for compression codec.
+ 
+ * Re-visit use of insufficient_data - see jdhuff.c and jdlhuff.c.
+ 
+ * How to check BITS_PER_JSAMPLE for lossy mode (ie, 16-bit data)? -
+   see jdinput.c.
+ 
+ * Check comment blocks for errors/changes.
+ 
+ * Review new filenames.  Try to avoid filename conflicts with possible JPEG-LS
+   codec.
diff -cN ../jpeg-6b/cjpeg.1 ./cjpeg.1
*** ../jpeg-6b/cjpeg.1	Fri Mar 20 20:29:01 1998
--- ./cjpeg.1	Tue Apr 27 14:58:15 1999
***************
*** 62,67 ****
--- 62,74 ----
  .B \-progressive
  Create progressive JPEG file (see below).
  .TP
+ .BI \-lossless " psv[,Pt]"
+ Create a lossless JPEG file using the specified predictor selection value (1-7)
+ and optional point transform.
+ .B Caution:
+ lossless JPEG is not widely implemented, so many decoders will be
+ unable to view a lossless JPEG file at all.
+ .TP
  .B \-targa
  Input file is Targa format.  Targa files that contain an "identification"
  field will not be automatically recognized by
diff -cN ../jpeg-6b/cjpeg.c ./cjpeg.c
*** ../jpeg-6b/cjpeg.c	Fri Mar 20 20:21:49 1998
--- ./cjpeg.c	Tue Apr 27 14:58:15 1999
***************
*** 157,162 ****
--- 157,165 ----
  #ifdef C_PROGRESSIVE_SUPPORTED
    fprintf(stderr, "  -progressive   Create progressive JPEG file\n");
  #endif
+ #ifdef C_LOSSLESS_SUPPORTED
+   fprintf(stderr, "  -lossless psv[,Pt]  Create lossless JPEG file\n");
+ #endif
  #ifdef TARGA_SUPPORTED
    fprintf(stderr, "  -targa         Input file is Targa format (usually not needed)\n");
  #endif
***************
*** 217,222 ****
--- 220,226 ----
    char * qslotsarg = NULL;	/* saves -qslots parm if any */
    char * samplearg = NULL;	/* saves -sample parm if any */
    char * scansarg = NULL;	/* saves -scans parm if any */
+   char * losslsarg = NULL;	/* saves -lossless parm if any */
  
    /* Set up default JPEG parameters. */
    /* Note that default -quality level need not, and does not,
***************
*** 287,292 ****
--- 291,309 ----
        /* Force a monochrome JPEG file to be generated. */
        jpeg_set_colorspace(cinfo, JCS_GRAYSCALE);
  
+     } else if (keymatch(arg, "lossless", 1)) {
+ /* Select simple lossless mode. */
+ #ifdef C_LOSSLESS_SUPPORTED
+       if (++argn >= argc)	/* advance to next argument */
+ 	usage();
+       losslsarg = argv[argn];
+       /* We must postpone execution until num_components is known. */
+ #else
+       fprintf(stderr, "%s: sorry, lossless output was not compiled\n",
+ 	      progname);
+       exit(EXIT_FAILURE);
+ #endif
+ 
      } else if (keymatch(arg, "maxmemory", 3)) {
        /* Maximum memory in Kb (or Mb with 'm'). */
        long lval;
***************
*** 440,445 ****
--- 457,468 ----
  #ifdef C_PROGRESSIVE_SUPPORTED
      if (simple_progressive)	/* process -progressive; -scans can override */
        jpeg_simple_progression(cinfo);
+ #endif
+ 
+ #ifdef C_LOSSLESS_SUPPORTED
+     if (losslsarg != NULL)	/* process -lossless if it was present */
+       if (! set_simple_lossless(cinfo, losslsarg))
+ 	usage();
  #endif
  
  #ifdef C_MULTISCAN_FILES_SUPPORTED
diff -cN ../jpeg-6b/filelist.doc ./filelist.doc
*** ../jpeg-6b/filelist.doc	Sun Mar 15 13:57:38 1998
--- ./filelist.doc	Tue Apr 27 14:58:15 1999
***************
*** 1,6 ****
  IJG JPEG LIBRARY:  FILE LIST
  
! Copyright (C) 1994-1998, Thomas G. Lane.
  This file is part of the Independent JPEG Group's software.
  For conditions of distribution and use, see the accompanying README file.
  
--- 1,6 ----
  IJG JPEG LIBRARY:  FILE LIST
  
! Copyright (C) 1994-1997, Thomas G. Lane.
  This file is part of the Independent JPEG Group's software.
  For conditions of distribution and use, see the accompanying README file.
  
***************
*** 28,33 ****
--- 28,35 ----
  jinclude.h	Central include file used by all IJG .c files to reference
  		system include files.
  jpegint.h	JPEG library's internal data structures.
+ jlossls.h	JPEG library's lossless codec data structures.
+ jlossy.h	JPEG library's lossy codec structures.
  jchuff.h	Private declarations for Huffman encoder modules.
  jdhuff.h	Private declarations for Huffman decoder modules.
  jdct.h		Private declarations for forward & reverse DCT subsystems.
***************
*** 64,97 ****
  jcinit.c	Initialization: determines which other modules to use.
  jcmaster.c	Master control: setup and inter-pass sequencing logic.
  jcmainct.c	Main buffer controller (preprocessor => JPEG compressor).
  jcprepct.c	Preprocessor buffer controller.
- jccoefct.c	Buffer controller for DCT coefficient buffer.
  jccolor.c	Color space conversion.
  jcsample.c	Downsampling.
  jcdctmgr.c	DCT manager (DCT implementation selection & control).
  jfdctint.c	Forward DCT using slow-but-accurate integer method.
  jfdctfst.c	Forward DCT using faster, less accurate integer method.
  jfdctflt.c	Forward DCT using floating-point arithmetic.
! jchuff.c	Huffman entropy coding for sequential JPEG.
  jcphuff.c	Huffman entropy coding for progressive JPEG.
! jcmarker.c	JPEG marker writing.
! jdatadst.c	Data destination manager for stdio output.
  
  Decompression side of the library:
  
  jdmaster.c	Master control: determines which other modules to use.
  jdinput.c	Input controller: controls input processing modules.
  jdmainct.c	Main buffer controller (JPEG decompressor => postprocessor).
! jdcoefct.c	Buffer controller for DCT coefficient buffer.
  jdpostct.c	Postprocessor buffer controller.
  jdmarker.c	JPEG marker reading.
- jdhuff.c	Huffman entropy decoding for sequential JPEG.
- jdphuff.c	Huffman entropy decoding for progressive JPEG.
- jddctmgr.c	IDCT manager (IDCT implementation selection & control).
- jidctint.c	Inverse DCT using slow-but-accurate integer method.
- jidctfst.c	Inverse DCT using faster, less accurate integer method.
- jidctflt.c	Inverse DCT using floating-point arithmetic.
- jidctred.c	Inverse DCTs with reduced-size outputs.
  jdsample.c	Upsampling.
  jdcolor.c	Color space conversion.
  jdmerge.c	Merged upsampling/color conversion (faster, lower quality).
--- 66,105 ----
  jcinit.c	Initialization: determines which other modules to use.
  jcmaster.c	Master control: setup and inter-pass sequencing logic.
  jcmainct.c	Main buffer controller (preprocessor => JPEG compressor).
+ jchuff.c	Codec-independent Huffman entropy encoding routines.
  jcprepct.c	Preprocessor buffer controller.
  jccolor.c	Color space conversion.
  jcsample.c	Downsampling.
+ jcmarker.c	JPEG marker writing.
+ jdatadst.c	Data destination manager for stdio output.
+ 
+ Lossy (DCT) codec:
+ 
+ jlossy.c	Lossy compressor proper.
+ jccoefct.c	Buffer controller for DCT coefficient buffer.
  jcdctmgr.c	DCT manager (DCT implementation selection & control).
  jfdctint.c	Forward DCT using slow-but-accurate integer method.
  jfdctfst.c	Forward DCT using faster, less accurate integer method.
  jfdctflt.c	Forward DCT using floating-point arithmetic.
! jcshuff.c	Huffman entropy coding for sequential JPEG.
  jcphuff.c	Huffman entropy coding for progressive JPEG.
! 
! Lossless (spatial) codec:
  
+ jclossls.c	Lossless compressor proper.
+ jcdiffct.c	Buffer controller for difference buffer.
+ jcscale.c	Point transformation.
+ jcpred.c	Sample predictor and differencer.
+ jclhuff.c	Huffman entropy encoding for lossless JPEG.
+ 
  Decompression side of the library:
  
  jdmaster.c	Master control: determines which other modules to use.
  jdinput.c	Input controller: controls input processing modules.
  jdmainct.c	Main buffer controller (JPEG decompressor => postprocessor).
! jdhuff.c	Codec-independent Huffman entropy decoding routines.
  jdpostct.c	Postprocessor buffer controller.
  jdmarker.c	JPEG marker reading.
  jdsample.c	Upsampling.
  jdcolor.c	Color space conversion.
  jdmerge.c	Merged upsampling/color conversion (faster, lower quality).
***************
*** 100,109 ****
--- 108,138 ----
  		Also handles one-pass quantization to an externally given map.
  jdatasrc.c	Data source manager for stdio input.
  
+ Lossy (DCT) codec:
+ 
+ jdlossy.c	Lossy decompressor proper.
+ jdcoefct.c	Buffer controller for DCT coefficient buffer.
+ jdshuff.c	Huffman entropy decoding for sequential JPEG.
+ jdphuff.c	Huffman entropy decoding for progressive JPEG.
+ jddctmgr.c	IDCT manager (IDCT implementation selection & control).
+ jidctint.c	Inverse DCT using slow-but-accurate integer method.
+ jidctfst.c	Inverse DCT using faster, less accurate integer method.
+ jidctflt.c	Inverse DCT using floating-point arithmetic.
+ jidctred.c	Inverse DCTs with reduced-size outputs.
+ 
+ Lossless (spatial) codec:
+ 
+ jdlossls.c	Lossless decompressor proper.
+ jddiffct.c	Buffer controller for difference buffers.
+ jdlhuff.c	Huffman entropy decoding for lossless JPEG.
+ jdpred.c	Sample predictor and undifferencer.
+ jdscale.c	Point transformation, sample size scaling.
+ 
  Support files for both compression and decompression:
  
  jerror.c	Standard error handling routines (application replaceable).
  jmemmgr.c	System-independent (more or less) memory management code.
+ jcodec.c	Codec-independent utility routines.
  jutils.c	Miscellaneous utility routines.
  
  jmemmgr.c relies on a system-dependent memory management module.  The IJG
diff -cN ../jpeg-6b/jcapimin.c ./jcapimin.c
*** ../jpeg-6b/jcapimin.c	Sat Jan 24 16:21:30 1998
--- ./jcapimin.c	Tue Apr 27 14:58:16 1999
***************
*** 168,174 ****
        /* We bypass the main controller and invoke coef controller directly;
         * all work is being done from the coefficient buffer.
         */
!       if (! (*cinfo->coef->compress_data) (cinfo, (JSAMPIMAGE) NULL))
  	ERREXIT(cinfo, JERR_CANT_SUSPEND);
      }
      (*cinfo->master->finish_pass) (cinfo);
--- 168,174 ----
        /* We bypass the main controller and invoke coef controller directly;
         * all work is being done from the coefficient buffer.
         */
!       if (! (*cinfo->codec->compress_data) (cinfo, (JSAMPIMAGE) NULL))
  	ERREXIT(cinfo, JERR_CANT_SUSPEND);
      }
      (*cinfo->master->finish_pass) (cinfo);
diff -cN ../jpeg-6b/jcapistd.c ./jcapistd.c
*** ../jpeg-6b/jcapistd.c	Sat Jan  6 18:24:10 1996
--- ./jcapistd.c	Tue Apr 27 14:58:16 1999
***************
*** 145,156 ****
      (*cinfo->master->pass_startup) (cinfo);
  
    /* Verify that at least one iMCU row has been passed. */
!   lines_per_iMCU_row = cinfo->max_v_samp_factor * DCTSIZE;
    if (num_lines < lines_per_iMCU_row)
      ERREXIT(cinfo, JERR_BUFFER_SIZE);
  
    /* Directly compress the row. */
!   if (! (*cinfo->coef->compress_data) (cinfo, data)) {
      /* If compressor did not consume the whole row, suspend processing. */
      return 0;
    }
--- 145,156 ----
      (*cinfo->master->pass_startup) (cinfo);
  
    /* Verify that at least one iMCU row has been passed. */
!   lines_per_iMCU_row = cinfo->max_v_samp_factor * cinfo->data_unit;
    if (num_lines < lines_per_iMCU_row)
      ERREXIT(cinfo, JERR_BUFFER_SIZE);
  
    /* Directly compress the row. */
!   if (! (*cinfo->codec->compress_data) (cinfo, data)) {
      /* If compressor did not consume the whole row, suspend processing. */
      return 0;
    }
diff -cN ../jpeg-6b/jccoefct.c ./jccoefct.c
*** ../jpeg-6b/jccoefct.c	Sat Nov 15 21:25:09 1997
--- ./jccoefct.c	Tue Apr 27 14:58:16 1999
***************
*** 1,7 ****
  /*
   * jccoefct.c
   *
!  * Copyright (C) 1994-1997, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jccoefct.c
   *
!  * Copyright (C) 1994-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 13,18 ****
--- 13,19 ----
  #define JPEG_INTERNALS
  #include "jinclude.h"
  #include "jpeglib.h"
+ #include "jlossy.h"		/* Private declarations for lossy codec */
  
  
  /* We use a full-image coefficient buffer when doing Huffman optimization,
***************
*** 32,39 ****
  /* Private buffer controller object */
  
  typedef struct {
-   struct jpeg_c_coef_controller pub; /* public fields */
- 
    JDIMENSION iMCU_row_num;	/* iMCU row # within image */
    JDIMENSION mcu_ctr;		/* counts MCUs processed in current row */
    int MCU_vert_offset;		/* counts MCU rows within iMCU row */
--- 33,38 ----
***************
*** 41,60 ****
  
    /* For single-pass compression, it's sufficient to buffer just one MCU
     * (although this may prove a bit slow in practice).  We allocate a
!    * workspace of C_MAX_BLOCKS_IN_MCU coefficient blocks, and reuse it for each
!    * MCU constructed and sent.  (On 80x86, the workspace is FAR even though
!    * it's not really very big; this is to keep the module interfaces unchanged
!    * when a large coefficient buffer is necessary.)
     * In multi-pass modes, this array points to the current MCU's blocks
     * within the virtual arrays.
     */
!   JBLOCKROW MCU_buffer[C_MAX_BLOCKS_IN_MCU];
  
    /* In multi-pass modes, we need a virtual block array for each component. */
    jvirt_barray_ptr whole_image[MAX_COMPONENTS];
! } my_coef_controller;
  
! typedef my_coef_controller * my_coef_ptr;
  
  
  /* Forward declarations */
--- 40,59 ----
  
    /* For single-pass compression, it's sufficient to buffer just one MCU
     * (although this may prove a bit slow in practice).  We allocate a
!    * workspace of C_MAX_DATA_UNITS_IN_MCU coefficient blocks, and reuse it for
!    * each MCU constructed and sent.  (On 80x86, the workspace is FAR even
!    * though it's not really very big; this is to keep the module interfaces
!    * unchanged when a large coefficient buffer is necessary.)
     * In multi-pass modes, this array points to the current MCU's blocks
     * within the virtual arrays.
     */
!   JBLOCKROW MCU_buffer[C_MAX_DATA_UNITS_IN_MCU];
  
    /* In multi-pass modes, we need a virtual block array for each component. */
    jvirt_barray_ptr whole_image[MAX_COMPONENTS];
! } c_coef_controller;
  
! typedef c_coef_controller * c_coef_ptr;
  
  
  /* Forward declarations */
***************
*** 72,78 ****
  start_iMCU_row (j_compress_ptr cinfo)
  /* Reset within-iMCU-row counters for a new row */
  {
!   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  
    /* In an interleaved scan, an MCU row is the same as an iMCU row.
     * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
--- 71,78 ----
  start_iMCU_row (j_compress_ptr cinfo)
  /* Reset within-iMCU-row counters for a new row */
  {
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   c_coef_ptr coef = (c_coef_ptr) lossyc->coef_private;
  
    /* In an interleaved scan, an MCU row is the same as an iMCU row.
     * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
***************
*** 99,105 ****
  METHODDEF(void)
  start_pass_coef (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
  {
!   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  
    coef->iMCU_row_num = 0;
    start_iMCU_row(cinfo);
--- 99,106 ----
  METHODDEF(void)
  start_pass_coef (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
  {
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   c_coef_ptr coef = (c_coef_ptr) lossyc->coef_private;
  
    coef->iMCU_row_num = 0;
    start_iMCU_row(cinfo);
***************
*** 108,125 ****
    case JBUF_PASS_THRU:
      if (coef->whole_image[0] != NULL)
        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
!     coef->pub.compress_data = compress_data;
      break;
  #ifdef FULL_COEF_BUFFER_SUPPORTED
    case JBUF_SAVE_AND_PASS:
      if (coef->whole_image[0] == NULL)
        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
!     coef->pub.compress_data = compress_first_pass;
      break;
    case JBUF_CRANK_DEST:
      if (coef->whole_image[0] == NULL)
        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
!     coef->pub.compress_data = compress_output;
      break;
  #endif
    default:
--- 109,126 ----
    case JBUF_PASS_THRU:
      if (coef->whole_image[0] != NULL)
        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
!     lossyc->pub.compress_data = compress_data;
      break;
  #ifdef FULL_COEF_BUFFER_SUPPORTED
    case JBUF_SAVE_AND_PASS:
      if (coef->whole_image[0] == NULL)
        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
!     lossyc->pub.compress_data = compress_first_pass;
      break;
    case JBUF_CRANK_DEST:
      if (coef->whole_image[0] == NULL)
        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
!     lossyc->pub.compress_data = compress_output;
      break;
  #endif
    default:
***************
*** 142,148 ****
  METHODDEF(boolean)
  compress_data (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
  {
!   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
    JDIMENSION MCU_col_num;	/* index of current MCU within row */
    JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
    JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
--- 143,150 ----
  METHODDEF(boolean)
  compress_data (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
  {
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   c_coef_ptr coef = (c_coef_ptr) lossyc->coef_private;
    JDIMENSION MCU_col_num;	/* index of current MCU within row */
    JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
    JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
***************
*** 174,183 ****
  	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
  	  if (coef->iMCU_row_num < last_iMCU_row ||
  	      yoffset+yindex < compptr->last_row_height) {
! 	    (*cinfo->fdct->forward_DCT) (cinfo, compptr,
! 					 input_buf[compptr->component_index],
! 					 coef->MCU_buffer[blkn],
! 					 ypos, xpos, (JDIMENSION) blockcnt);
  	    if (blockcnt < compptr->MCU_width) {
  	      /* Create some dummy blocks at the right edge of the image. */
  	      jzero_far((void FAR *) coef->MCU_buffer[blkn + blockcnt],
--- 176,185 ----
  	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
  	  if (coef->iMCU_row_num < last_iMCU_row ||
  	      yoffset+yindex < compptr->last_row_height) {
! 	    (*lossyc->fdct_forward_DCT) (cinfo, compptr,
! 				    input_buf[compptr->component_index],
! 				    coef->MCU_buffer[blkn],
! 				    ypos, xpos, (JDIMENSION) blockcnt);
  	    if (blockcnt < compptr->MCU_width) {
  	      /* Create some dummy blocks at the right edge of the image. */
  	      jzero_far((void FAR *) coef->MCU_buffer[blkn + blockcnt],
***************
*** 201,207 ****
        /* Try to write the MCU.  In event of a suspension failure, we will
         * re-DCT the MCU on restart (a bit inefficient, could be fixed...)
         */
!       if (! (*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {
  	/* Suspension forced; update state counters and exit */
  	coef->MCU_vert_offset = yoffset;
  	coef->mcu_ctr = MCU_col_num;
--- 203,209 ----
        /* Try to write the MCU.  In event of a suspension failure, we will
         * re-DCT the MCU on restart (a bit inefficient, could be fixed...)
         */
!       if (! (*lossyc->entropy_encode_mcu) (cinfo, coef->MCU_buffer)) {
  	/* Suspension forced; update state counters and exit */
  	coef->MCU_vert_offset = yoffset;
  	coef->mcu_ctr = MCU_col_num;
***************
*** 244,250 ****
  METHODDEF(boolean)
  compress_first_pass (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
  {
!   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
    JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
    JDIMENSION blocks_across, MCUs_across, MCUindex;
    int bi, ci, h_samp_factor, block_row, block_rows, ndummy;
--- 246,253 ----
  METHODDEF(boolean)
  compress_first_pass (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
  {
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   c_coef_ptr coef = (c_coef_ptr) lossyc->coef_private;
    JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
    JDIMENSION blocks_across, MCUs_across, MCUindex;
    int bi, ci, h_samp_factor, block_row, block_rows, ndummy;
***************
*** 265,274 ****
        block_rows = compptr->v_samp_factor;
      else {
        /* NB: can't use last_row_height here, since may not be set! */
!       block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
        if (block_rows == 0) block_rows = compptr->v_samp_factor;
      }
!     blocks_across = compptr->width_in_blocks;
      h_samp_factor = compptr->h_samp_factor;
      /* Count number of dummy blocks to be added at the right margin. */
      ndummy = (int) (blocks_across % h_samp_factor);
--- 268,277 ----
        block_rows = compptr->v_samp_factor;
      else {
        /* NB: can't use last_row_height here, since may not be set! */
!       block_rows = (int) (compptr->height_in_data_units % compptr->v_samp_factor);
        if (block_rows == 0) block_rows = compptr->v_samp_factor;
      }
!     blocks_across = compptr->width_in_data_units;
      h_samp_factor = compptr->h_samp_factor;
      /* Count number of dummy blocks to be added at the right margin. */
      ndummy = (int) (blocks_across % h_samp_factor);
***************
*** 279,285 ****
       */
      for (block_row = 0; block_row < block_rows; block_row++) {
        thisblockrow = buffer[block_row];
!       (*cinfo->fdct->forward_DCT) (cinfo, compptr,
  				   input_buf[ci], thisblockrow,
  				   (JDIMENSION) (block_row * DCTSIZE),
  				   (JDIMENSION) 0, blocks_across);
--- 282,288 ----
       */
      for (block_row = 0; block_row < block_rows; block_row++) {
        thisblockrow = buffer[block_row];
!       (*lossyc->fdct_forward_DCT) (cinfo, compptr,
  				   input_buf[ci], thisblockrow,
  				   (JDIMENSION) (block_row * DCTSIZE),
  				   (JDIMENSION) 0, blocks_across);
***************
*** 340,346 ****
  METHODDEF(boolean)
  compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
  {
!   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
    JDIMENSION MCU_col_num;	/* index of current MCU within row */
    int blkn, ci, xindex, yindex, yoffset;
    JDIMENSION start_col;
--- 343,350 ----
  METHODDEF(boolean)
  compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
  {
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   c_coef_ptr coef = (c_coef_ptr) lossyc->coef_private;
    JDIMENSION MCU_col_num;	/* index of current MCU within row */
    int blkn, ci, xindex, yindex, yoffset;
    JDIMENSION start_col;
***************
*** 378,384 ****
  	}
        }
        /* Try to write the MCU. */
!       if (! (*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {
  	/* Suspension forced; update state counters and exit */
  	coef->MCU_vert_offset = yoffset;
  	coef->mcu_ctr = MCU_col_num;
--- 382,388 ----
  	}
        }
        /* Try to write the MCU. */
!       if (! (*lossyc->entropy_encode_mcu) (cinfo, coef->MCU_buffer)) {
  	/* Suspension forced; update state counters and exit */
  	coef->MCU_vert_offset = yoffset;
  	coef->mcu_ctr = MCU_col_num;
***************
*** 404,416 ****
  GLOBAL(void)
  jinit_c_coef_controller (j_compress_ptr cinfo, boolean need_full_buffer)
  {
!   my_coef_ptr coef;
  
!   coef = (my_coef_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				SIZEOF(my_coef_controller));
!   cinfo->coef = (struct jpeg_c_coef_controller *) coef;
!   coef->pub.start_pass = start_pass_coef;
  
    /* Create the coefficient buffer. */
    if (need_full_buffer) {
--- 408,421 ----
  GLOBAL(void)
  jinit_c_coef_controller (j_compress_ptr cinfo, boolean need_full_buffer)
  {
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   c_coef_ptr coef;
  
!   coef = (c_coef_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				SIZEOF(c_coef_controller));
!   lossyc->coef_private = (struct jpeg_c_coef_controller *) coef;
!   lossyc->coef_start_pass = start_pass_coef;
  
    /* Create the coefficient buffer. */
    if (need_full_buffer) {
***************
*** 424,432 ****
  	 ci++, compptr++) {
        coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
  	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
! 	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
  				(long) compptr->h_samp_factor),
! 	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
  				(long) compptr->v_samp_factor),
  	 (JDIMENSION) compptr->v_samp_factor);
      }
--- 429,437 ----
  	 ci++, compptr++) {
        coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
  	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
! 	 (JDIMENSION) jround_up((long) compptr->width_in_data_units,
  				(long) compptr->h_samp_factor),
! 	 (JDIMENSION) jround_up((long) compptr->height_in_data_units,
  				(long) compptr->v_samp_factor),
  	 (JDIMENSION) compptr->v_samp_factor);
      }
***************
*** 440,447 ****
  
      buffer = (JBLOCKROW)
        (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				  C_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
!     for (i = 0; i < C_MAX_BLOCKS_IN_MCU; i++) {
        coef->MCU_buffer[i] = buffer + i;
      }
      coef->whole_image[0] = NULL; /* flag for no virtual arrays */
--- 445,452 ----
  
      buffer = (JBLOCKROW)
        (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				  C_MAX_DATA_UNITS_IN_MCU * SIZEOF(JBLOCK));
!     for (i = 0; i < C_MAX_DATA_UNITS_IN_MCU; i++) {
        coef->MCU_buffer[i] = buffer + i;
      }
      coef->whole_image[0] = NULL; /* flag for no virtual arrays */
diff -cN ../jpeg-6b/jcdctmgr.c ./jcdctmgr.c
*** ../jpeg-6b/jcdctmgr.c	Sat Jan 13 14:15:12 1996
--- ./jcdctmgr.c	Tue Apr 27 14:58:16 1999
***************
*** 1,7 ****
  /*
   * jcdctmgr.c
   *
!  * Copyright (C) 1994-1996, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jcdctmgr.c
   *
!  * Copyright (C) 1994-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 14,19 ****
--- 14,20 ----
  #define JPEG_INTERNALS
  #include "jinclude.h"
  #include "jpeglib.h"
+ #include "jlossy.h"		/* Private declarations for lossy codec */
  #include "jdct.h"		/* Private declarations for DCT subsystem */
  
  
***************
*** 20,27 ****
  /* Private subobject for this module */
  
  typedef struct {
-   struct jpeg_forward_dct pub;	/* public fields */
- 
    /* Pointer to the DCT routine actually in use */
    forward_DCT_method_ptr do_dct;
  
--- 21,26 ----
***************
*** 36,44 ****
    float_DCT_method_ptr do_float_dct;
    FAST_FLOAT * float_divisors[NUM_QUANT_TBLS];
  #endif
! } my_fdct_controller;
  
! typedef my_fdct_controller * my_fdct_ptr;
  
  
  /*
--- 35,43 ----
    float_DCT_method_ptr do_float_dct;
    FAST_FLOAT * float_divisors[NUM_QUANT_TBLS];
  #endif
! } fdct_controller;
  
! typedef fdct_controller * fdct_ptr;
  
  
  /*
***************
*** 53,59 ****
  METHODDEF(void)
  start_pass_fdctmgr (j_compress_ptr cinfo)
  {
!   my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
    int ci, qtblno, i;
    jpeg_component_info *compptr;
    JQUANT_TBL * qtbl;
--- 52,59 ----
  METHODDEF(void)
  start_pass_fdctmgr (j_compress_ptr cinfo)
  {
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   fdct_ptr fdct = (fdct_ptr) lossyc->fdct_private;
    int ci, qtblno, i;
    jpeg_component_info *compptr;
    JQUANT_TBL * qtbl;
***************
*** 184,190 ****
  /* This version is used for integer DCT implementations. */
  {
    /* This routine is heavily used, so it's worth coding it tightly. */
!   my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
    forward_DCT_method_ptr do_dct = fdct->do_dct;
    DCTELEM * divisors = fdct->divisors[compptr->quant_tbl_no];
    DCTELEM workspace[DCTSIZE2];	/* work area for FDCT subroutine */
--- 184,191 ----
  /* This version is used for integer DCT implementations. */
  {
    /* This routine is heavily used, so it's worth coding it tightly. */
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   fdct_ptr fdct = (fdct_ptr) lossyc->fdct_private;
    forward_DCT_method_ptr do_dct = fdct->do_dct;
    DCTELEM * divisors = fdct->divisors[compptr->quant_tbl_no];
    DCTELEM workspace[DCTSIZE2];	/* work area for FDCT subroutine */
***************
*** 274,280 ****
  /* This version is used for floating-point DCT implementations. */
  {
    /* This routine is heavily used, so it's worth coding it tightly. */
!   my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
    float_DCT_method_ptr do_dct = fdct->do_float_dct;
    FAST_FLOAT * divisors = fdct->float_divisors[compptr->quant_tbl_no];
    FAST_FLOAT workspace[DCTSIZE2]; /* work area for FDCT subroutine */
--- 275,282 ----
  /* This version is used for floating-point DCT implementations. */
  {
    /* This routine is heavily used, so it's worth coding it tightly. */
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   fdct_ptr fdct = (fdct_ptr) lossyc->fdct_private;
    float_DCT_method_ptr do_dct = fdct->do_float_dct;
    FAST_FLOAT * divisors = fdct->float_divisors[compptr->quant_tbl_no];
    FAST_FLOAT workspace[DCTSIZE2]; /* work area for FDCT subroutine */
***************
*** 344,374 ****
  GLOBAL(void)
  jinit_forward_dct (j_compress_ptr cinfo)
  {
!   my_fdct_ptr fdct;
    int i;
  
!   fdct = (my_fdct_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				SIZEOF(my_fdct_controller));
!   cinfo->fdct = (struct jpeg_forward_dct *) fdct;
!   fdct->pub.start_pass = start_pass_fdctmgr;
  
    switch (cinfo->dct_method) {
  #ifdef DCT_ISLOW_SUPPORTED
    case JDCT_ISLOW:
!     fdct->pub.forward_DCT = forward_DCT;
      fdct->do_dct = jpeg_fdct_islow;
      break;
  #endif
  #ifdef DCT_IFAST_SUPPORTED
    case JDCT_IFAST:
!     fdct->pub.forward_DCT = forward_DCT;
      fdct->do_dct = jpeg_fdct_ifast;
      break;
  #endif
  #ifdef DCT_FLOAT_SUPPORTED
    case JDCT_FLOAT:
!     fdct->pub.forward_DCT = forward_DCT_float;
      fdct->do_float_dct = jpeg_fdct_float;
      break;
  #endif
--- 346,377 ----
  GLOBAL(void)
  jinit_forward_dct (j_compress_ptr cinfo)
  {
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   fdct_ptr fdct;
    int i;
  
!   fdct = (fdct_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				SIZEOF(fdct_controller));
!   lossyc->fdct_private = (struct jpeg_forward_dct *) fdct;
!   lossyc->fdct_start_pass = start_pass_fdctmgr;
  
    switch (cinfo->dct_method) {
  #ifdef DCT_ISLOW_SUPPORTED
    case JDCT_ISLOW:
!     lossyc->fdct_forward_DCT = forward_DCT;
      fdct->do_dct = jpeg_fdct_islow;
      break;
  #endif
  #ifdef DCT_IFAST_SUPPORTED
    case JDCT_IFAST:
!     lossyc->fdct_forward_DCT = forward_DCT;
      fdct->do_dct = jpeg_fdct_ifast;
      break;
  #endif
  #ifdef DCT_FLOAT_SUPPORTED
    case JDCT_FLOAT:
!     lossyc->fdct_forward_DCT = forward_DCT_float;
      fdct->do_float_dct = jpeg_fdct_float;
      break;
  #endif
diff -cN ../jpeg-6b/jcdiffct.c ./jcdiffct.c
*** ../jpeg-6b/jcdiffct.c
--- ./jcdiffct.c	Tue Apr 27 14:58:17 1999
***************
*** 0 ****
--- 1,409 ----
+ /*
+  * jcdiffct.c
+  *
+  * Copyright (C) 1994-1998, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+  * This file contains the difference buffer controller for compression.
+  * This controller is the top level of the lossless JPEG compressor proper.
+  * The difference buffer lies between prediction/differencing and entropy
+  * encoding.
+  */
+ 
+ #define JPEG_INTERNALS
+ #include "jinclude.h"
+ #include "jpeglib.h"
+ #include "jlossls.h"		/* Private declarations for lossless codec */
+ 
+ 
+ #ifdef C_LOSSLESS_SUPPORTED
+ 
+ /* We use a full-image sample buffer when doing Huffman optimization,
+  * and also for writing multiple-scan JPEG files.  In all cases, the
+  * full-image buffer is filled during the first pass, and the scaling,
+  * prediction and differencing steps are run during subsequent passes.
+  */
+ #ifdef ENTROPY_OPT_SUPPORTED
+ #define FULL_SAMP_BUFFER_SUPPORTED
+ #else
+ #ifdef C_MULTISCAN_FILES_SUPPORTED
+ #define FULL_SAMP_BUFFER_SUPPORTED
+ #endif
+ #endif
+ 
+ 
+ /* Private buffer controller object */
+ 
+ typedef struct {
+   JDIMENSION iMCU_row_num;	/* iMCU row # within image */
+   JDIMENSION mcu_ctr;		/* counts MCUs processed in current row */
+   int MCU_vert_offset;		/* counts MCU rows within iMCU row */
+   int MCU_rows_per_iMCU_row;	/* number of such rows needed */
+ 
+   JSAMPROW cur_row[MAX_COMPONENTS];	/* row of point transformed samples */
+   JSAMPROW prev_row[MAX_COMPONENTS];	/* previous row of Pt'd samples */
+   JDIFFARRAY diff_buf[MAX_COMPONENTS];	/* iMCU row of differences */
+ 
+   /* In multi-pass modes, we need a virtual sample array for each component. */
+   jvirt_sarray_ptr whole_image[MAX_COMPONENTS];
+ } c_diff_controller;
+ 
+ typedef c_diff_controller * c_diff_ptr;
+ 
+ 
+ /* Forward declarations */
+ METHODDEF(boolean) compress_data
+     JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf));
+ #ifdef FULL_SAMP_BUFFER_SUPPORTED
+ METHODDEF(boolean) compress_first_pass
+     JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf));
+ METHODDEF(boolean) compress_output
+     JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf));
+ #endif
+ 
+ 
+ LOCAL(void)
+ start_iMCU_row (j_compress_ptr cinfo)
+ /* Reset within-iMCU-row counters for a new row */
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+   c_diff_ptr diff = (c_diff_ptr) losslsc->diff_private;
+ 
+   /* In an interleaved scan, an MCU row is the same as an iMCU row.
+    * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
+    * But at the bottom of the image, process only what's left.
+    */
+   if (cinfo->comps_in_scan > 1) {
+     diff->MCU_rows_per_iMCU_row = 1;
+   } else {
+     if (diff->iMCU_row_num < (cinfo->total_iMCU_rows-1))
+       diff->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
+     else
+       diff->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
+   }
+ 
+   diff->mcu_ctr = 0;
+   diff->MCU_vert_offset = 0;
+ }
+ 
+ 
+ /*
+  * Initialize for a processing pass.
+  */
+ 
+ METHODDEF(void)
+ start_pass_diff (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+   c_diff_ptr diff = (c_diff_ptr) losslsc->diff_private;
+ 
+   diff->iMCU_row_num = 0;
+   start_iMCU_row(cinfo);
+ 
+   switch (pass_mode) {
+   case JBUF_PASS_THRU:
+     if (diff->whole_image[0] != NULL)
+       ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
+     losslsc->pub.compress_data = compress_data;
+     break;
+ #ifdef FULL_SAMP_BUFFER_SUPPORTED
+   case JBUF_SAVE_AND_PASS:
+     if (diff->whole_image[0] == NULL)
+       ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
+     losslsc->pub.compress_data = compress_first_pass;
+     break;
+   case JBUF_CRANK_DEST:
+     if (diff->whole_image[0] == NULL)
+       ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
+     losslsc->pub.compress_data = compress_output;
+     break;
+ #endif
+   default:
+     ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
+     break;
+   }
+ }
+ 
+ 
+ #define SWAP_ROWS(rowa,rowb) {JSAMPROW temp; temp=rowa; rowa=rowb; rowb=temp;}
+ 
+ /*
+  * Process some data in the single-pass case.
+  * We process the equivalent of one fully interleaved MCU row ("iMCU" row)
+  * per call, ie, v_samp_factor rows for each component in the image.
+  * Returns TRUE if the iMCU row is completed, FALSE if suspended.
+  *
+  * NB: input_buf contains a plane for each component in image,
+  * which we index according to the component's SOF position.
+  */
+ 
+ METHODDEF(boolean)
+ compress_data (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+   c_diff_ptr diff = (c_diff_ptr) losslsc->diff_private;
+   JDIMENSION MCU_col_num;	/* index of current MCU within row */
+   JDIMENSION MCU_count;		/* number of MCUs encoded */
+   JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
+   JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
+   int comp, ci, yoffset, samp_row, samp_rows, samps_across;
+   jpeg_component_info *compptr;
+ 
+   /* Loop to write as much as one whole iMCU row */
+   for (yoffset = diff->MCU_vert_offset; yoffset < diff->MCU_rows_per_iMCU_row;
+        yoffset++) {
+ 
+     MCU_col_num = diff->mcu_ctr;
+ 
+     /* Scale and predict each scanline of the MCU-row separately.
+      *
+      * Note: We only do this if we are at the start of a MCU-row, ie,
+      * we don't want to reprocess a row suspended by the output.
+      */
+     if (MCU_col_num == 0) {
+       for (comp = 0; comp < cinfo->comps_in_scan; comp++) {
+ 	compptr = cinfo->cur_comp_info[comp];
+ 	ci = compptr->component_index;
+ 	if (diff->iMCU_row_num < last_iMCU_row)
+ 	  samp_rows = compptr->v_samp_factor;
+ 	else {
+ 	  /* NB: can't use last_row_height here, since may not be set! */
+ 	  samp_rows = (int) (compptr->height_in_data_units % compptr->v_samp_factor);
+ 	  if (samp_rows == 0) samp_rows = compptr->v_samp_factor;
+ 	  else {
+ 	    /* Fill dummy difference rows at the bottom edge with zeros, which
+ 	     * will encode to the smallest amount of data.
+ 	     */
+ 	    for (samp_row = samp_rows; samp_row < compptr->v_samp_factor;
+ 		 samp_row++)
+ 	      MEMZERO(diff->diff_buf[ci][samp_row],
+ 		      jround_up((long) compptr->width_in_data_units,
+ 				(long) compptr->h_samp_factor) * SIZEOF(JDIFF));
+ 	  }
+ 	}
+ 	samps_across = compptr->width_in_data_units;
+ 
+ 	for (samp_row = 0; samp_row < samp_rows; samp_row++) {
+ 	  (*losslsc->scaler_scale) (cinfo,
+ 				    input_buf[ci][samp_row],
+ 				    diff->cur_row[ci], samps_across);
+ 	  (*losslsc->predict_difference[ci]) (cinfo, ci,
+ 					      diff->cur_row[ci],
+ 					      diff->prev_row[ci],
+ 					      diff->diff_buf[ci][samp_row],
+ 					      samps_across);
+ 	  SWAP_ROWS(diff->cur_row[ci], diff->prev_row[ci]);
+ 	}
+       }
+     }
+ 
+     /* Try to write the MCU-row (or remaining portion of suspended MCU-row). */
+     MCU_count =
+       (*losslsc->entropy_encode_mcus) (cinfo,
+ 				       diff->diff_buf, yoffset, MCU_col_num,
+ 				       cinfo->MCUs_per_row - MCU_col_num);
+     if (MCU_count != cinfo->MCUs_per_row - MCU_col_num) {
+       /* Suspension forced; update state counters and exit */
+       diff->MCU_vert_offset = yoffset;
+       diff->mcu_ctr += MCU_col_num;
+       return FALSE;
+     }
+ 
+     /* Completed an MCU row, but perhaps not an iMCU row */
+     diff->mcu_ctr = 0;
+   }
+ 
+   /* Completed the iMCU row, advance counters for next one */
+   diff->iMCU_row_num++;
+   start_iMCU_row(cinfo);
+   return TRUE;
+ }
+ 
+ 
+ #ifdef FULL_SAMP_BUFFER_SUPPORTED
+ 
+ /*
+  * Process some data in the first pass of a multi-pass case.
+  * We process the equivalent of one fully interleaved MCU row ("iMCU" row)
+  * per call, ie, v_samp_factor rows for each component in the image.
+  * This amount of data is read from the source buffer and saved into the
+  * virtual arrays.
+  *
+  * We must also emit the data to the compressor.  This is conveniently
+  * done by calling compress_output() after we've loaded the current strip
+  * of the virtual arrays.
+  *
+  * NB: input_buf contains a plane for each component in image.  All components
+  * are loaded into the virtual arrays in this pass.  However, it may be that
+  * only a subset of the components are emitted to the compressor during
+  * this first pass; be careful about looking at the scan-dependent variables
+  * (MCU dimensions, etc).
+  */
+ 
+ METHODDEF(boolean)
+ compress_first_pass (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+   c_diff_ptr diff = (c_diff_ptr) losslsc->diff_private;
+   JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
+   JDIMENSION samps_across;
+   int ci, samp_row, samp_rows;
+   JSAMPARRAY buffer[MAX_COMPONENTS];
+   jpeg_component_info *compptr;
+ 
+   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
+        ci++, compptr++) {
+     /* Align the virtual buffers for this component. */
+     buffer[ci] = (*cinfo->mem->access_virt_sarray)
+       ((j_common_ptr) cinfo, diff->whole_image[ci],
+        diff->iMCU_row_num * compptr->v_samp_factor,
+        (JDIMENSION) compptr->v_samp_factor, TRUE);
+ 
+     /* Count non-dummy sample rows in this iMCU row. */
+     if (diff->iMCU_row_num < last_iMCU_row)
+       samp_rows = compptr->v_samp_factor;
+     else {
+       /* NB: can't use last_row_height here, since may not be set! */
+       samp_rows = (int) (compptr->height_in_data_units % compptr->v_samp_factor);
+       if (samp_rows == 0) samp_rows = compptr->v_samp_factor;
+     }
+     samps_across = compptr->width_in_data_units;
+ 
+     /* Perform point transform scaling and prediction/differencing for all
+      * non-dummy rows in this iMCU row.  Each call on these functions
+      * process a complete row of samples.
+      */
+     for (samp_row = 0; samp_row < samp_rows; samp_row++) {
+       MEMCOPY(buffer[ci][samp_row], input_buf[ci][samp_row],
+ 	      samps_across * SIZEOF(JSAMPLE));
+     }
+   }
+ 
+   /* NB: compress_output will increment iMCU_row_num if successful.
+    * A suspension return will result in redoing all the work above next time.
+    */
+ 
+   /* Emit data to the compressor, sharing code with subsequent passes */
+   return compress_output(cinfo, input_buf);
+ }
+ 
+ 
+ /*
+  * Process some data in subsequent passes of a multi-pass case.
+  * We process the equivalent of one fully interleaved MCU row ("iMCU" row)
+  * per call, ie, v_samp_factor rows for each component in the scan.
+  * The data is obtained from the virtual arrays and fed to the compressor.
+  * Returns TRUE if the iMCU row is completed, FALSE if suspended.
+  *
+  * NB: input_buf is ignored; it is likely to be a NULL pointer.
+  */
+ 
+ METHODDEF(boolean)
+ compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+   c_diff_ptr diff = (c_diff_ptr) losslsc->diff_private;
+   JDIMENSION MCU_col_num;	/* index of current MCU within row */
+   JDIMENSION MCU_count;		/* number of MCUs encoded */
+   int comp, ci, yoffset;
+   JSAMPARRAY buffer[MAX_COMPONENTS];
+   jpeg_component_info *compptr;
+ 
+   /* Align the virtual buffers for the components used in this scan.
+    * NB: during first pass, this is safe only because the buffers will
+    * already be aligned properly, so jmemmgr.c won't need to do any I/O.
+    */
+   for (comp = 0; comp < cinfo->comps_in_scan; comp++) {
+     compptr = cinfo->cur_comp_info[comp];
+     ci = compptr->component_index;
+     buffer[ci] = (*cinfo->mem->access_virt_sarray)
+       ((j_common_ptr) cinfo, diff->whole_image[ci],
+        diff->iMCU_row_num * compptr->v_samp_factor,
+        (JDIMENSION) compptr->v_samp_factor, FALSE);
+   }
+ 
+   return compress_data(cinfo, buffer);
+ }
+ 
+ #endif /* FULL_SAMP_BUFFER_SUPPORTED */
+ 
+ 
+ /*
+  * Initialize difference buffer controller.
+  */
+ 
+ GLOBAL(void)
+ jinit_c_diff_controller (j_compress_ptr cinfo, boolean need_full_buffer)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+   c_diff_ptr diff;
+   int ci, row;
+   jpeg_component_info *compptr;
+ 
+   diff = (c_diff_ptr)
+     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
+ 				SIZEOF(c_diff_controller));
+   losslsc->diff_private = (void *) diff;
+   losslsc->diff_start_pass = start_pass_diff;
+ 
+   /* Create the prediction row buffers. */
+   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
+        ci++, compptr++) {
+     diff->cur_row[ci] = *(*cinfo->mem->alloc_sarray)
+       ((j_common_ptr) cinfo, JPOOL_IMAGE,
+        (JDIMENSION) jround_up((long) compptr->width_in_data_units,
+ 			      (long) compptr->h_samp_factor),
+        (JDIMENSION) 1);
+     diff->prev_row[ci] = *(*cinfo->mem->alloc_sarray)
+       ((j_common_ptr) cinfo, JPOOL_IMAGE,
+        (JDIMENSION) jround_up((long) compptr->width_in_data_units,
+ 			      (long) compptr->h_samp_factor),
+        (JDIMENSION) 1);
+   }
+ 
+   /* Create the difference buffer. */
+   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
+        ci++, compptr++) {
+     diff->diff_buf[ci] = (*cinfo->mem->alloc_darray)
+       ((j_common_ptr) cinfo, JPOOL_IMAGE,
+        (JDIMENSION) jround_up((long) compptr->width_in_data_units,
+ 			      (long) compptr->h_samp_factor),
+        (JDIMENSION) compptr->v_samp_factor);
+     /* Prefill difference rows with zeros.  We do this because only actual
+      * data is placed in the buffers during prediction/differencing, leaving
+      * any dummy differences at the right edge as zeros, which will encode
+      * to the smallest amount of data.
+      */
+     for (row = 0; row < compptr->v_samp_factor; row++)
+       MEMZERO(diff->diff_buf[ci][row],
+ 	      jround_up((long) compptr->width_in_data_units,
+ 			(long) compptr->h_samp_factor) * SIZEOF(JDIFF));
+   }
+ 
+   /* Create the sample buffer. */
+   if (need_full_buffer) {
+ #ifdef FULL_SAMP_BUFFER_SUPPORTED
+     /* Allocate a full-image virtual array for each component, */
+     /* padded to a multiple of samp_factor differences in each direction. */
+     int ci;
+     jpeg_component_info *compptr;
+ 
+     for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
+ 	 ci++, compptr++) {
+       diff->whole_image[ci] = (*cinfo->mem->request_virt_sarray)
+ 	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
+ 	 (JDIMENSION) jround_up((long) compptr->width_in_data_units,
+ 				(long) compptr->h_samp_factor),
+ 	 (JDIMENSION) jround_up((long) compptr->height_in_data_units,
+ 				(long) compptr->v_samp_factor),
+ 	 (JDIMENSION) compptr->v_samp_factor);
+     }
+ #else
+     ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
+ #endif
+   } else
+     diff->whole_image[0] = NULL; /* flag for no virtual arrays */
+ }
+ 
+ #endif /* C_LOSSLESS_SUPPORTED */
diff -cN ../jpeg-6b/jchuff.c ./jchuff.c
*** ../jpeg-6b/jchuff.c	Mon Oct 20 20:20:39 1997
--- ./jchuff.c	Tue Apr 27 14:58:17 1999
***************
*** 1,178 ****
  /*
   * jchuff.c
   *
!  * Copyright (C) 1991-1997, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
!  * This file contains Huffman entropy encoding routines.
!  *
!  * Much of the complexity here has to do with supporting output suspension.
!  * If the data destination module demands suspension, we want to be able to
!  * back up to the start of the current MCU.  To do this, we copy state
!  * variables into local working storage, and update them back to the
!  * permanent JPEG objects only upon successful completion of an MCU.
   */
  
  #define JPEG_INTERNALS
  #include "jinclude.h"
  #include "jpeglib.h"
! #include "jchuff.h"		/* Declarations shared with jcphuff.c */
! 
! 
! /* Expanded entropy encoder object for Huffman encoding.
!  *
!  * The savable_state subrecord contains fields that change within an MCU,
!  * but must not be updated permanently until we complete the MCU.
!  */
! 
! typedef struct {
!   INT32 put_buffer;		/* current bit-accumulation buffer */
!   int put_bits;			/* # of bits now in it */
!   int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */
! } savable_state;
! 
! /* This macro is to work around compilers with missing or broken
!  * structure assignment.  You'll need to fix this code if you have
!  * such a compiler and you change MAX_COMPS_IN_SCAN.
!  */
! 
! #ifndef NO_STRUCT_ASSIGN
! #define ASSIGN_STATE(dest,src)  ((dest) = (src))
! #else
! #if MAX_COMPS_IN_SCAN == 4
! #define ASSIGN_STATE(dest,src)  \
! 	((dest).put_buffer = (src).put_buffer, \
! 	 (dest).put_bits = (src).put_bits, \
! 	 (dest).last_dc_val[0] = (src).last_dc_val[0], \
! 	 (dest).last_dc_val[1] = (src).last_dc_val[1], \
! 	 (dest).last_dc_val[2] = (src).last_dc_val[2], \
! 	 (dest).last_dc_val[3] = (src).last_dc_val[3])
! #endif
! #endif
! 
! 
! typedef struct {
!   struct jpeg_entropy_encoder pub; /* public fields */
! 
!   savable_state saved;		/* Bit buffer & DC state at start of MCU */
! 
!   /* These fields are NOT loaded into local working state. */
!   unsigned int restarts_to_go;	/* MCUs left in this restart interval */
!   int next_restart_num;		/* next restart number to write (0-7) */
! 
!   /* Pointers to derived tables (these workspaces have image lifespan) */
!   c_derived_tbl * dc_derived_tbls[NUM_HUFF_TBLS];
!   c_derived_tbl * ac_derived_tbls[NUM_HUFF_TBLS];
! 
! #ifdef ENTROPY_OPT_SUPPORTED	/* Statistics tables for optimization */
!   long * dc_count_ptrs[NUM_HUFF_TBLS];
!   long * ac_count_ptrs[NUM_HUFF_TBLS];
! #endif
! } huff_entropy_encoder;
! 
! typedef huff_entropy_encoder * huff_entropy_ptr;
! 
! /* Working state while writing an MCU.
!  * This struct contains all the fields that are needed by subroutines.
!  */
! 
! typedef struct {
!   JOCTET * next_output_byte;	/* => next byte to write in buffer */
!   size_t free_in_buffer;	/* # of byte spaces remaining in buffer */
!   savable_state cur;		/* Current bit buffer & DC state */
!   j_compress_ptr cinfo;		/* dump_buffer needs access to this */
! } working_state;
! 
! 
! /* Forward declarations */
! METHODDEF(boolean) encode_mcu_huff JPP((j_compress_ptr cinfo,
! 					JBLOCKROW *MCU_data));
! METHODDEF(void) finish_pass_huff JPP((j_compress_ptr cinfo));
! #ifdef ENTROPY_OPT_SUPPORTED
! METHODDEF(boolean) encode_mcu_gather JPP((j_compress_ptr cinfo,
! 					  JBLOCKROW *MCU_data));
! METHODDEF(void) finish_pass_gather JPP((j_compress_ptr cinfo));
! #endif
! 
! 
! /*
!  * Initialize for a Huffman-compressed scan.
!  * If gather_statistics is TRUE, we do not output anything during the scan,
!  * just count the Huffman symbols used and generate Huffman code tables.
!  */
! 
! METHODDEF(void)
! start_pass_huff (j_compress_ptr cinfo, boolean gather_statistics)
! {
!   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
!   int ci, dctbl, actbl;
!   jpeg_component_info * compptr;
! 
!   if (gather_statistics) {
! #ifdef ENTROPY_OPT_SUPPORTED
!     entropy->pub.encode_mcu = encode_mcu_gather;
!     entropy->pub.finish_pass = finish_pass_gather;
! #else
!     ERREXIT(cinfo, JERR_NOT_COMPILED);
! #endif
!   } else {
!     entropy->pub.encode_mcu = encode_mcu_huff;
!     entropy->pub.finish_pass = finish_pass_huff;
!   }
! 
!   for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
!     compptr = cinfo->cur_comp_info[ci];
!     dctbl = compptr->dc_tbl_no;
!     actbl = compptr->ac_tbl_no;
!     if (gather_statistics) {
! #ifdef ENTROPY_OPT_SUPPORTED
!       /* Check for invalid table indexes */
!       /* (make_c_derived_tbl does this in the other path) */
!       if (dctbl < 0 || dctbl >= NUM_HUFF_TBLS)
! 	ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, dctbl);
!       if (actbl < 0 || actbl >= NUM_HUFF_TBLS)
! 	ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, actbl);
!       /* Allocate and zero the statistics tables */
!       /* Note that jpeg_gen_optimal_table expects 257 entries in each table! */
!       if (entropy->dc_count_ptrs[dctbl] == NULL)
! 	entropy->dc_count_ptrs[dctbl] = (long *)
! 	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				      257 * SIZEOF(long));
!       MEMZERO(entropy->dc_count_ptrs[dctbl], 257 * SIZEOF(long));
!       if (entropy->ac_count_ptrs[actbl] == NULL)
! 	entropy->ac_count_ptrs[actbl] = (long *)
! 	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				      257 * SIZEOF(long));
!       MEMZERO(entropy->ac_count_ptrs[actbl], 257 * SIZEOF(long));
! #endif
!     } else {
!       /* Compute derived values for Huffman tables */
!       /* We may do this more than once for a table, but it's not expensive */
!       jpeg_make_c_derived_tbl(cinfo, TRUE, dctbl,
! 			      & entropy->dc_derived_tbls[dctbl]);
!       jpeg_make_c_derived_tbl(cinfo, FALSE, actbl,
! 			      & entropy->ac_derived_tbls[actbl]);
!     }
!     /* Initialize DC predictions to 0 */
!     entropy->saved.last_dc_val[ci] = 0;
!   }
! 
!   /* Initialize bit buffer to empty */
!   entropy->saved.put_buffer = 0;
!   entropy->saved.put_bits = 0;
! 
!   /* Initialize restart stuff */
!   entropy->restarts_to_go = cinfo->restart_interval;
!   entropy->next_restart_num = 0;
! }
  
  
  /*
   * Compute the derived values for a Huffman table.
   * This routine also performs some validation checks on the table.
-  *
-  * Note this is also used by jcphuff.c.
   */
  
  GLOBAL(void)
--- 1,23 ----
  /*
   * jchuff.c
   *
!  * Copyright (C) 1991-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
!  * This file contains Huffman entropy decoding routines which are shared
!  * by the sequential, progressive and lossless decoders.
   */
  
  #define JPEG_INTERNALS
  #include "jinclude.h"
  #include "jpeglib.h"
! #include "jchuff.h"		/* Declarations shared with jc*huff.c */
  
  
  /*
   * Compute the derived values for a Huffman table.
   * This routine also performs some validation checks on the table.
   */
  
  GLOBAL(void)
***************
*** 249,258 ****
  
    /* This is also a convenient place to check for out-of-range
     * and duplicated VAL entries.  We allow 0..255 for AC symbols
!    * but only 0..15 for DC.  (We could constrain them further
     * based on data depth and mode, but this seems enough.)
     */
!   maxsymbol = isDC ? 15 : 255;
  
    for (p = 0; p < lastp; p++) {
      i = htbl->huffval[p];
--- 94,103 ----
  
    /* This is also a convenient place to check for out-of-range
     * and duplicated VAL entries.  We allow 0..255 for AC symbols
!    * but only 0..16 for DC.  (We could constrain them further
     * based on data depth and mode, but this seems enough.)
     */
!   maxsymbol = isDC ? 16 : 255;
  
    for (p = 0; p < lastp; p++) {
      i = htbl->huffval[p];
***************
*** 264,681 ****
  }
  
  
- /* Outputting bytes to the file */
- 
- /* Emit a byte, taking 'action' if must suspend. */
- #define emit_byte(state,val,action)  \
- 	{ *(state)->next_output_byte++ = (JOCTET) (val);  \
- 	  if (--(state)->free_in_buffer == 0)  \
- 	    if (! dump_buffer(state))  \
- 	      { action; } }
- 
- 
- LOCAL(boolean)
- dump_buffer (working_state * state)
- /* Empty the output buffer; return TRUE if successful, FALSE if must suspend */
- {
-   struct jpeg_destination_mgr * dest = state->cinfo->dest;
- 
-   if (! (*dest->empty_output_buffer) (state->cinfo))
-     return FALSE;
-   /* After a successful buffer dump, must reset buffer pointers */
-   state->next_output_byte = dest->next_output_byte;
-   state->free_in_buffer = dest->free_in_buffer;
-   return TRUE;
- }
- 
- 
- /* Outputting bits to the file */
- 
- /* Only the right 24 bits of put_buffer are used; the valid bits are
-  * left-justified in this part.  At most 16 bits can be passed to emit_bits
-  * in one call, and we never retain more than 7 bits in put_buffer
-  * between calls, so 24 bits are sufficient.
-  */
- 
- INLINE
- LOCAL(boolean)
- emit_bits (working_state * state, unsigned int code, int size)
- /* Emit some bits; return TRUE if successful, FALSE if must suspend */
- {
-   /* This routine is heavily used, so it's worth coding tightly. */
-   register INT32 put_buffer = (INT32) code;
-   register int put_bits = state->cur.put_bits;
- 
-   /* if size is 0, caller used an invalid Huffman table entry */
-   if (size == 0)
-     ERREXIT(state->cinfo, JERR_HUFF_MISSING_CODE);
- 
-   put_buffer &= (((INT32) 1)<<size) - 1; /* mask off any extra bits in code */
-   
-   put_bits += size;		/* new number of bits in buffer */
-   
-   put_buffer <<= 24 - put_bits; /* align incoming bits */
- 
-   put_buffer |= state->cur.put_buffer; /* and merge with old buffer contents */
-   
-   while (put_bits >= 8) {
-     int c = (int) ((put_buffer >> 16) & 0xFF);
-     
-     emit_byte(state, c, return FALSE);
-     if (c == 0xFF) {		/* need to stuff a zero byte? */
-       emit_byte(state, 0, return FALSE);
-     }
-     put_buffer <<= 8;
-     put_bits -= 8;
-   }
- 
-   state->cur.put_buffer = put_buffer; /* update state variables */
-   state->cur.put_bits = put_bits;
- 
-   return TRUE;
- }
- 
- 
- LOCAL(boolean)
- flush_bits (working_state * state)
- {
-   if (! emit_bits(state, 0x7F, 7)) /* fill any partial byte with ones */
-     return FALSE;
-   state->cur.put_buffer = 0;	/* and reset bit-buffer to empty */
-   state->cur.put_bits = 0;
-   return TRUE;
- }
- 
- 
- /* Encode a single block's worth of coefficients */
- 
- LOCAL(boolean)
- encode_one_block (working_state * state, JCOEFPTR block, int last_dc_val,
- 		  c_derived_tbl *dctbl, c_derived_tbl *actbl)
- {
-   register int temp, temp2;
-   register int nbits;
-   register int k, r, i;
-   
-   /* Encode the DC coefficient difference per section F.1.2.1 */
-   
-   temp = temp2 = block[0] - last_dc_val;
- 
-   if (temp < 0) {
-     temp = -temp;		/* temp is abs value of input */
-     /* For a negative input, want temp2 = bitwise complement of abs(input) */
-     /* This code assumes we are on a two's complement machine */
-     temp2--;
-   }
-   
-   /* Find the number of bits needed for the magnitude of the coefficient */
-   nbits = 0;
-   while (temp) {
-     nbits++;
-     temp >>= 1;
-   }
-   /* Check for out-of-range coefficient values.
-    * Since we're encoding a difference, the range limit is twice as much.
-    */
-   if (nbits > MAX_COEF_BITS+1)
-     ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);
-   
-   /* Emit the Huffman-coded symbol for the number of bits */
-   if (! emit_bits(state, dctbl->ehufco[nbits], dctbl->ehufsi[nbits]))
-     return FALSE;
- 
-   /* Emit that number of bits of the value, if positive, */
-   /* or the complement of its magnitude, if negative. */
-   if (nbits)			/* emit_bits rejects calls with size 0 */
-     if (! emit_bits(state, (unsigned int) temp2, nbits))
-       return FALSE;
- 
-   /* Encode the AC coefficients per section F.1.2.2 */
-   
-   r = 0;			/* r = run length of zeros */
-   
-   for (k = 1; k < DCTSIZE2; k++) {
-     if ((temp = block[jpeg_natural_order[k]]) == 0) {
-       r++;
-     } else {
-       /* if run length > 15, must emit special run-length-16 codes (0xF0) */
-       while (r > 15) {
- 	if (! emit_bits(state, actbl->ehufco[0xF0], actbl->ehufsi[0xF0]))
- 	  return FALSE;
- 	r -= 16;
-       }
- 
-       temp2 = temp;
-       if (temp < 0) {
- 	temp = -temp;		/* temp is abs value of input */
- 	/* This code assumes we are on a two's complement machine */
- 	temp2--;
-       }
-       
-       /* Find the number of bits needed for the magnitude of the coefficient */
-       nbits = 1;		/* there must be at least one 1 bit */
-       while ((temp >>= 1))
- 	nbits++;
-       /* Check for out-of-range coefficient values */
-       if (nbits > MAX_COEF_BITS)
- 	ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);
-       
-       /* Emit Huffman symbol for run length / number of bits */
-       i = (r << 4) + nbits;
-       if (! emit_bits(state, actbl->ehufco[i], actbl->ehufsi[i]))
- 	return FALSE;
- 
-       /* Emit that number of bits of the value, if positive, */
-       /* or the complement of its magnitude, if negative. */
-       if (! emit_bits(state, (unsigned int) temp2, nbits))
- 	return FALSE;
-       
-       r = 0;
-     }
-   }
- 
-   /* If the last coef(s) were zero, emit an end-of-block code */
-   if (r > 0)
-     if (! emit_bits(state, actbl->ehufco[0], actbl->ehufsi[0]))
-       return FALSE;
- 
-   return TRUE;
- }
- 
- 
- /*
-  * Emit a restart marker & resynchronize predictions.
-  */
- 
- LOCAL(boolean)
- emit_restart (working_state * state, int restart_num)
- {
-   int ci;
- 
-   if (! flush_bits(state))
-     return FALSE;
- 
-   emit_byte(state, 0xFF, return FALSE);
-   emit_byte(state, JPEG_RST0 + restart_num, return FALSE);
- 
-   /* Re-initialize DC predictions to 0 */
-   for (ci = 0; ci < state->cinfo->comps_in_scan; ci++)
-     state->cur.last_dc_val[ci] = 0;
- 
-   /* The restart counter is not updated until we successfully write the MCU. */
- 
-   return TRUE;
- }
- 
- 
- /*
-  * Encode and output one MCU's worth of Huffman-compressed coefficients.
-  */
- 
- METHODDEF(boolean)
- encode_mcu_huff (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
- {
-   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
-   working_state state;
-   int blkn, ci;
-   jpeg_component_info * compptr;
- 
-   /* Load up working state */
-   state.next_output_byte = cinfo->dest->next_output_byte;
-   state.free_in_buffer = cinfo->dest->free_in_buffer;
-   ASSIGN_STATE(state.cur, entropy->saved);
-   state.cinfo = cinfo;
- 
-   /* Emit restart marker if needed */
-   if (cinfo->restart_interval) {
-     if (entropy->restarts_to_go == 0)
-       if (! emit_restart(&state, entropy->next_restart_num))
- 	return FALSE;
-   }
- 
-   /* Encode the MCU data blocks */
-   for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
-     ci = cinfo->MCU_membership[blkn];
-     compptr = cinfo->cur_comp_info[ci];
-     if (! encode_one_block(&state,
- 			   MCU_data[blkn][0], state.cur.last_dc_val[ci],
- 			   entropy->dc_derived_tbls[compptr->dc_tbl_no],
- 			   entropy->ac_derived_tbls[compptr->ac_tbl_no]))
-       return FALSE;
-     /* Update last_dc_val */
-     state.cur.last_dc_val[ci] = MCU_data[blkn][0][0];
-   }
- 
-   /* Completed MCU, so update state */
-   cinfo->dest->next_output_byte = state.next_output_byte;
-   cinfo->dest->free_in_buffer = state.free_in_buffer;
-   ASSIGN_STATE(entropy->saved, state.cur);
- 
-   /* Update restart-interval state too */
-   if (cinfo->restart_interval) {
-     if (entropy->restarts_to_go == 0) {
-       entropy->restarts_to_go = cinfo->restart_interval;
-       entropy->next_restart_num++;
-       entropy->next_restart_num &= 7;
-     }
-     entropy->restarts_to_go--;
-   }
- 
-   return TRUE;
- }
- 
- 
- /*
-  * Finish up at the end of a Huffman-compressed scan.
-  */
- 
- METHODDEF(void)
- finish_pass_huff (j_compress_ptr cinfo)
- {
-   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
-   working_state state;
- 
-   /* Load up working state ... flush_bits needs it */
-   state.next_output_byte = cinfo->dest->next_output_byte;
-   state.free_in_buffer = cinfo->dest->free_in_buffer;
-   ASSIGN_STATE(state.cur, entropy->saved);
-   state.cinfo = cinfo;
- 
-   /* Flush out the last data */
-   if (! flush_bits(&state))
-     ERREXIT(cinfo, JERR_CANT_SUSPEND);
- 
-   /* Update state */
-   cinfo->dest->next_output_byte = state.next_output_byte;
-   cinfo->dest->free_in_buffer = state.free_in_buffer;
-   ASSIGN_STATE(entropy->saved, state.cur);
- }
- 
- 
- /*
-  * Huffman coding optimization.
-  *
-  * We first scan the supplied data and count the number of uses of each symbol
-  * that is to be Huffman-coded. (This process MUST agree with the code above.)
-  * Then we build a Huffman coding tree for the observed counts.
-  * Symbols which are not needed at all for the particular image are not
-  * assigned any code, which saves space in the DHT marker as well as in
-  * the compressed data.
-  */
- 
- #ifdef ENTROPY_OPT_SUPPORTED
- 
- 
- /* Process a single block's worth of coefficients */
- 
- LOCAL(void)
- htest_one_block (j_compress_ptr cinfo, JCOEFPTR block, int last_dc_val,
- 		 long dc_counts[], long ac_counts[])
- {
-   register int temp;
-   register int nbits;
-   register int k, r;
-   
-   /* Encode the DC coefficient difference per section F.1.2.1 */
-   
-   temp = block[0] - last_dc_val;
-   if (temp < 0)
-     temp = -temp;
-   
-   /* Find the number of bits needed for the magnitude of the coefficient */
-   nbits = 0;
-   while (temp) {
-     nbits++;
-     temp >>= 1;
-   }
-   /* Check for out-of-range coefficient values.
-    * Since we're encoding a difference, the range limit is twice as much.
-    */
-   if (nbits > MAX_COEF_BITS+1)
-     ERREXIT(cinfo, JERR_BAD_DCT_COEF);
- 
-   /* Count the Huffman symbol for the number of bits */
-   dc_counts[nbits]++;
-   
-   /* Encode the AC coefficients per section F.1.2.2 */
-   
-   r = 0;			/* r = run length of zeros */
-   
-   for (k = 1; k < DCTSIZE2; k++) {
-     if ((temp = block[jpeg_natural_order[k]]) == 0) {
-       r++;
-     } else {
-       /* if run length > 15, must emit special run-length-16 codes (0xF0) */
-       while (r > 15) {
- 	ac_counts[0xF0]++;
- 	r -= 16;
-       }
-       
-       /* Find the number of bits needed for the magnitude of the coefficient */
-       if (temp < 0)
- 	temp = -temp;
-       
-       /* Find the number of bits needed for the magnitude of the coefficient */
-       nbits = 1;		/* there must be at least one 1 bit */
-       while ((temp >>= 1))
- 	nbits++;
-       /* Check for out-of-range coefficient values */
-       if (nbits > MAX_COEF_BITS)
- 	ERREXIT(cinfo, JERR_BAD_DCT_COEF);
-       
-       /* Count Huffman symbol for run length / number of bits */
-       ac_counts[(r << 4) + nbits]++;
-       
-       r = 0;
-     }
-   }
- 
-   /* If the last coef(s) were zero, emit an end-of-block code */
-   if (r > 0)
-     ac_counts[0]++;
- }
- 
- 
- /*
-  * Trial-encode one MCU's worth of Huffman-compressed coefficients.
-  * No data is actually output, so no suspension return is possible.
-  */
- 
- METHODDEF(boolean)
- encode_mcu_gather (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
- {
-   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
-   int blkn, ci;
-   jpeg_component_info * compptr;
- 
-   /* Take care of restart intervals if needed */
-   if (cinfo->restart_interval) {
-     if (entropy->restarts_to_go == 0) {
-       /* Re-initialize DC predictions to 0 */
-       for (ci = 0; ci < cinfo->comps_in_scan; ci++)
- 	entropy->saved.last_dc_val[ci] = 0;
-       /* Update restart state */
-       entropy->restarts_to_go = cinfo->restart_interval;
-     }
-     entropy->restarts_to_go--;
-   }
- 
-   for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
-     ci = cinfo->MCU_membership[blkn];
-     compptr = cinfo->cur_comp_info[ci];
-     htest_one_block(cinfo, MCU_data[blkn][0], entropy->saved.last_dc_val[ci],
- 		    entropy->dc_count_ptrs[compptr->dc_tbl_no],
- 		    entropy->ac_count_ptrs[compptr->ac_tbl_no]);
-     entropy->saved.last_dc_val[ci] = MCU_data[blkn][0][0];
-   }
- 
-   return TRUE;
- }
- 
- 
  /*
   * Generate the best Huffman code table for the given counts, fill htbl.
-  * Note this is also used by jcphuff.c.
   *
   * The JPEG standard requires that no symbol be assigned a codeword of all
   * one bits (so that padding bits added at the end of a compressed segment
--- 109,116 ----
***************
*** 835,909 ****
  
    /* Set sent_table FALSE so updated table will be written to JPEG file. */
    htbl->sent_table = FALSE;
- }
- 
- 
- /*
-  * Finish up a statistics-gathering pass and create the new Huffman tables.
-  */
- 
- METHODDEF(void)
- finish_pass_gather (j_compress_ptr cinfo)
- {
-   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
-   int ci, dctbl, actbl;
-   jpeg_component_info * compptr;
-   JHUFF_TBL **htblptr;
-   boolean did_dc[NUM_HUFF_TBLS];
-   boolean did_ac[NUM_HUFF_TBLS];
- 
-   /* It's important not to apply jpeg_gen_optimal_table more than once
-    * per table, because it clobbers the input frequency counts!
-    */
-   MEMZERO(did_dc, SIZEOF(did_dc));
-   MEMZERO(did_ac, SIZEOF(did_ac));
- 
-   for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
-     compptr = cinfo->cur_comp_info[ci];
-     dctbl = compptr->dc_tbl_no;
-     actbl = compptr->ac_tbl_no;
-     if (! did_dc[dctbl]) {
-       htblptr = & cinfo->dc_huff_tbl_ptrs[dctbl];
-       if (*htblptr == NULL)
- 	*htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
-       jpeg_gen_optimal_table(cinfo, *htblptr, entropy->dc_count_ptrs[dctbl]);
-       did_dc[dctbl] = TRUE;
-     }
-     if (! did_ac[actbl]) {
-       htblptr = & cinfo->ac_huff_tbl_ptrs[actbl];
-       if (*htblptr == NULL)
- 	*htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
-       jpeg_gen_optimal_table(cinfo, *htblptr, entropy->ac_count_ptrs[actbl]);
-       did_ac[actbl] = TRUE;
-     }
-   }
- }
- 
- 
- #endif /* ENTROPY_OPT_SUPPORTED */
- 
- 
- /*
-  * Module initialization routine for Huffman entropy encoding.
-  */
- 
- GLOBAL(void)
- jinit_huff_encoder (j_compress_ptr cinfo)
- {
-   huff_entropy_ptr entropy;
-   int i;
- 
-   entropy = (huff_entropy_ptr)
-     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
- 				SIZEOF(huff_entropy_encoder));
-   cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;
-   entropy->pub.start_pass = start_pass_huff;
- 
-   /* Mark tables unallocated */
-   for (i = 0; i < NUM_HUFF_TBLS; i++) {
-     entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
- #ifdef ENTROPY_OPT_SUPPORTED
-     entropy->dc_count_ptrs[i] = entropy->ac_count_ptrs[i] = NULL;
- #endif
-   }
  }
--- 270,273 ----
diff -cN ../jpeg-6b/jchuff.h ./jchuff.h
*** ../jpeg-6b/jchuff.h	Mon Oct 20 19:12:57 1997
--- ./jchuff.h	Tue Apr 27 14:58:17 1999
***************
*** 22,27 ****
--- 22,34 ----
  #define MAX_COEF_BITS 14
  #endif
  
+ /* The legal range of a spatial difference is
+  * -32767 .. +32768.
+  * Hence the magnitude should always fit in 16 bits.
+  */
+ 
+ #define MAX_DIFF_BITS 16
+ 
  /* Derived data constructed for each Huffman table */
  
  typedef struct {
diff -cN ../jpeg-6b/jcinit.c ./jcinit.c
*** ../jpeg-6b/jcinit.c	Sun Sep  7 16:50:40 1997
--- ./jcinit.c	Tue Apr 27 14:58:17 1999
***************
*** 32,37 ****
--- 32,40 ----
    /* Initialize master control (includes parameter checking/processing) */
    jinit_c_master_control(cinfo, FALSE /* full compression */);
  
+   /* Initialize compression codec */
+   jinit_c_codec(cinfo);
+ 
    /* Preprocessing */
    if (! cinfo->raw_data_in) {
      jinit_color_converter(cinfo);
***************
*** 38,62 ****
      jinit_downsampler(cinfo);
      jinit_c_prep_controller(cinfo, FALSE /* never need full buffer here */);
    }
-   /* Forward DCT */
-   jinit_forward_dct(cinfo);
-   /* Entropy encoding: either Huffman or arithmetic coding. */
-   if (cinfo->arith_code) {
-     ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
-   } else {
-     if (cinfo->progressive_mode) {
- #ifdef C_PROGRESSIVE_SUPPORTED
-       jinit_phuff_encoder(cinfo);
- #else
-       ERREXIT(cinfo, JERR_NOT_COMPILED);
- #endif
-     } else
-       jinit_huff_encoder(cinfo);
-   }
  
-   /* Need a full-image coefficient buffer in any multi-pass mode. */
-   jinit_c_coef_controller(cinfo,
- 		(boolean) (cinfo->num_scans > 1 || cinfo->optimize_coding));
    jinit_c_main_controller(cinfo, FALSE /* never need full buffer here */);
  
    jinit_marker_writer(cinfo);
--- 41,47 ----
diff -cN ../jpeg-6b/jclhuff.c ./jclhuff.c
*** ../jpeg-6b/jclhuff.c
--- ./jclhuff.c	Tue Apr 27 14:58:18 1999
***************
*** 0 ****
--- 1,599 ----
+ /*
+  * jclhuff.c
+  *
+  * Copyright (C) 1991-1998, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+  * This file contains Huffman entropy encoding routines for lossless JPEG.
+  *
+  * Much of the complexity here has to do with supporting output suspension.
+  * If the data destination module demands suspension, we want to be able to
+  * back up to the start of the current MCU.  To do this, we copy state
+  * variables into local working storage, and update them back to the
+  * permanent JPEG objects only upon successful completion of an MCU.
+  */
+ 
+ #define JPEG_INTERNALS
+ #include "jinclude.h"
+ #include "jpeglib.h"
+ #include "jlossls.h"		/* Private declarations for lossless codec */
+ #include "jchuff.h"		/* Declarations shared with jc*huff.c */
+ 
+ 
+ /* Expanded entropy encoder object for Huffman encoding.
+  *
+  * The savable_state subrecord contains fields that change within an MCU,
+  * but must not be updated permanently until we complete the MCU.
+  */
+ 
+ typedef struct {
+   INT32 put_buffer;		/* current bit-accumulation buffer */
+   int put_bits;			/* # of bits now in it */
+ } savable_state;
+ 
+ /* This macro is to work around compilers with missing or broken
+  * structure assignment.  You'll need to fix this code if you have
+  * such a compiler and you change MAX_COMPS_IN_SCAN.
+  */
+ 
+ #ifndef NO_STRUCT_ASSIGN
+ #define ASSIGN_STATE(dest,src)  ((dest) = (src))
+ #else
+ #define ASSIGN_STATE(dest,src)  \
+ 	((dest).put_buffer = (src).put_buffer, \
+ 	 (dest).put_bits = (src).put_bits)
+ #endif
+ 
+ 
+ typedef struct {
+   int ci, yoffset, MCU_width;
+ } lhe_input_ptr_info;
+ 
+ 
+ typedef struct {
+   savable_state saved;		/* Bit buffer at start of MCU */
+ 
+   /* These fields are NOT loaded into local working state. */
+   unsigned int restarts_to_go;	/* MCUs left in this restart interval */
+   int next_restart_num;		/* next restart number to write (0-7) */
+ 
+   /* Pointers to derived tables (these workspaces have image lifespan) */
+   c_derived_tbl * derived_tbls[NUM_HUFF_TBLS];
+ 
+   /* Pointers to derived tables to be used for each data unit within an MCU */
+   c_derived_tbl * cur_tbls[C_MAX_DATA_UNITS_IN_MCU];
+ 
+ #ifdef ENTROPY_OPT_SUPPORTED	/* Statistics tables for optimization */
+   long * count_ptrs[NUM_HUFF_TBLS];
+ 
+   /* Pointers to stats tables to be used for each data unit within an MCU */
+   long * cur_counts[C_MAX_DATA_UNITS_IN_MCU];
+ #endif
+ 
+   /* Pointers to the proper input difference row for each group of data units
+    * within an MCU.  For each component, there are Vi groups of Hi data units.
+    */
+   JDIFFROW input_ptr[C_MAX_DATA_UNITS_IN_MCU];
+ 
+   /* Number of input pointers in use for the current MCU.  This is the sum
+    * of all Vi in the MCU.
+    */
+   int num_input_ptrs;
+ 
+   /* Information used for positioning the input pointers within the input
+    * difference rows.
+    */
+   lhe_input_ptr_info input_ptr_info[C_MAX_DATA_UNITS_IN_MCU];
+ 
+   /* Index of the proper input pointer for each data unit within an MCU */
+   int input_ptr_index[C_MAX_DATA_UNITS_IN_MCU];
+ 
+ } lhuff_entropy_encoder;
+ 
+ typedef lhuff_entropy_encoder * lhuff_entropy_ptr;
+ 
+ /* Working state while writing an MCU.
+  * This struct contains all the fields that are needed by subroutines.
+  */
+ 
+ typedef struct {
+   JOCTET * next_output_byte;	/* => next byte to write in buffer */
+   size_t free_in_buffer;	/* # of byte spaces remaining in buffer */
+   savable_state cur;		/* Current bit buffer & DC state */
+   j_compress_ptr cinfo;		/* dump_buffer needs access to this */
+ } working_state;
+ 
+ 
+ /* Forward declarations */
+ METHODDEF(JDIMENSION) encode_mcus_huff (j_compress_ptr cinfo,
+ 					JDIFFIMAGE diff_buf,
+ 					JDIMENSION MCU_row_num,
+ 					JDIMENSION MCU_col_num,
+ 					JDIMENSION nMCU);
+ METHODDEF(void) finish_pass_huff JPP((j_compress_ptr cinfo));
+ #ifdef ENTROPY_OPT_SUPPORTED
+ METHODDEF(JDIMENSION) encode_mcus_gather (j_compress_ptr cinfo,
+ 					  JDIFFIMAGE diff_buf,
+ 					  JDIMENSION MCU_row_num,
+ 					  JDIMENSION MCU_col_num,
+ 					  JDIMENSION nMCU);
+ METHODDEF(void) finish_pass_gather JPP((j_compress_ptr cinfo));
+ #endif
+ 
+ 
+ /*
+  * Initialize for a Huffman-compressed scan.
+  * If gather_statistics is TRUE, we do not output anything during the scan,
+  * just count the Huffman symbols used and generate Huffman code tables.
+  */
+ 
+ METHODDEF(void)
+ start_pass_huff (j_compress_ptr cinfo, boolean gather_statistics)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+   lhuff_entropy_ptr entropy = (lhuff_entropy_ptr) losslsc->entropy_private;
+   int ci, dctbl, sampn, ptrn, yoffset, xoffset;
+   jpeg_component_info * compptr;
+ 
+   if (gather_statistics) {
+ #ifdef ENTROPY_OPT_SUPPORTED
+     losslsc->entropy_encode_mcus = encode_mcus_gather;
+     losslsc->pub.entropy_finish_pass = finish_pass_gather;
+ #else
+     ERREXIT(cinfo, JERR_NOT_COMPILED);
+ #endif
+   } else {
+     losslsc->entropy_encode_mcus = encode_mcus_huff;
+     losslsc->pub.entropy_finish_pass = finish_pass_huff;
+   }
+ 
+   for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
+     compptr = cinfo->cur_comp_info[ci];
+     dctbl = compptr->dc_tbl_no;
+     if (gather_statistics) {
+ #ifdef ENTROPY_OPT_SUPPORTED
+       /* Check for invalid table indexes */
+       /* (make_c_derived_tbl does this in the other path) */
+       if (dctbl < 0 || dctbl >= NUM_HUFF_TBLS)
+ 	ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, dctbl);
+       /* Allocate and zero the statistics tables */
+       /* Note that jpeg_gen_optimal_table expects 257 entries in each table! */
+       if (entropy->count_ptrs[dctbl] == NULL)
+ 	entropy->count_ptrs[dctbl] = (long *)
+ 	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
+ 				      257 * SIZEOF(long));
+       MEMZERO(entropy->count_ptrs[dctbl], 257 * SIZEOF(long));
+ #endif
+     } else {
+       /* Compute derived values for Huffman tables */
+       /* We may do this more than once for a table, but it's not expensive */
+       jpeg_make_c_derived_tbl(cinfo, TRUE, dctbl,
+ 			      & entropy->derived_tbls[dctbl]);
+     }
+   }
+ 
+   /* Precalculate encoding info for each sample in an MCU of this scan */
+   for (sampn = 0, ptrn = 0; sampn < cinfo->data_units_in_MCU;) {
+     compptr = cinfo->cur_comp_info[cinfo->MCU_membership[sampn]];
+     ci = compptr->component_index;
+     /*    ci = cinfo->MCU_membership[sampn];
+     compptr = cinfo->cur_comp_info[ci];*/
+     for (yoffset = 0; yoffset < compptr->MCU_height; yoffset++, ptrn++) {
+       /* Precalculate the setup info for each input pointer */
+       entropy->input_ptr_info[ptrn].ci = ci;
+       entropy->input_ptr_info[ptrn].yoffset = yoffset;
+       entropy->input_ptr_info[ptrn].MCU_width = compptr->MCU_width;
+       for (xoffset = 0; xoffset < compptr->MCU_width; xoffset++, sampn++) {
+ 	/* Precalculate the input pointer index for each sample */
+ 	entropy->input_ptr_index[sampn] = ptrn;
+ 	/* Precalculate which tables to use for each sample */
+ 	entropy->cur_tbls[sampn] = entropy->derived_tbls[compptr->dc_tbl_no];
+ 	entropy->cur_counts[sampn] = entropy->count_ptrs[compptr->dc_tbl_no];
+       }
+     }
+   }
+   entropy->num_input_ptrs = ptrn;
+ 
+   /* Initialize bit buffer to empty */
+   entropy->saved.put_buffer = 0;
+   entropy->saved.put_bits = 0;
+ 
+   /* Initialize restart stuff */
+   entropy->restarts_to_go = cinfo->restart_interval;
+   entropy->next_restart_num = 0;
+ }
+ 
+ 
+ /* Outputting bytes to the file */
+ 
+ /* Emit a byte, taking 'action' if must suspend. */
+ #define emit_byte(state,val,action)  \
+ 	{ *(state)->next_output_byte++ = (JOCTET) (val);  \
+ 	  if (--(state)->free_in_buffer == 0)  \
+ 	    if (! dump_buffer(state))  \
+ 	      { action; } }
+ 
+ 
+ LOCAL(boolean)
+ dump_buffer (working_state * state)
+ /* Empty the output buffer; return TRUE if successful, FALSE if must suspend */
+ {
+   struct jpeg_destination_mgr * dest = state->cinfo->dest;
+ 
+   if (! (*dest->empty_output_buffer) (state->cinfo))
+     return FALSE;
+   /* After a successful buffer dump, must reset buffer pointers */
+   state->next_output_byte = dest->next_output_byte;
+   state->free_in_buffer = dest->free_in_buffer;
+   return TRUE;
+ }
+ 
+ 
+ /* Outputting bits to the file */
+ 
+ /* Only the right 24 bits of put_buffer are used; the valid bits are
+  * left-justified in this part.  At most 16 bits can be passed to emit_bits
+  * in one call, and we never retain more than 7 bits in put_buffer
+  * between calls, so 24 bits are sufficient.
+  */
+ 
+ INLINE
+ LOCAL(boolean)
+ emit_bits (working_state * state, unsigned int code, int size)
+ /* Emit some bits; return TRUE if successful, FALSE if must suspend */
+ {
+   /* This routine is heavily used, so it's worth coding tightly. */
+   register INT32 put_buffer = (INT32) code;
+   register int put_bits = state->cur.put_bits;
+ 
+   /* if size is 0, caller used an invalid Huffman table entry */
+   if (size == 0)
+     ERREXIT(state->cinfo, JERR_HUFF_MISSING_CODE);
+ 
+   put_buffer &= (((INT32) 1)<<size) - 1; /* mask off any extra bits in code */
+   
+   put_bits += size;		/* new number of bits in buffer */
+   
+   put_buffer <<= 24 - put_bits; /* align incoming bits */
+ 
+   put_buffer |= state->cur.put_buffer; /* and merge with old buffer contents */
+   
+   while (put_bits >= 8) {
+     int c = (int) ((put_buffer >> 16) & 0xFF);
+     
+     emit_byte(state, c, return FALSE);
+     if (c == 0xFF) {		/* need to stuff a zero byte? */
+       emit_byte(state, 0, return FALSE);
+     }
+     put_buffer <<= 8;
+     put_bits -= 8;
+   }
+ 
+   state->cur.put_buffer = put_buffer; /* update state variables */
+   state->cur.put_bits = put_bits;
+ 
+   return TRUE;
+ }
+ 
+ 
+ LOCAL(boolean)
+ flush_bits (working_state * state)
+ {
+   if (! emit_bits(state, 0x7F, 7)) /* fill any partial byte with ones */
+     return FALSE;
+   state->cur.put_buffer = 0;	/* and reset bit-buffer to empty */
+   state->cur.put_bits = 0;
+   return TRUE;
+ }
+ 
+ 
+ /*
+  * Emit a restart marker & resynchronize predictions.
+  */
+ 
+ LOCAL(boolean)
+ emit_restart (working_state * state, int restart_num)
+ {
+   int ci;
+ 
+   if (! flush_bits(state))
+     return FALSE;
+ 
+   emit_byte(state, 0xFF, return FALSE);
+   emit_byte(state, JPEG_RST0 + restart_num, return FALSE);
+ 
+   /* The restart counter is not updated until we successfully write the MCU. */
+ 
+   return TRUE;
+ }
+ 
+ 
+ /*
+  * Encode and output one nMCU's worth of Huffman-compressed differences.
+  */
+ 
+ METHODDEF(JDIMENSION)
+ encode_mcus_huff (j_compress_ptr cinfo, JDIFFIMAGE diff_buf,
+ 		  JDIMENSION MCU_row_num, JDIMENSION MCU_col_num,
+ 		  JDIMENSION nMCU)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+   lhuff_entropy_ptr entropy = (lhuff_entropy_ptr) losslsc->entropy_private;
+   working_state state;
+   int mcu_num, sampn, ci, yoffset, MCU_width, ptrn;
+   jpeg_component_info * compptr;
+ 
+   /* Load up working state */
+   state.next_output_byte = cinfo->dest->next_output_byte;
+   state.free_in_buffer = cinfo->dest->free_in_buffer;
+   ASSIGN_STATE(state.cur, entropy->saved);
+   state.cinfo = cinfo;
+ 
+   /* Emit restart marker if needed */
+   if (cinfo->restart_interval) {
+     if (entropy->restarts_to_go == 0)
+       if (! emit_restart(&state, entropy->next_restart_num))
+ 	return 0;
+   }
+ 
+   /* Set input pointer locations based on MCU_col_num */
+   for (ptrn = 0; ptrn < entropy->num_input_ptrs; ptrn++) {
+     ci = entropy->input_ptr_info[ptrn].ci;
+     yoffset = entropy->input_ptr_info[ptrn].yoffset;
+     MCU_width = entropy->input_ptr_info[ptrn].MCU_width;
+     entropy->input_ptr[ptrn] =
+       diff_buf[ci][MCU_row_num + yoffset] + (MCU_col_num * MCU_width);
+   }
+ 
+   for (mcu_num = 0; mcu_num < nMCU; mcu_num++) {
+ 
+     /* Inner loop handles the samples in the MCU */
+     for (sampn = 0; sampn < cinfo->data_units_in_MCU; sampn++) {
+       register int temp, temp2, temp3;
+       register int nbits;
+       c_derived_tbl *dctbl = entropy->cur_tbls[sampn];
+   
+       /* Encode the difference per section H.1.2.2 */
+   
+       /* Input the sample difference */
+       temp = *entropy->input_ptr[entropy->input_ptr_index[sampn]]++;
+ 
+       if (temp & 0x8000) {	/* instead of temp < 0 */
+ 	temp = (-temp) & 0x7FFF; /* absolute value, mod 2^16 */
+ 	if (temp == 0)		/* special case: magnitude = 32768 */
+ 	  temp2 = temp = 0x8000;
+ 	temp2 = ~ temp;		/* one's complement of magnitude */
+       } else {
+ 	temp &= 0x7FFF;		/* abs value mod 2^16 */
+ 	temp2 = temp;		/* magnitude */
+       }
+ 
+       /* Find the number of bits needed for the magnitude of the difference */
+       nbits = 0;
+       while (temp) {
+ 	nbits++;
+ 	temp >>= 1;
+       }
+       /* Check for out-of-range difference values.
+        */
+       if (nbits > MAX_DIFF_BITS)
+ 	ERREXIT(cinfo, JERR_BAD_DIFF);
+   
+       /* Emit the Huffman-coded symbol for the number of bits */
+       if (! emit_bits(&state, dctbl->ehufco[nbits], dctbl->ehufsi[nbits]))
+ 	return mcu_num;
+ 
+       /* Emit that number of bits of the value, if positive, */
+       /* or the complement of its magnitude, if negative. */
+       if (nbits &&		/* emit_bits rejects calls with size 0 */
+ 	  nbits != 16)		/* special case: no bits should be emitted */
+ 	if (! emit_bits(&state, (unsigned int) temp2, nbits))
+ 	  return mcu_num;
+     }
+ 
+     /* Completed MCU, so update state */
+     cinfo->dest->next_output_byte = state.next_output_byte;
+     cinfo->dest->free_in_buffer = state.free_in_buffer;
+     ASSIGN_STATE(entropy->saved, state.cur);
+ 
+     /* Update restart-interval state too */
+     if (cinfo->restart_interval) {
+       if (entropy->restarts_to_go == 0) {
+ 	entropy->restarts_to_go = cinfo->restart_interval;
+ 	entropy->next_restart_num++;
+ 	entropy->next_restart_num &= 7;
+       }
+       entropy->restarts_to_go--;
+     }
+ 
+   }
+ 
+   return nMCU;
+ }
+ 
+ 
+ /*
+  * Finish up at the end of a Huffman-compressed scan.
+  */
+ 
+ METHODDEF(void)
+ finish_pass_huff (j_compress_ptr cinfo)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+   lhuff_entropy_ptr entropy = (lhuff_entropy_ptr) losslsc->entropy_private;
+   working_state state;
+ 
+   /* Load up working state ... flush_bits needs it */
+   state.next_output_byte = cinfo->dest->next_output_byte;
+   state.free_in_buffer = cinfo->dest->free_in_buffer;
+   ASSIGN_STATE(state.cur, entropy->saved);
+   state.cinfo = cinfo;
+ 
+   /* Flush out the last data */
+   if (! flush_bits(&state))
+     ERREXIT(cinfo, JERR_CANT_SUSPEND);
+ 
+   /* Update state */
+   cinfo->dest->next_output_byte = state.next_output_byte;
+   cinfo->dest->free_in_buffer = state.free_in_buffer;
+   ASSIGN_STATE(entropy->saved, state.cur);
+ }
+ 
+ 
+ /*
+  * Huffman coding optimization.
+  *
+  * We first scan the supplied data and count the number of uses of each symbol
+  * that is to be Huffman-coded. (This process MUST agree with the code above.)
+  * Then we build a Huffman coding tree for the observed counts.
+  * Symbols which are not needed at all for the particular image are not
+  * assigned any code, which saves space in the DHT marker as well as in
+  * the compressed data.
+  */
+ 
+ #ifdef ENTROPY_OPT_SUPPORTED
+ 
+ /*
+  * Trial-encode one nMCU's worth of Huffman-compressed differences.
+  * No data is actually output, so no suspension return is possible.
+  */
+ 
+ METHODDEF(JDIMENSION)
+ encode_mcus_gather (j_compress_ptr cinfo, JDIFFIMAGE diff_buf,
+ 		    JDIMENSION MCU_row_num, JDIMENSION MCU_col_num,
+ 		    JDIMENSION nMCU)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+   lhuff_entropy_ptr entropy = (lhuff_entropy_ptr) losslsc->entropy_private;
+   int mcu_num, sampn, ci, yoffset, MCU_width, ptrn;
+   jpeg_component_info * compptr;
+ 
+   /* Take care of restart intervals if needed */
+   if (cinfo->restart_interval) {
+     if (entropy->restarts_to_go == 0) {
+       /* Update restart state */
+       entropy->restarts_to_go = cinfo->restart_interval;
+     }
+     entropy->restarts_to_go--;
+   }
+ 
+   /* Set input pointer locations based on MCU_col_num */
+   for (ptrn = 0; ptrn < entropy->num_input_ptrs; ptrn++) {
+     ci = entropy->input_ptr_info[ptrn].ci;
+     yoffset = entropy->input_ptr_info[ptrn].yoffset;
+     MCU_width = entropy->input_ptr_info[ptrn].MCU_width;
+     entropy->input_ptr[ptrn] =
+       diff_buf[ci][MCU_row_num + yoffset] + (MCU_col_num * MCU_width);
+   }
+ 
+   for (mcu_num = 0; mcu_num < nMCU; mcu_num++) {
+ 
+     /* Inner loop handles the samples in the MCU */
+     for (sampn = 0; sampn < cinfo->data_units_in_MCU; sampn++) {
+       register int temp;
+       register int nbits;
+       c_derived_tbl *dctbl = entropy->cur_tbls[sampn];
+       long * counts = entropy->cur_counts[sampn];
+   
+       /* Encode the difference per section H.1.2.2 */
+   
+       /* Input the sample difference */
+       temp = *entropy->input_ptr[entropy->input_ptr_index[sampn]]++;
+ 
+       if (temp & 0x8000) {	/* instead of temp < 0 */
+ 	temp = (-temp) & 0x7FFF; /* absolute value, mod 2^16 */
+ 	if (temp == 0)		/* special case: magnitude = 32768 */
+ 	  temp = 0x8000;
+       } else
+ 	temp &= 0x7FFF;		/* abs value mod 2^16 */
+ 
+       /* Find the number of bits needed for the magnitude of the difference */
+       nbits = 0;
+       while (temp) {
+ 	nbits++;
+ 	temp >>= 1;
+       }
+       /* Check for out-of-range difference values.
+        */
+       if (nbits > MAX_DIFF_BITS)
+ 	ERREXIT(cinfo, JERR_BAD_DIFF);
+   
+       /* Count the Huffman symbol for the number of bits */
+       counts[nbits]++;
+     }
+   }
+ 
+   return nMCU;
+ }
+ 
+ 
+ /*
+  * Finish up a statistics-gathering pass and create the new Huffman tables.
+  */
+ 
+ METHODDEF(void)
+ finish_pass_gather (j_compress_ptr cinfo)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+   lhuff_entropy_ptr entropy = (lhuff_entropy_ptr) losslsc->entropy_private;
+   int ci, dctbl;
+   jpeg_component_info * compptr;
+   JHUFF_TBL **htblptr;
+   boolean did_dc[NUM_HUFF_TBLS];
+ 
+   /* It's important not to apply jpeg_gen_optimal_table more than once
+    * per table, because it clobbers the input frequency counts!
+    */
+   MEMZERO(did_dc, SIZEOF(did_dc));
+ 
+   for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
+     compptr = cinfo->cur_comp_info[ci];
+     dctbl = compptr->dc_tbl_no;
+     if (! did_dc[dctbl]) {
+       htblptr = & cinfo->dc_huff_tbl_ptrs[dctbl];
+       if (*htblptr == NULL)
+ 	*htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
+       jpeg_gen_optimal_table(cinfo, *htblptr, entropy->count_ptrs[dctbl]);
+       did_dc[dctbl] = TRUE;
+     }
+   }
+ }
+ 
+ 
+ #endif /* ENTROPY_OPT_SUPPORTED */
+ 
+ 
+ METHODDEF(boolean)
+ need_optimization_pass (j_compress_ptr cinfo)
+ {
+   return TRUE;
+ }
+ 
+ 
+ /*
+  * Module initialization routine for Huffman entropy encoding.
+  */
+ 
+ GLOBAL(void)
+ jinit_lhuff_encoder (j_compress_ptr cinfo)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+   lhuff_entropy_ptr entropy;
+   int i;
+ 
+   entropy = (lhuff_entropy_ptr)
+     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
+ 				SIZEOF(lhuff_entropy_encoder));
+   losslsc->entropy_private = (struct jpeg_entropy_encoder *) entropy;
+   losslsc->pub.entropy_start_pass = start_pass_huff;
+   losslsc->pub.need_optimization_pass = need_optimization_pass;
+ 
+   /* Mark tables unallocated */
+   for (i = 0; i < NUM_HUFF_TBLS; i++) {
+     entropy->derived_tbls[i] = NULL;
+ #ifdef ENTROPY_OPT_SUPPORTED
+     entropy->count_ptrs[i] = NULL;
+ #endif
+   }
+ }
diff -cN ../jpeg-6b/jclossls.c ./jclossls.c
*** ../jpeg-6b/jclossls.c
--- ./jclossls.c	Tue Apr 27 14:58:18 1999
***************
*** 0 ****
--- 1,78 ----
+ /*
+  * jclossls.c
+  *
+  * Copyright (C) 1998, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+  * This file contains the control logic for the lossless JPEG compressor.
+  */
+ 
+ #define JPEG_INTERNALS
+ #include "jinclude.h"
+ #include "jpeglib.h"
+ #include "jlossls.h"
+ 
+ 
+ #ifdef C_LOSSLESS_SUPPORTED
+ 
+ /*
+  * Initialize for a processing pass.
+  */
+ 
+ METHODDEF(void)
+ start_pass (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+ 
+   (*losslsc->scaler_start_pass) (cinfo);
+   (*losslsc->predict_start_pass) (cinfo);
+   (*losslsc->diff_start_pass) (cinfo, pass_mode);
+ }
+ 
+ 
+ /*
+  * Initialize the lossless compression codec.
+  * This is called only once, during master selection.
+  */
+ 
+ GLOBAL(void) 
+ jinit_lossless_c_codec(j_compress_ptr cinfo)
+ {
+   j_lossless_c_ptr losslsc;
+ 
+   /* Create subobject in permanent pool */
+   losslsc = (j_lossless_c_ptr)
+     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
+ 				SIZEOF(jpeg_lossless_c_codec));
+   cinfo->codec = (struct jpeg_c_codec *) losslsc;
+ 
+   /* Initialize sub-modules */
+ 
+   /* Scaler */
+   jinit_c_scaler(cinfo);
+ 
+   /* Differencer */
+   jinit_differencer(cinfo);
+ 
+   /* Entropy encoding: either Huffman or arithmetic coding. */
+   if (cinfo->arith_code) {
+     ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
+   } else {
+     jinit_lhuff_encoder(cinfo);
+   }
+ 
+   /* Need a full-image difference buffer in any multi-pass mode. */
+   jinit_c_diff_controller(cinfo,
+ 			  (boolean) (cinfo->num_scans > 1 ||
+ 				     cinfo->optimize_coding));
+ 
+   /* Initialize method pointers.
+    *
+    * Note: entropy_start_pass and entropy_finish_pass are assigned in
+    * jclhuff.c and compress_data is assigned in jcdiffct.c.
+    */
+   losslsc->pub.start_pass = start_pass;
+ }
+ 
+ #endif /* C_LOSSLESS_SUPPORTED */
diff -cN ../jpeg-6b/jclossy.c ./jclossy.c
*** ../jpeg-6b/jclossy.c
--- ./jclossy.c	Tue Apr 27 14:58:18 1999
***************
*** 0 ****
--- 1,76 ----
+ /*
+  * jclossy.c
+  *
+  * Copyright (C) 1998, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+  * This file contains the control logic for the lossy JPEG compressor.
+  */
+ 
+ #define JPEG_INTERNALS
+ #include "jinclude.h"
+ #include "jpeglib.h"
+ #include "jlossy.h"
+ 
+ 
+ /*
+  * Initialize for a processing pass.
+  */
+ 
+ METHODDEF(void)
+ start_pass (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
+ {
+   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
+ 
+   (*lossyc->fdct_start_pass) (cinfo);
+   (*lossyc->coef_start_pass) (cinfo, pass_mode);
+ }
+ 
+ 
+ /*
+  * Initialize the lossy compression codec.
+  * This is called only once, during master selection.
+  */
+ 
+ GLOBAL(void)
+ jinit_lossy_c_codec (j_compress_ptr cinfo)
+ {
+   j_lossy_c_ptr lossyc;
+ 
+   /* Create subobject in permanent pool */
+   lossyc = (j_lossy_c_ptr)
+     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
+ 				SIZEOF(jpeg_lossy_c_codec));
+   cinfo->codec = (struct jpeg_c_codec *) lossyc;
+ 
+   /* Initialize sub-modules */
+ 
+   /* Forward DCT */
+   jinit_forward_dct(cinfo);
+   /* Entropy encoding: either Huffman or arithmetic coding. */
+   if (cinfo->arith_code) {
+     ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
+   } else {
+     if (cinfo->process == JPROC_PROGRESSIVE) {
+ #ifdef C_PROGRESSIVE_SUPPORTED
+       jinit_phuff_encoder(cinfo);
+ #else
+       ERREXIT(cinfo, JERR_NOT_COMPILED);
+ #endif
+     } else
+       jinit_shuff_encoder(cinfo);
+   }
+ 
+   /* Need a full-image coefficient buffer in any multi-pass mode. */
+   jinit_c_coef_controller(cinfo,
+ 			  (boolean) (cinfo->num_scans > 1 ||
+ 				     cinfo->optimize_coding));
+ 
+   /* Initialize method pointers.
+    *
+    * Note: entropy_start_pass and entropy_finish_pass are assigned in
+    * jcshuff.c or jcphuff.c and compress_data is assigned in jccoefct.c.
+    */
+   lossyc->pub.start_pass = start_pass;
+ }
diff -cN ../jpeg-6b/jcmainct.c ./jcmainct.c
*** ../jpeg-6b/jcmainct.c	Sat Jan  6 18:24:59 1996
--- ./jcmainct.c	Tue Apr 27 14:58:18 1999
***************
*** 1,7 ****
  /*
   * jcmainct.c
   *
!  * Copyright (C) 1994-1996, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jcmainct.c
   *
!  * Copyright (C) 1994-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 115,138 ****
  			  JDIMENSION in_rows_avail)
  {
    my_main_ptr main = (my_main_ptr) cinfo->main;
  
    while (main->cur_iMCU_row < cinfo->total_iMCU_rows) {
      /* Read input data if we haven't filled the main buffer yet */
!     if (main->rowgroup_ctr < DCTSIZE)
        (*cinfo->prep->pre_process_data) (cinfo,
  					input_buf, in_row_ctr, in_rows_avail,
  					main->buffer, &main->rowgroup_ctr,
! 					(JDIMENSION) DCTSIZE);
  
      /* If we don't have a full iMCU row buffered, return to application for
       * more data.  Note that preprocessor will always pad to fill the iMCU row
       * at the bottom of the image.
       */
!     if (main->rowgroup_ctr != DCTSIZE)
        return;
  
      /* Send the completed row to the compressor */
!     if (! (*cinfo->coef->compress_data) (cinfo, main->buffer)) {
        /* If compressor did not consume the whole row, then we must need to
         * suspend processing and return to the application.  In this situation
         * we pretend we didn't yet consume the last input row; otherwise, if
--- 115,139 ----
  			  JDIMENSION in_rows_avail)
  {
    my_main_ptr main = (my_main_ptr) cinfo->main;
+   int data_unit = cinfo->data_unit;
  
    while (main->cur_iMCU_row < cinfo->total_iMCU_rows) {
      /* Read input data if we haven't filled the main buffer yet */
!     if (main->rowgroup_ctr < data_unit)
        (*cinfo->prep->pre_process_data) (cinfo,
  					input_buf, in_row_ctr, in_rows_avail,
  					main->buffer, &main->rowgroup_ctr,
! 					(JDIMENSION) data_unit);
  
      /* If we don't have a full iMCU row buffered, return to application for
       * more data.  Note that preprocessor will always pad to fill the iMCU row
       * at the bottom of the image.
       */
!     if (main->rowgroup_ctr != data_unit)
        return;
  
      /* Send the completed row to the compressor */
!     if (! (*cinfo->codec->compress_data) (cinfo, main->buffer)) {
        /* If compressor did not consume the whole row, then we must need to
         * suspend processing and return to the application.  In this situation
         * we pretend we didn't yet consume the last input row; otherwise, if
***************
*** 174,179 ****
--- 175,181 ----
    int ci;
    jpeg_component_info *compptr;
    boolean writing = (main->pass_mode != JBUF_CRANK_DEST);
+   int data_unit = cinfo->data_unit;
  
    while (main->cur_iMCU_row < cinfo->total_iMCU_rows) {
      /* Realign the virtual buffers if at the start of an iMCU row. */
***************
*** 182,194 ****
  	   ci++, compptr++) {
  	main->buffer[ci] = (*cinfo->mem->access_virt_sarray)
  	  ((j_common_ptr) cinfo, main->whole_image[ci],
! 	   main->cur_iMCU_row * (compptr->v_samp_factor * DCTSIZE),
! 	   (JDIMENSION) (compptr->v_samp_factor * DCTSIZE), writing);
        }
        /* In a read pass, pretend we just read some source data. */
        if (! writing) {
! 	*in_row_ctr += cinfo->max_v_samp_factor * DCTSIZE;
! 	main->rowgroup_ctr = DCTSIZE;
        }
      }
  
--- 184,196 ----
  	   ci++, compptr++) {
  	main->buffer[ci] = (*cinfo->mem->access_virt_sarray)
  	  ((j_common_ptr) cinfo, main->whole_image[ci],
! 	   main->cur_iMCU_row * (compptr->v_samp_factor * data_unit),
! 	   (JDIMENSION) (compptr->v_samp_factor * data_unit), writing);
        }
        /* In a read pass, pretend we just read some source data. */
        if (! writing) {
! 	*in_row_ctr += cinfo->max_v_samp_factor * data_unit;
! 	main->rowgroup_ctr = data_unit;
        }
      }
  
***************
*** 198,212 ****
        (*cinfo->prep->pre_process_data) (cinfo,
  					input_buf, in_row_ctr, in_rows_avail,
  					main->buffer, &main->rowgroup_ctr,
! 					(JDIMENSION) DCTSIZE);
        /* Return to application if we need more data to fill the iMCU row. */
!       if (main->rowgroup_ctr < DCTSIZE)
  	return;
      }
  
      /* Emit data, unless this is a sink-only pass. */
      if (main->pass_mode != JBUF_SAVE_SOURCE) {
!       if (! (*cinfo->coef->compress_data) (cinfo, main->buffer)) {
  	/* If compressor did not consume the whole row, then we must need to
  	 * suspend processing and return to the application.  In this situation
  	 * we pretend we didn't yet consume the last input row; otherwise, if
--- 200,214 ----
        (*cinfo->prep->pre_process_data) (cinfo,
  					input_buf, in_row_ctr, in_rows_avail,
  					main->buffer, &main->rowgroup_ctr,
! 					(JDIMENSION) data_unit);
        /* Return to application if we need more data to fill the iMCU row. */
!       if (main->rowgroup_ctr < data_unit)
  	return;
      }
  
      /* Emit data, unless this is a sink-only pass. */
      if (main->pass_mode != JBUF_SAVE_SOURCE) {
!       if (! (*cinfo->codec->compress_data) (cinfo, main->buffer)) {
  	/* If compressor did not consume the whole row, then we must need to
  	 * suspend processing and return to the application.  In this situation
  	 * we pretend we didn't yet consume the last input row; otherwise, if
***************
*** 247,252 ****
--- 249,255 ----
    my_main_ptr main;
    int ci;
    jpeg_component_info *compptr;
+   int data_unit = cinfo->data_unit;
  
    main = (my_main_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
***************
*** 269,278 ****
  	 ci++, compptr++) {
        main->whole_image[ci] = (*cinfo->mem->request_virt_sarray)
  	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
! 	 compptr->width_in_blocks * DCTSIZE,
! 	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
! 				(long) compptr->v_samp_factor) * DCTSIZE,
! 	 (JDIMENSION) (compptr->v_samp_factor * DCTSIZE));
      }
  #else
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
--- 272,281 ----
  	 ci++, compptr++) {
        main->whole_image[ci] = (*cinfo->mem->request_virt_sarray)
  	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
! 	 compptr->width_in_data_units * data_unit,
! 	 (JDIMENSION) jround_up((long) compptr->height_in_data_units,
! 				(long) compptr->v_samp_factor) * data_unit,
! 	 (JDIMENSION) (compptr->v_samp_factor * data_unit));
      }
  #else
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
***************
*** 286,293 ****
  	 ci++, compptr++) {
        main->buffer[ci] = (*cinfo->mem->alloc_sarray)
  	((j_common_ptr) cinfo, JPOOL_IMAGE,
! 	 compptr->width_in_blocks * DCTSIZE,
! 	 (JDIMENSION) (compptr->v_samp_factor * DCTSIZE));
      }
    }
  }
--- 289,296 ----
  	 ci++, compptr++) {
        main->buffer[ci] = (*cinfo->mem->alloc_sarray)
  	((j_common_ptr) cinfo, JPOOL_IMAGE,
! 	 compptr->width_in_data_units * data_unit,
! 	 (JDIMENSION) (compptr->v_samp_factor * data_unit));
      }
    }
  }
diff -cN ../jpeg-6b/jcmarker.c ./jcmarker.c
*** ../jpeg-6b/jcmarker.c	Sat Feb 21 16:54:00 1998
--- ./jcmarker.c	Tue Apr 27 14:58:19 1999
***************
*** 322,328 ****
      emit_byte(cinfo, compptr->component_id);
      td = compptr->dc_tbl_no;
      ta = compptr->ac_tbl_no;
!     if (cinfo->progressive_mode) {
        /* Progressive mode: only DC or only AC tables are used in one scan;
         * furthermore, Huffman coding of DC refinement uses no table at all.
         * We emit 0 for unused field(s); this is recommended by the P&M text
--- 322,328 ----
      emit_byte(cinfo, compptr->component_id);
      td = compptr->dc_tbl_no;
      ta = compptr->ac_tbl_no;
!     if (cinfo->process == JPROC_PROGRESSIVE) {
        /* Progressive mode: only DC or only AC tables are used in one scan;
         * furthermore, Huffman coding of DC refinement uses no table at all.
         * We emit 0 for unused field(s); this is recommended by the P&M text
***************
*** 496,516 ****
    int ci, prec;
    boolean is_baseline;
    jpeg_component_info *compptr;
!   
!   /* Emit DQT for each quantization table.
!    * Note that emit_dqt() suppresses any duplicate tables.
!    */
!   prec = 0;
!   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
!        ci++, compptr++) {
!     prec += emit_dqt(cinfo, compptr->quant_tbl_no);
    }
-   /* now prec is nonzero iff there are any 16-bit quant tables. */
  
    /* Check for a non-baseline specification.
     * Note we assume that Huffman table numbers won't be changed later.
     */
!   if (cinfo->arith_code || cinfo->progressive_mode ||
        cinfo->data_precision != 8) {
      is_baseline = FALSE;
    } else {
--- 496,518 ----
    int ci, prec;
    boolean is_baseline;
    jpeg_component_info *compptr;
! 
!   if (cinfo->process != JPROC_LOSSLESS) {
!     /* Emit DQT for each quantization table.
!      * Note that emit_dqt() suppresses any duplicate tables.
!      */
!     prec = 0;
!     for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
! 	 ci++, compptr++) {
!       prec += emit_dqt(cinfo, compptr->quant_tbl_no);
!     }
!     /* now prec is nonzero iff there are any 16-bit quant tables. */
    }
  
    /* Check for a non-baseline specification.
     * Note we assume that Huffman table numbers won't be changed later.
     */
!   if (cinfo->arith_code || cinfo->process != JPROC_SEQUENTIAL ||
        cinfo->data_precision != 8) {
      is_baseline = FALSE;
    } else {
***************
*** 531,538 ****
    if (cinfo->arith_code) {
      emit_sof(cinfo, M_SOF9);	/* SOF code for arithmetic coding */
    } else {
!     if (cinfo->progressive_mode)
        emit_sof(cinfo, M_SOF2);	/* SOF code for progressive Huffman */
      else if (is_baseline)
        emit_sof(cinfo, M_SOF0);	/* SOF code for baseline implementation */
      else
--- 533,542 ----
    if (cinfo->arith_code) {
      emit_sof(cinfo, M_SOF9);	/* SOF code for arithmetic coding */
    } else {
!     if (cinfo->process == JPROC_PROGRESSIVE)
        emit_sof(cinfo, M_SOF2);	/* SOF code for progressive Huffman */
+     else if (cinfo->process == JPROC_LOSSLESS)
+       emit_sof(cinfo, M_SOF3);	/* SOF code for lossless Huffman */
      else if (is_baseline)
        emit_sof(cinfo, M_SOF0);	/* SOF code for baseline implementation */
      else
***************
*** 566,572 ****
       */
      for (i = 0; i < cinfo->comps_in_scan; i++) {
        compptr = cinfo->cur_comp_info[i];
!       if (cinfo->progressive_mode) {
  	/* Progressive mode: only DC or only AC tables are used in one scan */
  	if (cinfo->Ss == 0) {
  	  if (cinfo->Ah == 0)	/* DC needs no table for refinement scan */
--- 570,576 ----
       */
      for (i = 0; i < cinfo->comps_in_scan; i++) {
        compptr = cinfo->cur_comp_info[i];
!       if (cinfo->process == JPROC_PROGRESSIVE) {
  	/* Progressive mode: only DC or only AC tables are used in one scan */
  	if (cinfo->Ss == 0) {
  	  if (cinfo->Ah == 0)	/* DC needs no table for refinement scan */
***************
*** 574,579 ****
--- 578,586 ----
  	} else {
  	  emit_dht(cinfo, compptr->ac_tbl_no, TRUE);
  	}
+       } else if (cinfo->process == JPROC_LOSSLESS) {
+ 	/* Lossless mode: only DC tables are used */
+ 	emit_dht(cinfo, compptr->dc_tbl_no, FALSE);
        } else {
  	/* Sequential mode: need both DC and AC tables */
  	emit_dht(cinfo, compptr->dc_tbl_no, FALSE);
diff -cN ../jpeg-6b/jcmaster.c ./jcmaster.c
*** ../jpeg-6b/jcmaster.c	Sun Aug 10 19:40:57 1997
--- ./jcmaster.c	Tue Apr 27 14:58:19 1999
***************
*** 1,7 ****
  /*
   * jcmaster.c
   *
!  * Copyright (C) 1991-1997, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jcmaster.c
   *
!  * Copyright (C) 1991-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 14,19 ****
--- 14,20 ----
  #define JPEG_INTERNALS
  #include "jinclude.h"
  #include "jpeglib.h"
+ #include "jlossy.h"		/* Private declarations for lossy codec */
  
  
  /* Private state */
***************
*** 50,55 ****
--- 51,57 ----
    jpeg_component_info *compptr;
    long samplesperrow;
    JDIMENSION jd_samplesperrow;
+   int data_unit = cinfo->data_unit;
  
    /* Sanity check on image dimensions */
    if (cinfo->image_height <= 0 || cinfo->image_width <= 0
***************
*** 95,109 ****
         ci++, compptr++) {
      /* Fill in the correct component_index value; don't rely on application */
      compptr->component_index = ci;
!     /* For compression, we never do DCT scaling. */
!     compptr->DCT_scaled_size = DCTSIZE;
!     /* Size in DCT blocks */
!     compptr->width_in_blocks = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
! 		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
!     compptr->height_in_blocks = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
! 		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
      /* Size in samples */
      compptr->downsampled_width = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
--- 97,111 ----
         ci++, compptr++) {
      /* Fill in the correct component_index value; don't rely on application */
      compptr->component_index = ci;
!     /* For compression, we never do any codec-based processing. */
!     compptr->codec_data_unit = data_unit;
!     /* Size in data units */
!     compptr->width_in_data_units = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
! 		    (long) (cinfo->max_h_samp_factor * data_unit));
!     compptr->height_in_data_units = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
! 		    (long) (cinfo->max_v_samp_factor * data_unit));
      /* Size in samples */
      compptr->downsampled_width = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
***************
*** 120,135 ****
     */
    cinfo->total_iMCU_rows = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height,
! 		  (long) (cinfo->max_v_samp_factor*DCTSIZE));
  }
  
- 
  #ifdef C_MULTISCAN_FILES_SUPPORTED
  
  LOCAL(void)
  validate_script (j_compress_ptr cinfo)
  /* Verify that the scan script in cinfo->scan_info[] is valid; also
!  * determine whether it uses progressive JPEG, and set cinfo->progressive_mode.
   */
  {
    const jpeg_scan_info * scanptr;
--- 122,144 ----
     */
    cinfo->total_iMCU_rows = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height,
! 		  (long) (cinfo->max_v_samp_factor*data_unit));
  }
  
  #ifdef C_MULTISCAN_FILES_SUPPORTED
+ #define NEED_SCAN_SCRIPT
+ #else
+ #ifdef C_LOSSLESS_SUPPORTED
+ #define NEED_SCAN_SCRIPT
+ #endif
+ #endif
+ 
+ #ifdef NEED_SCAN_SCRIPT
  
  LOCAL(void)
  validate_script (j_compress_ptr cinfo)
  /* Verify that the scan script in cinfo->scan_info[] is valid; also
!  * determine whether it uses progressive JPEG, and set cinfo->process.
   */
  {
    const jpeg_scan_info * scanptr;
***************
*** 145,157 ****
    if (cinfo->num_scans <= 0)
      ERREXIT1(cinfo, JERR_BAD_SCAN_SCRIPT, 0);
  
    /* For sequential JPEG, all scans must have Ss=0, Se=DCTSIZE2-1;
     * for progressive JPEG, no scan can have this.
     */
!   scanptr = cinfo->scan_info;
!   if (scanptr->Ss != 0 || scanptr->Se != DCTSIZE2-1) {
  #ifdef C_PROGRESSIVE_SUPPORTED
!     cinfo->progressive_mode = TRUE;
      last_bitpos_ptr = & last_bitpos[0][0];
      for (ci = 0; ci < cinfo->num_components; ci++) 
        for (coefi = 0; coefi < DCTSIZE2; coefi++)
--- 154,180 ----
    if (cinfo->num_scans <= 0)
      ERREXIT1(cinfo, JERR_BAD_SCAN_SCRIPT, 0);
  
+ #ifndef C_MULTISCAN_FILES_SUPPORTED
+   if (cinfo->num_scans > 1)
+     ERREXIT(cinfo, JERR_NOT_COMPILED);
+ #endif
+ 
+   scanptr = cinfo->scan_info;
+   if (cinfo->lossless) {
+ #ifdef C_LOSSLESS_SUPPORTED
+     cinfo->process = JPROC_LOSSLESS;
+     for (ci = 0; ci < cinfo->num_components; ci++) 
+       component_sent[ci] = FALSE;
+ #else
+     ERREXIT(cinfo, JERR_NOT_COMPILED);
+ #endif
+   }
    /* For sequential JPEG, all scans must have Ss=0, Se=DCTSIZE2-1;
     * for progressive JPEG, no scan can have this.
     */
!   else if (scanptr->Ss != 0 || scanptr->Se != DCTSIZE2-1) {
  #ifdef C_PROGRESSIVE_SUPPORTED
!     cinfo->process = JPROC_PROGRESSIVE;
      last_bitpos_ptr = & last_bitpos[0][0];
      for (ci = 0; ci < cinfo->num_components; ci++) 
        for (coefi = 0; coefi < DCTSIZE2; coefi++)
***************
*** 160,166 ****
      ERREXIT(cinfo, JERR_NOT_COMPILED);
  #endif
    } else {
!     cinfo->progressive_mode = FALSE;
      for (ci = 0; ci < cinfo->num_components; ci++) 
        component_sent[ci] = FALSE;
    }
--- 183,189 ----
      ERREXIT(cinfo, JERR_NOT_COMPILED);
  #endif
    } else {
!     cinfo->process = JPROC_SEQUENTIAL;
      for (ci = 0; ci < cinfo->num_components; ci++) 
        component_sent[ci] = FALSE;
    }
***************
*** 183,189 ****
      Se = scanptr->Se;
      Ah = scanptr->Ah;
      Al = scanptr->Al;
!     if (cinfo->progressive_mode) {
  #ifdef C_PROGRESSIVE_SUPPORTED
        /* The JPEG spec simply gives the ranges 0..13 for Ah and Al, but that
         * seems wrong: the upper bound ought to depend on data precision.
--- 206,231 ----
      Se = scanptr->Se;
      Ah = scanptr->Ah;
      Al = scanptr->Al;
!     if (cinfo->process == JPROC_LOSSLESS) {
! #ifdef C_LOSSLESS_SUPPORTED
!       /* The JPEG spec simply gives the range 0..15 for Al (Pt), but that
!        * seems wrong: the upper bound ought to depend on data precision.
!        * Perhaps they really meant 0..N-1 for N-bit precision, which is what
!        * we allow here.
!        */
!       if (Ss < 1 || Ss > 7 ||			/* predictor selector */
! 	  Se != 0 || Ah != 0 ||
! 	  Al < 0 || Al >= cinfo->data_precision) /* point transform */
! 	ERREXIT1(cinfo, JERR_BAD_LOSSLESS_SCRIPT, scanno);
!       /* Make sure components are not sent twice */
!       for (ci = 0; ci < ncomps; ci++) {
! 	thisi = scanptr->component_index[ci];
! 	if (component_sent[thisi])
! 	  ERREXIT1(cinfo, JERR_BAD_SCAN_SCRIPT, scanno);
! 	component_sent[thisi] = TRUE;
!       }
! #endif
!     } else if (cinfo->process == JPROC_PROGRESSIVE) {
  #ifdef C_PROGRESSIVE_SUPPORTED
        /* The JPEG spec simply gives the ranges 0..13 for Ah and Al, but that
         * seems wrong: the upper bound ought to depend on data precision.
***************
*** 240,246 ****
    }
  
    /* Now verify that everything got sent. */
!   if (cinfo->progressive_mode) {
  #ifdef C_PROGRESSIVE_SUPPORTED
      /* For progressive mode, we only check that at least some DC data
       * got sent for each component; the spec does not require that all bits
--- 282,288 ----
    }
  
    /* Now verify that everything got sent. */
!   if (cinfo->process == JPROC_PROGRESSIVE) {
  #ifdef C_PROGRESSIVE_SUPPORTED
      /* For progressive mode, we only check that at least some DC data
       * got sent for each component; the spec does not require that all bits
***************
*** 260,266 ****
    }
  }
  
! #endif /* C_MULTISCAN_FILES_SUPPORTED */
  
  
  LOCAL(void)
--- 302,308 ----
    }
  }
  
! #endif /* NEED_SCAN_SCRIPT */
  
  
  LOCAL(void)
***************
*** 269,275 ****
  {
    int ci;
  
! #ifdef C_MULTISCAN_FILES_SUPPORTED
    if (cinfo->scan_info != NULL) {
      /* Prepare for current scan --- the script is already validated */
      my_master_ptr master = (my_master_ptr) cinfo->master;
--- 311,317 ----
  {
    int ci;
  
! #ifdef NEED_SCAN_SCRIPT
    if (cinfo->scan_info != NULL) {
      /* Prepare for current scan --- the script is already validated */
      my_master_ptr master = (my_master_ptr) cinfo->master;
***************
*** 284,291 ****
      cinfo->Se = scanptr->Se;
      cinfo->Ah = scanptr->Ah;
      cinfo->Al = scanptr->Al;
!   }
!   else
  #endif
    {
      /* Prepare for single sequential-JPEG scan containing all components */
--- 326,332 ----
      cinfo->Se = scanptr->Se;
      cinfo->Ah = scanptr->Ah;
      cinfo->Al = scanptr->Al;
!   } else
  #endif
    {
      /* Prepare for single sequential-JPEG scan containing all components */
***************
*** 296,305 ****
      for (ci = 0; ci < cinfo->num_components; ci++) {
        cinfo->cur_comp_info[ci] = &cinfo->comp_info[ci];
      }
!     cinfo->Ss = 0;
!     cinfo->Se = DCTSIZE2-1;
!     cinfo->Ah = 0;
!     cinfo->Al = 0;
    }
  }
  
--- 337,356 ----
      for (ci = 0; ci < cinfo->num_components; ci++) {
        cinfo->cur_comp_info[ci] = &cinfo->comp_info[ci];
      }
!     if (cinfo->lossless) {
! #ifdef C_LOSSLESS_SUPPORTED
!     /* If we fall through to here, the user specified lossless, but did not
!      * provide a scan script.
!      */
!       ERREXIT(cinfo, JERR_NO_LOSSLESS_SCRIPT);
! #endif
!     } else {
!       cinfo->process = JPROC_SEQUENTIAL;
!       cinfo->Ss = 0;
!       cinfo->Se = DCTSIZE2-1;
!       cinfo->Ah = 0;
!       cinfo->Al = 0;
!     }
    }
  }
  
***************
*** 311,316 ****
--- 362,368 ----
  {
    int ci, mcublks, tmp;
    jpeg_component_info *compptr;
+   int data_unit = cinfo->data_unit;
    
    if (cinfo->comps_in_scan == 1) {
      
***************
*** 318,341 ****
      compptr = cinfo->cur_comp_info[0];
      
      /* Overall image size in MCUs */
!     cinfo->MCUs_per_row = compptr->width_in_blocks;
!     cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
      
      /* For noninterleaved scan, always one block per MCU */
      compptr->MCU_width = 1;
      compptr->MCU_height = 1;
!     compptr->MCU_blocks = 1;
!     compptr->MCU_sample_width = DCTSIZE;
      compptr->last_col_width = 1;
      /* For noninterleaved scans, it is convenient to define last_row_height
       * as the number of block rows present in the last iMCU row.
       */
!     tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
      if (tmp == 0) tmp = compptr->v_samp_factor;
      compptr->last_row_height = tmp;
      
      /* Prepare array describing MCU composition */
!     cinfo->blocks_in_MCU = 1;
      cinfo->MCU_membership[0] = 0;
      
    } else {
--- 370,393 ----
      compptr = cinfo->cur_comp_info[0];
      
      /* Overall image size in MCUs */
!     cinfo->MCUs_per_row = compptr->width_in_data_units;
!     cinfo->MCU_rows_in_scan = compptr->height_in_data_units;
      
      /* For noninterleaved scan, always one block per MCU */
      compptr->MCU_width = 1;
      compptr->MCU_height = 1;
!     compptr->MCU_data_units = 1;
!     compptr->MCU_sample_width = data_unit;
      compptr->last_col_width = 1;
      /* For noninterleaved scans, it is convenient to define last_row_height
       * as the number of block rows present in the last iMCU row.
       */
!     tmp = (int) (compptr->height_in_data_units % compptr->v_samp_factor);
      if (tmp == 0) tmp = compptr->v_samp_factor;
      compptr->last_row_height = tmp;
      
      /* Prepare array describing MCU composition */
!     cinfo->data_units_in_MCU = 1;
      cinfo->MCU_membership[0] = 0;
      
    } else {
***************
*** 348,359 ****
      /* Overall image size in MCUs */
      cinfo->MCUs_per_row = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_width,
! 		    (long) (cinfo->max_h_samp_factor*DCTSIZE));
      cinfo->MCU_rows_in_scan = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_height,
! 		    (long) (cinfo->max_v_samp_factor*DCTSIZE));
      
!     cinfo->blocks_in_MCU = 0;
      
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
        compptr = cinfo->cur_comp_info[ci];
--- 400,411 ----
      /* Overall image size in MCUs */
      cinfo->MCUs_per_row = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_width,
! 		    (long) (cinfo->max_h_samp_factor*data_unit));
      cinfo->MCU_rows_in_scan = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_height,
! 		    (long) (cinfo->max_v_samp_factor*data_unit));
      
!     cinfo->data_units_in_MCU = 0;
      
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
        compptr = cinfo->cur_comp_info[ci];
***************
*** 360,380 ****
        /* Sampling factors give # of blocks of component in each MCU */
        compptr->MCU_width = compptr->h_samp_factor;
        compptr->MCU_height = compptr->v_samp_factor;
!       compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
!       compptr->MCU_sample_width = compptr->MCU_width * DCTSIZE;
        /* Figure number of non-dummy blocks in last MCU column & row */
!       tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
        if (tmp == 0) tmp = compptr->MCU_width;
        compptr->last_col_width = tmp;
!       tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
        if (tmp == 0) tmp = compptr->MCU_height;
        compptr->last_row_height = tmp;
        /* Prepare array describing MCU composition */
!       mcublks = compptr->MCU_blocks;
!       if (cinfo->blocks_in_MCU + mcublks > C_MAX_BLOCKS_IN_MCU)
  	ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
        while (mcublks-- > 0) {
! 	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
        }
      }
      
--- 412,432 ----
        /* Sampling factors give # of blocks of component in each MCU */
        compptr->MCU_width = compptr->h_samp_factor;
        compptr->MCU_height = compptr->v_samp_factor;
!       compptr->MCU_data_units = compptr->MCU_width * compptr->MCU_height;
!       compptr->MCU_sample_width = compptr->MCU_width * data_unit;
        /* Figure number of non-dummy blocks in last MCU column & row */
!       tmp = (int) (compptr->width_in_data_units % compptr->MCU_width);
        if (tmp == 0) tmp = compptr->MCU_width;
        compptr->last_col_width = tmp;
!       tmp = (int) (compptr->height_in_data_units % compptr->MCU_height);
        if (tmp == 0) tmp = compptr->MCU_height;
        compptr->last_row_height = tmp;
        /* Prepare array describing MCU composition */
!       mcublks = compptr->MCU_data_units;
!       if (cinfo->data_units_in_MCU + mcublks > C_MAX_DATA_UNITS_IN_MCU)
  	ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
        while (mcublks-- > 0) {
! 	cinfo->MCU_membership[cinfo->data_units_in_MCU++] = ci;
        }
      }
      
***************
*** 400,405 ****
--- 452,458 ----
  METHODDEF(void)
  prepare_for_pass (j_compress_ptr cinfo)
  {
+   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
    my_master_ptr master = (my_master_ptr) cinfo->master;
  
    switch (master->pass_type) {
***************
*** 414,424 ****
        (*cinfo->downsample->start_pass) (cinfo);
        (*cinfo->prep->start_pass) (cinfo, JBUF_PASS_THRU);
      }
!     (*cinfo->fdct->start_pass) (cinfo);
!     (*cinfo->entropy->start_pass) (cinfo, cinfo->optimize_coding);
!     (*cinfo->coef->start_pass) (cinfo,
! 				(master->total_passes > 1 ?
! 				 JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
      (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
      if (cinfo->optimize_coding) {
        /* No immediate data output; postpone writing frame/scan headers */
--- 467,476 ----
        (*cinfo->downsample->start_pass) (cinfo);
        (*cinfo->prep->start_pass) (cinfo, JBUF_PASS_THRU);
      }
!     (*cinfo->codec->entropy_start_pass) (cinfo, cinfo->optimize_coding);
!     (*cinfo->codec->start_pass) (cinfo,
! 				 (master->total_passes > 1 ?
! 				  JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
      (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
      if (cinfo->optimize_coding) {
        /* No immediate data output; postpone writing frame/scan headers */
***************
*** 433,441 ****
      /* Do Huffman optimization for a scan after the first one. */
      select_scan_parameters(cinfo);
      per_scan_setup(cinfo);
!     if (cinfo->Ss != 0 || cinfo->Ah == 0 || cinfo->arith_code) {
!       (*cinfo->entropy->start_pass) (cinfo, TRUE);
!       (*cinfo->coef->start_pass) (cinfo, JBUF_CRANK_DEST);
        master->pub.call_pass_startup = FALSE;
        break;
      }
--- 485,493 ----
      /* Do Huffman optimization for a scan after the first one. */
      select_scan_parameters(cinfo);
      per_scan_setup(cinfo);
!     if ((*cinfo->codec->need_optimization_pass) (cinfo) || cinfo->arith_code) {
!       (*cinfo->codec->entropy_start_pass) (cinfo, TRUE);
!       (*cinfo->codec->start_pass) (cinfo, JBUF_CRANK_DEST);
        master->pub.call_pass_startup = FALSE;
        break;
      }
***************
*** 453,460 ****
        select_scan_parameters(cinfo);
        per_scan_setup(cinfo);
      }
!     (*cinfo->entropy->start_pass) (cinfo, FALSE);
!     (*cinfo->coef->start_pass) (cinfo, JBUF_CRANK_DEST);
      /* We emit frame/scan headers now */
      if (master->scan_number == 0)
        (*cinfo->marker->write_frame_header) (cinfo);
--- 505,512 ----
        select_scan_parameters(cinfo);
        per_scan_setup(cinfo);
      }
!     (*cinfo->codec->entropy_start_pass) (cinfo, FALSE);
!     (*cinfo->codec->start_pass) (cinfo, JBUF_CRANK_DEST);
      /* We emit frame/scan headers now */
      if (master->scan_number == 0)
        (*cinfo->marker->write_frame_header) (cinfo);
***************
*** 502,513 ****
  METHODDEF(void)
  finish_pass_master (j_compress_ptr cinfo)
  {
    my_master_ptr master = (my_master_ptr) cinfo->master;
  
    /* The entropy coder always needs an end-of-pass call,
     * either to analyze statistics or to flush its output buffer.
     */
!   (*cinfo->entropy->finish_pass) (cinfo);
  
    /* Update state for next pass */
    switch (master->pass_type) {
--- 554,566 ----
  METHODDEF(void)
  finish_pass_master (j_compress_ptr cinfo)
  {
+   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
    my_master_ptr master = (my_master_ptr) cinfo->master;
  
    /* The entropy coder always needs an end-of-pass call,
     * either to analyze statistics or to flush its output buffer.
     */
!   (*lossyc->pub.entropy_finish_pass) (cinfo);
  
    /* Update state for next pass */
    switch (master->pass_type) {
***************
*** 553,574 ****
    master->pub.finish_pass = finish_pass_master;
    master->pub.is_last_pass = FALSE;
  
    /* Validate parameters, determine derived values */
    initial_setup(cinfo);
  
    if (cinfo->scan_info != NULL) {
! #ifdef C_MULTISCAN_FILES_SUPPORTED
      validate_script(cinfo);
  #else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
  #endif
    } else {
!     cinfo->progressive_mode = FALSE;
      cinfo->num_scans = 1;
    }
  
!   if (cinfo->progressive_mode)	/*  TEMPORARY HACK ??? */
!     cinfo->optimize_coding = TRUE; /* assume default tables no good for progressive mode */
  
    /* Initialize my private state */
    if (transcode_only) {
--- 606,631 ----
    master->pub.finish_pass = finish_pass_master;
    master->pub.is_last_pass = FALSE;
  
+   cinfo->data_unit = cinfo->lossless ? 1 : DCTSIZE;
+ 
    /* Validate parameters, determine derived values */
    initial_setup(cinfo);
  
    if (cinfo->scan_info != NULL) {
! #ifdef NEED_SCAN_SCRIPT
      validate_script(cinfo);
  #else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
  #endif
    } else {
!     cinfo->process = JPROC_SEQUENTIAL;
      cinfo->num_scans = 1;
    }
  
!   if (cinfo->process == JPROC_PROGRESSIVE ||	/*  TEMPORARY HACK ??? */
!       cinfo->process == JPROC_LOSSLESS)
!     cinfo->optimize_coding = TRUE; /* assume default tables no good for
! 				    * progressive mode or lossless mode */
  
    /* Initialize my private state */
    if (transcode_only) {
diff -cN ../jpeg-6b/jcodec.c ./jcodec.c
*** ../jpeg-6b/jcodec.c
--- ./jcodec.c	Tue Apr 27 14:58:19 1999
***************
*** 0 ****
--- 1,53 ----
+ /*
+  * jcodec.c
+  *
+  * Copyright (C) 1998, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+  * This file contains utility functions for the JPEG codec(s).
+  */
+ 
+ #define JPEG_INTERNALS
+ #include "jinclude.h"
+ #include "jpeglib.h"
+ #include "jlossy.h"
+ #include "jlossls.h"
+ 
+ 
+ /*
+  * Initialize the compression codec.
+  * This is called only once, during master selection.
+  */
+ 
+ GLOBAL(void)
+ jinit_c_codec (j_compress_ptr cinfo)
+ {
+   if (cinfo->process == JPROC_LOSSLESS) {
+ #ifdef C_LOSSLESS_SUPPORTED
+     jinit_lossless_c_codec(cinfo);
+ #else
+     ERREXIT(cinfo, JERR_NOT_COMPILED);
+ #endif
+   } else
+     jinit_lossy_c_codec(cinfo);
+ }
+ 
+ 
+ /*
+  * Initialize the decompression codec.
+  * This is called only once, during master selection.
+  */
+ 
+ GLOBAL(void)
+ jinit_d_codec (j_decompress_ptr cinfo)
+ {
+   if (cinfo->process == JPROC_LOSSLESS) {
+ #ifdef D_LOSSLESS_SUPPORTED
+     jinit_lossless_d_codec(cinfo);
+ #else
+     ERREXIT(cinfo, JERR_NOT_COMPILED);
+ #endif
+   } else
+     jinit_lossy_d_codec(cinfo);
+ }
diff -cN ../jpeg-6b/jcparam.c ./jcparam.c
*** ../jpeg-6b/jcparam.c	Sat Feb 21 14:59:42 1998
--- ./jcparam.c	Tue Apr 27 14:58:19 1999
***************
*** 284,289 ****
--- 284,290 ----
  
    /* Initialize everything not dependent on the color space */
  
+   cinfo->lossless = FALSE;
    cinfo->data_precision = BITS_IN_JSAMPLE;
    /* Set up two quantization tables using default quality of 75 */
    jpeg_set_quality(cinfo, 75, TRUE);
***************
*** 358,384 ****
  GLOBAL(void)
  jpeg_default_colorspace (j_compress_ptr cinfo)
  {
!   switch (cinfo->in_color_space) {
!   case JCS_GRAYSCALE:
!     jpeg_set_colorspace(cinfo, JCS_GRAYSCALE);
!     break;
!   case JCS_RGB:
!     jpeg_set_colorspace(cinfo, JCS_YCbCr);
!     break;
!   case JCS_YCbCr:
!     jpeg_set_colorspace(cinfo, JCS_YCbCr);
!     break;
!   case JCS_CMYK:
!     jpeg_set_colorspace(cinfo, JCS_CMYK); /* By default, no translation */
!     break;
!   case JCS_YCCK:
!     jpeg_set_colorspace(cinfo, JCS_YCCK);
!     break;
!   case JCS_UNKNOWN:
!     jpeg_set_colorspace(cinfo, JCS_UNKNOWN);
!     break;
!   default:
!     ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
    }
  }
  
--- 359,389 ----
  GLOBAL(void)
  jpeg_default_colorspace (j_compress_ptr cinfo)
  {
!   if (cinfo->lossless)
!     jpeg_set_colorspace(cinfo, cinfo->in_color_space);
!   else { /* lossy */
!     switch (cinfo->in_color_space) {
!     case JCS_GRAYSCALE:
!       jpeg_set_colorspace(cinfo, JCS_GRAYSCALE);
!       break;
!     case JCS_RGB:
!       jpeg_set_colorspace(cinfo, JCS_YCbCr);
!       break;
!     case JCS_YCbCr:
!       jpeg_set_colorspace(cinfo, JCS_YCbCr);
!       break;
!     case JCS_CMYK:
!       jpeg_set_colorspace(cinfo, JCS_CMYK); /* By default, no translation */
!       break;
!     case JCS_YCCK:
!       jpeg_set_colorspace(cinfo, JCS_YCCK);
!       break;
!     case JCS_UNKNOWN:
!       jpeg_set_colorspace(cinfo, JCS_UNKNOWN);
!       break;
!     default:
!       ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
!     }
    }
  }
  
***************
*** 433,442 ****
      cinfo->write_JFIF_header = TRUE; /* Write a JFIF marker */
      cinfo->num_components = 3;
      /* JFIF specifies component IDs 1,2,3 */
!     /* We default to 2x2 subsamples of chrominance */
!     SET_COMP(0, 1, 2,2, 0, 0,0);
!     SET_COMP(1, 2, 1,1, 1, 1,1);
!     SET_COMP(2, 3, 1,1, 1, 1,1);
      break;
    case JCS_CMYK:
      cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag CMYK */
--- 438,453 ----
      cinfo->write_JFIF_header = TRUE; /* Write a JFIF marker */
      cinfo->num_components = 3;
      /* JFIF specifies component IDs 1,2,3 */
!     if (cinfo->lossless) {
!       SET_COMP(0, 1, 1,1, 0, 0,0);
!       SET_COMP(1, 2, 1,1, 1, 1,1);
!       SET_COMP(2, 3, 1,1, 1, 1,1);
!     } else { /* lossy */
!       /* We default to 2x2 subsamples of chrominance */
!       SET_COMP(0, 1, 2,2, 0, 0,0);
!       SET_COMP(1, 2, 1,1, 1, 1,1);
!       SET_COMP(2, 3, 1,1, 1, 1,1);
!     }
      break;
    case JCS_CMYK:
      cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag CMYK */
***************
*** 449,458 ****
    case JCS_YCCK:
      cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag YCCK */
      cinfo->num_components = 4;
!     SET_COMP(0, 1, 2,2, 0, 0,0);
!     SET_COMP(1, 2, 1,1, 1, 1,1);
!     SET_COMP(2, 3, 1,1, 1, 1,1);
!     SET_COMP(3, 4, 2,2, 0, 0,0);
      break;
    case JCS_UNKNOWN:
      cinfo->num_components = cinfo->input_components;
--- 460,476 ----
    case JCS_YCCK:
      cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag YCCK */
      cinfo->num_components = 4;
!     if (cinfo->lossless) {
!       SET_COMP(0, 1, 1,1, 0, 0,0);
!       SET_COMP(1, 2, 1,1, 1, 1,1);
!       SET_COMP(2, 3, 1,1, 1, 1,1);
!       SET_COMP(3, 4, 1,1, 0, 0,0);
!     } else { /* lossy */
!       SET_COMP(0, 1, 2,2, 0, 0,0);
!       SET_COMP(1, 2, 1,1, 1, 1,1);
!       SET_COMP(2, 3, 1,1, 1, 1,1);
!       SET_COMP(3, 4, 2,2, 0, 0,0);
!     }
      break;
    case JCS_UNKNOWN:
      cinfo->num_components = cinfo->input_components;
***************
*** 472,492 ****
  #ifdef C_PROGRESSIVE_SUPPORTED
  
  LOCAL(jpeg_scan_info *)
- fill_a_scan (jpeg_scan_info * scanptr, int ci,
- 	     int Ss, int Se, int Ah, int Al)
- /* Support routine: generate one scan for specified component */
- {
-   scanptr->comps_in_scan = 1;
-   scanptr->component_index[0] = ci;
-   scanptr->Ss = Ss;
-   scanptr->Se = Se;
-   scanptr->Ah = Ah;
-   scanptr->Al = Al;
-   scanptr++;
-   return scanptr;
- }
- 
- LOCAL(jpeg_scan_info *)
  fill_scans (jpeg_scan_info * scanptr, int ncomps,
  	    int Ss, int Se, int Ah, int Al)
  /* Support routine: generate one scan for each component */
--- 490,495 ----
***************
*** 505,510 ****
--- 508,529 ----
    return scanptr;
  }
  
+ 
+ LOCAL(jpeg_scan_info *)
+ fill_a_scan (jpeg_scan_info * scanptr, int ci,
+ 	     int Ss, int Se, int Ah, int Al)
+ /* Support routine: generate one scan for specified component */
+ {
+   scanptr->comps_in_scan = 1;
+   scanptr->component_index[0] = ci;
+   scanptr->Ss = Ss;
+   scanptr->Se = Se;
+   scanptr->Ah = Ah;
+   scanptr->Al = Al;
+   scanptr++;
+   return scanptr;
+ }
+ 
  LOCAL(jpeg_scan_info *)
  fill_dc_scans (jpeg_scan_info * scanptr, int ncomps, int Ah, int Al)
  /* Support routine: generate interleaved DC scan if possible, else N scans */
***************
*** 608,610 ****
--- 627,687 ----
  }
  
  #endif /* C_PROGRESSIVE_SUPPORTED */
+ 
+ 
+ #ifdef C_LOSSLESS_SUPPORTED
+ 
+ /*
+  * Create a single-entry lossless-JPEG script containing all components.
+  * cinfo->num_components must be correct.
+  */
+ 
+ GLOBAL(void)
+ jpeg_simple_lossless (j_compress_ptr cinfo, int predictor, int point_transform)
+ {
+   int ncomps = cinfo->num_components;
+   int nscans = 1;
+   int ci;
+   jpeg_scan_info * scanptr;
+ 
+   /* Safety check to ensure start_compress not called yet. */
+   if (cinfo->global_state != CSTATE_START)
+     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
+ 
+   cinfo->lossless = TRUE;
+ 
+   /* Set jpeg_color_space. */
+   jpeg_default_colorspace(cinfo);
+ 
+   /* Check to ensure that all components will fit in one scan. */
+   if (cinfo->num_components > MAX_COMPS_IN_SCAN)
+     ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
+ 	     MAX_COMPS_IN_SCAN);
+ 
+   /* Allocate space for script.
+    * We need to put it in the permanent pool in case the application performs
+    * multiple compressions without changing the settings.  To avoid a memory
+    * leak if jpeg_simple_lossless is called repeatedly for the same JPEG
+    * object, we try to re-use previously allocated space.
+    */
+   if (cinfo->script_space == NULL || cinfo->script_space_size < nscans) {
+     cinfo->script_space_size = nscans;
+     cinfo->script_space = (jpeg_scan_info *)
+       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
+ 			cinfo->script_space_size * SIZEOF(jpeg_scan_info));
+   }
+   scanptr = cinfo->script_space;
+   cinfo->scan_info = scanptr;
+   cinfo->num_scans = nscans;
+ 
+   /* Fill the script. */
+   scanptr->comps_in_scan = ncomps;
+   for (ci = 0; ci < ncomps; ci++)
+     scanptr->component_index[ci] = ci;
+   scanptr->Ss = predictor;
+   scanptr->Se = 0;
+   scanptr->Ah = 0;
+   scanptr->Al = point_transform;
+ }
+ 
+ #endif /* C_LOSSLESS_SUPPORTED */
diff -cN ../jpeg-6b/jcphuff.c ./jcphuff.c
*** ../jpeg-6b/jcphuff.c	Mon Oct 20 20:21:14 1997
--- ./jcphuff.c	Tue Apr 27 14:58:20 1999
***************
*** 1,7 ****
  /*
   * jcphuff.c
   *
!  * Copyright (C) 1995-1997, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jcphuff.c
   *
!  * Copyright (C) 1995-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 15,21 ****
  #define JPEG_INTERNALS
  #include "jinclude.h"
  #include "jpeglib.h"
! #include "jchuff.h"		/* Declarations shared with jchuff.c */
  
  #ifdef C_PROGRESSIVE_SUPPORTED
  
--- 15,22 ----
  #define JPEG_INTERNALS
  #include "jinclude.h"
  #include "jpeglib.h"
! #include "jlossy.h"		/* Private declarations for lossy codec */
! #include "jchuff.h"		/* Declarations shared with jc*huff.c */
  
  #ifdef C_PROGRESSIVE_SUPPORTED
  
***************
*** 22,29 ****
  /* Expanded entropy encoder object for progressive Huffman encoding. */
  
  typedef struct {
-   struct jpeg_entropy_encoder pub; /* public fields */
- 
    /* Mode flag: TRUE for optimization, FALSE for actual data output */
    boolean gather_statistics;
  
--- 23,28 ----
***************
*** 105,111 ****
  METHODDEF(void)
  start_pass_phuff (j_compress_ptr cinfo, boolean gather_statistics)
  {  
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
    boolean is_DC_band;
    int ci, tbl;
    jpeg_component_info * compptr;
--- 104,111 ----
  METHODDEF(void)
  start_pass_phuff (j_compress_ptr cinfo, boolean gather_statistics)
  {  
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) lossyc->entropy_private;
    boolean is_DC_band;
    int ci, tbl;
    jpeg_component_info * compptr;
***************
*** 120,133 ****
    /* Select execution routines */
    if (cinfo->Ah == 0) {
      if (is_DC_band)
!       entropy->pub.encode_mcu = encode_mcu_DC_first;
      else
!       entropy->pub.encode_mcu = encode_mcu_AC_first;
    } else {
      if (is_DC_band)
!       entropy->pub.encode_mcu = encode_mcu_DC_refine;
      else {
!       entropy->pub.encode_mcu = encode_mcu_AC_refine;
        /* AC refinement needs a correction bit buffer */
        if (entropy->bit_buffer == NULL)
  	entropy->bit_buffer = (char *)
--- 120,133 ----
    /* Select execution routines */
    if (cinfo->Ah == 0) {
      if (is_DC_band)
!       lossyc->entropy_encode_mcu = encode_mcu_DC_first;
      else
!       lossyc->entropy_encode_mcu = encode_mcu_AC_first;
    } else {
      if (is_DC_band)
!       lossyc->entropy_encode_mcu = encode_mcu_DC_refine;
      else {
!       lossyc->entropy_encode_mcu = encode_mcu_AC_refine;
        /* AC refinement needs a correction bit buffer */
        if (entropy->bit_buffer == NULL)
  	entropy->bit_buffer = (char *)
***************
*** 136,144 ****
      }
    }
    if (gather_statistics)
!     entropy->pub.finish_pass = finish_pass_gather_phuff;
    else
!     entropy->pub.finish_pass = finish_pass_phuff;
  
    /* Only DC coefficients may be interleaved, so cinfo->comps_in_scan = 1
     * for AC coefficients.
--- 136,144 ----
      }
    }
    if (gather_statistics)
!     lossyc->pub.entropy_finish_pass = finish_pass_gather_phuff;
    else
!     lossyc->pub.entropy_finish_pass = finish_pass_phuff;
  
    /* Only DC coefficients may be interleaved, so cinfo->comps_in_scan = 1
     * for AC coefficients.
***************
*** 376,382 ****
  METHODDEF(boolean)
  encode_mcu_DC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
  {
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
    register int temp, temp2;
    register int nbits;
    int blkn, ci;
--- 376,383 ----
  METHODDEF(boolean)
  encode_mcu_DC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
  {
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) lossyc->entropy_private;
    register int temp, temp2;
    register int nbits;
    int blkn, ci;
***************
*** 394,400 ****
        emit_restart(entropy, entropy->next_restart_num);
  
    /* Encode the MCU data blocks */
!   for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
      block = MCU_data[blkn];
      ci = cinfo->MCU_membership[blkn];
      compptr = cinfo->cur_comp_info[ci];
--- 395,401 ----
        emit_restart(entropy, entropy->next_restart_num);
  
    /* Encode the MCU data blocks */
!   for (blkn = 0; blkn < cinfo->data_units_in_MCU; blkn++) {
      block = MCU_data[blkn];
      ci = cinfo->MCU_membership[blkn];
      compptr = cinfo->cur_comp_info[ci];
***************
*** 463,469 ****
  METHODDEF(boolean)
  encode_mcu_AC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
  {
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
    register int temp, temp2;
    register int nbits;
    register int r, k;
--- 464,471 ----
  METHODDEF(boolean)
  encode_mcu_AC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
  {
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) lossyc->entropy_private;
    register int temp, temp2;
    register int nbits;
    register int r, k;
***************
*** 570,576 ****
  METHODDEF(boolean)
  encode_mcu_DC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
  {
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
    register int temp;
    int blkn;
    int Al = cinfo->Al;
--- 572,579 ----
  METHODDEF(boolean)
  encode_mcu_DC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
  {
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) lossyc->entropy_private;
    register int temp;
    int blkn;
    int Al = cinfo->Al;
***************
*** 585,591 ****
        emit_restart(entropy, entropy->next_restart_num);
  
    /* Encode the MCU data blocks */
!   for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
      block = MCU_data[blkn];
  
      /* We simply emit the Al'th bit of the DC coefficient value. */
--- 588,594 ----
        emit_restart(entropy, entropy->next_restart_num);
  
    /* Encode the MCU data blocks */
!   for (blkn = 0; blkn < cinfo->data_units_in_MCU; blkn++) {
      block = MCU_data[blkn];
  
      /* We simply emit the Al'th bit of the DC coefficient value. */
***************
*** 617,623 ****
  METHODDEF(boolean)
  encode_mcu_AC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
  {
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
    register int temp;
    register int r, k;
    int EOB;
--- 620,627 ----
  METHODDEF(boolean)
  encode_mcu_AC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
  {
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) lossyc->entropy_private;
    register int temp;
    register int r, k;
    int EOB;
***************
*** 745,751 ****
  METHODDEF(void)
  finish_pass_phuff (j_compress_ptr cinfo)
  {   
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  
    entropy->next_output_byte = cinfo->dest->next_output_byte;
    entropy->free_in_buffer = cinfo->dest->free_in_buffer;
--- 749,756 ----
  METHODDEF(void)
  finish_pass_phuff (j_compress_ptr cinfo)
  {   
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) lossyc->entropy_private;
  
    entropy->next_output_byte = cinfo->dest->next_output_byte;
    entropy->free_in_buffer = cinfo->dest->free_in_buffer;
***************
*** 766,772 ****
  METHODDEF(void)
  finish_pass_gather_phuff (j_compress_ptr cinfo)
  {
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
    boolean is_DC_band;
    int ci, tbl;
    jpeg_component_info * compptr;
--- 771,778 ----
  METHODDEF(void)
  finish_pass_gather_phuff (j_compress_ptr cinfo)
  {
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) lossyc->entropy_private;
    boolean is_DC_band;
    int ci, tbl;
    jpeg_component_info * compptr;
***************
*** 806,811 ****
--- 812,824 ----
  }
  
  
+ METHODDEF(boolean)
+ need_optimization_pass (j_compress_ptr cinfo)
+ {
+   return (cinfo->Ss != 0 || cinfo->Ah == 0);
+ }
+ 
+ 
  /*
   * Module initialization routine for progressive Huffman entropy encoding.
   */
***************
*** 813,818 ****
--- 826,832 ----
  GLOBAL(void)
  jinit_phuff_encoder (j_compress_ptr cinfo)
  {
+   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
    phuff_entropy_ptr entropy;
    int i;
  
***************
*** 819,826 ****
    entropy = (phuff_entropy_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
  				SIZEOF(phuff_entropy_encoder));
!   cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;
!   entropy->pub.start_pass = start_pass_phuff;
  
    /* Mark tables unallocated */
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
--- 833,841 ----
    entropy = (phuff_entropy_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
  				SIZEOF(phuff_entropy_encoder));
!   lossyc->entropy_private = (struct jpeg_entropy_encoder *) entropy;
!   lossyc->pub.entropy_start_pass = start_pass_phuff;
!   lossyc->pub.need_optimization_pass = need_optimization_pass;
  
    /* Mark tables unallocated */
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
diff -cN ../jpeg-6b/jcpred.c ./jcpred.c
*** ../jpeg-6b/jcpred.c
--- ./jcpred.c	Tue Apr 27 14:58:20 1999
***************
*** 0 ****
--- 1,297 ----
+ /*
+  * jcpred.c
+  *
+  * Copyright (C) 1998, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+  * This file contains sample differencing for lossless JPEG.
+  *
+  * In order to avoid paying the performance penalty of having to check the
+  * predictor being used and the row being processed for each call of the
+  * undifferencer, and to promote optimization, we have separate differencing
+  * functions for each case.
+  *
+  * We are able to avoid duplicating source code by implementing the predictors
+  * and differencers as macros.  Each of the differencing functions are
+  * simply wrappers around a DIFFERENCE macro with the appropriate PREDICTOR
+  * macro passed as an argument.
+  */
+ 
+ #define JPEG_INTERNALS
+ #include "jinclude.h"
+ #include "jpeglib.h"
+ #include "jlossls.h"		/* Private declarations for lossless codec */
+ 
+ 
+ #ifdef C_LOSSLESS_SUPPORTED
+ 
+ /* Private predictor object */
+ 
+ typedef struct {
+   /* MCU-rows left in the restart interval for each component */
+   unsigned int restart_rows_to_go[MAX_COMPONENTS];
+ } c_predictor;
+ 
+ typedef c_predictor * c_pred_ptr;
+ 
+ /* Forward declarations */
+ LOCAL(void) reset_predictor
+ 	JPP((j_compress_ptr cinfo, int ci));
+ METHODDEF(void) start_pass
+ 	JPP((j_compress_ptr cinfo));
+ 
+ 
+ /* Predictor for the first column of the first row: 2^(P-Pt-1) */
+ #define INITIAL_PREDICTORx	(1 << (cinfo->data_precision - cinfo->Al - 1))
+ 
+ /* Predictor for the first column of the remaining rows: Rb */
+ #define INITIAL_PREDICTOR2	GETJSAMPLE(prev_row[0])
+ 
+ 
+ /*
+  * 1-Dimensional differencer routine.
+  *
+  * This macro implements the 1-D horizontal predictor (1).  INITIAL_PREDICTOR
+  * is used as the special case predictor for the first column, which must be
+  * either INITIAL_PREDICTOR2 or INITIAL_PREDICTORx.  The remaining samples
+  * use PREDICTOR1.
+  */
+ 
+ #define DIFFERENCE_1D(INITIAL_PREDICTOR) \
+ 	j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec; \
+ 	c_pred_ptr pred = (c_pred_ptr) losslsc->pred_private; \
+ 	boolean restart = FALSE; \
+ 	int xindex; \
+ 	int samp, Ra; \
+  \
+ 	samp = GETJSAMPLE(input_buf[0]); \
+ 	diff_buf[0] = samp - INITIAL_PREDICTOR; \
+  \
+ 	for (xindex = 1; xindex < width; xindex++) { \
+ 	  Ra = samp; \
+ 	  samp = GETJSAMPLE(input_buf[xindex]); \
+ 	  diff_buf[xindex] = samp - PREDICTOR1; \
+ 	} \
+  \
+ 	/* Account for restart interval (no-op if not using restarts) */ \
+ 	if (cinfo->restart_interval) { \
+ 	  if (--(pred->restart_rows_to_go[ci]) == 0) { \
+ 	    reset_predictor(cinfo, ci); \
+ 	    restart = TRUE; \
+ 	  } \
+ 	}
+ 
+ 
+ /*
+  * 2-Dimensional differencer routine.
+  *
+  * This macro implements the 2-D horizontal predictors (#2-7).  PREDICTOR2 is
+  * used as the special case predictor for the first column.  The remaining
+  * samples use PREDICTOR, which is a function of Ra, Rb, Rc.
+  *
+  * Because prev_row and output_buf may point to the same storage area (in an
+  * interleaved image with Vi=1, for example), we must take care to buffer Rb/Rc
+  * before writing the current reconstructed sample value into output_buf.
+  */
+ 
+ #define DIFFERENCE_2D(PREDICTOR) \
+ 	j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec; \
+ 	c_pred_ptr pred = (c_pred_ptr) losslsc->pred_private; \
+ 	int xindex; \
+ 	int samp, Ra, Rb, Rc; \
+  \
+ 	Rb = GETJSAMPLE(prev_row[0]); \
+ 	samp = GETJSAMPLE(input_buf[0]); \
+ 	diff_buf[0] = samp - PREDICTOR2; \
+  \
+ 	for (xindex = 1; xindex < width; xindex++) { \
+ 	  Rc = Rb; \
+ 	  Rb = GETJSAMPLE(prev_row[xindex]); \
+ 	  Ra = samp; \
+ 	  samp = GETJSAMPLE(input_buf[xindex]); \
+ 	  diff_buf[xindex] = samp - PREDICTOR; \
+ 	} \
+  \
+ 	/* Account for restart interval (no-op if not using restarts) */ \
+ 	if (cinfo->restart_interval) { \
+ 	  if (--pred->restart_rows_to_go[ci] == 0) \
+ 	    reset_predictor(cinfo, ci); \
+ 	}
+ 
+ 
+ /*
+  * Differencers for the all rows but the first in a scan or restart interval.
+  * The first sample in the row is differenced using the vertical
+  * predictor (2).  The rest of the samples are differenced using the
+  * predictor specified in the scan header.
+  */
+ 
+ METHODDEF(void)
+ jpeg_difference1(j_compress_ptr cinfo, int ci,
+ 		 JSAMPROW input_buf, JSAMPROW prev_row,
+ 		 JDIFFROW diff_buf, JDIMENSION width)
+ {
+   DIFFERENCE_1D(INITIAL_PREDICTOR2);
+ }
+ 
+ METHODDEF(void)
+ jpeg_difference2(j_compress_ptr cinfo, int ci,
+ 		 JSAMPROW input_buf, JSAMPROW prev_row,
+ 		 JDIFFROW diff_buf, JDIMENSION width)
+ {
+   DIFFERENCE_2D(PREDICTOR2);
+ }
+ 
+ METHODDEF(void)
+ jpeg_difference3(j_compress_ptr cinfo, int ci,
+ 		 JSAMPROW input_buf, JSAMPROW prev_row,
+ 		 JDIFFROW diff_buf, JDIMENSION width)
+ {
+   DIFFERENCE_2D(PREDICTOR3);
+ }
+ 
+ METHODDEF(void)
+ jpeg_difference4(j_compress_ptr cinfo, int ci,
+ 		 JSAMPROW input_buf, JSAMPROW prev_row,
+ 		 JDIFFROW diff_buf, JDIMENSION width)
+ {
+   DIFFERENCE_2D(PREDICTOR4);
+ }
+ 
+ METHODDEF(void)
+ jpeg_difference5(j_compress_ptr cinfo, int ci,
+ 		 JSAMPROW input_buf, JSAMPROW prev_row,
+ 		 JDIFFROW diff_buf, JDIMENSION width)
+ {
+   DIFFERENCE_2D(PREDICTOR5);
+ }
+ 
+ METHODDEF(void)
+ jpeg_difference6(j_compress_ptr cinfo, int ci,
+ 		 JSAMPROW input_buf, JSAMPROW prev_row,
+ 		 JDIFFROW diff_buf, JDIMENSION width)
+ {
+   DIFFERENCE_2D(PREDICTOR6);
+ }
+ 
+ METHODDEF(void)
+ jpeg_difference7(j_compress_ptr cinfo, int ci,
+ 		 JSAMPROW input_buf, JSAMPROW prev_row,
+ 		 JDIFFROW diff_buf, JDIMENSION width)
+ {
+   DIFFERENCE_2D(PREDICTOR7);
+ }
+ 
+ 
+ /*
+  * Differencer for the first row in a scan or restart interval.  The first
+  * sample in the row is differenced using the special predictor constant
+  * x=2^(P-Pt-1).  The rest of the samples are differenced using the
+  * 1-D horizontal predictor (1).
+  */
+ 
+ METHODDEF(void)
+ jpeg_difference_first_row(j_compress_ptr cinfo, int ci,
+ 		 JSAMPROW input_buf, JSAMPROW prev_row,
+ 		 JDIFFROW diff_buf, JDIMENSION width)
+ {
+   DIFFERENCE_1D(INITIAL_PREDICTORx);
+ 
+   /*
+    * Now that we have differenced the first row, we want to use the
+    * differencer which corresponds to the predictor specified in the
+    * scan header.
+    *
+    * Note that we don't to do this if we have just reset the predictor
+    * for a new restart interval.
+    */
+   if (!restart) {
+     switch (cinfo->Ss) {
+     case 1:
+       losslsc->predict_difference[ci] = jpeg_difference1;
+       break;
+     case 2:
+       losslsc->predict_difference[ci] = jpeg_difference2;
+       break;
+     case 3:
+       losslsc->predict_difference[ci] = jpeg_difference3;
+       break;
+     case 4:
+       losslsc->predict_difference[ci] = jpeg_difference4;
+       break;
+     case 5:
+       losslsc->predict_difference[ci] = jpeg_difference5;
+       break;
+     case 6:
+       losslsc->predict_difference[ci] = jpeg_difference6;
+       break;
+     case 7:
+       losslsc->predict_difference[ci] = jpeg_difference7;
+       break;
+     }
+   }
+ }
+ 
+ /*
+  * Reset predictor at the start of a pass or restart interval.
+  */
+ 
+ LOCAL(void)
+ reset_predictor (j_compress_ptr cinfo, int ci)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+   c_pred_ptr pred = (c_pred_ptr) losslsc->pred_private;
+ 
+   /* Initialize restart counter */
+   pred->restart_rows_to_go[ci] =
+     cinfo->restart_interval / cinfo->MCUs_per_row;
+ 
+   /* Set difference function to first row function */
+   losslsc->predict_difference[ci] = jpeg_difference_first_row;
+ }
+ 
+ 
+ /*
+  * Initialize for an input processing pass.
+  */
+ 
+ METHODDEF(void)
+ start_pass (j_compress_ptr cinfo)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+   c_pred_ptr pred = (c_pred_ptr) losslsc->pred_private;
+   int ci;
+ 
+   /* Check that the restart interval is an integer multiple of the number 
+    * of MCU in an MCU-row.
+    */
+   if (cinfo->restart_interval % cinfo->MCUs_per_row != 0)
+     ERREXIT2(cinfo, JERR_BAD_RESTART,
+ 	     cinfo->restart_interval, cinfo->MCUs_per_row);
+ 
+   /* Set predictors for start of pass */
+   for (ci = 0; ci < cinfo->num_components; ci++)
+     reset_predictor(cinfo, ci);
+ }
+ 
+ 
+ /*
+  * Module initialization routine for the differencer.
+  */
+ 
+ GLOBAL(void)
+ jinit_differencer (j_compress_ptr cinfo)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+   c_pred_ptr pred;
+ 
+   pred = (c_pred_ptr)
+     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
+ 				SIZEOF(c_predictor));
+   losslsc->pred_private = (void *) pred;
+   losslsc->predict_start_pass = start_pass;
+ }
+ 
+ #endif /* C_LOSSLESS_SUPPORTED */
+ 
diff -cN ../jpeg-6b/jcprepct.c ./jcprepct.c
*** ../jpeg-6b/jcprepct.c	Sat Jan  6 18:25:51 1996
--- ./jcprepct.c	Tue Apr 27 14:58:20 1999
***************
*** 1,7 ****
  /*
   * jcprepct.c
   *
!  * Copyright (C) 1994-1996, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jcprepct.c
   *
!  * Copyright (C) 1994-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 174,180 ****
        for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
  	   ci++, compptr++) {
  	expand_bottom_edge(output_buf[ci],
! 			   compptr->width_in_blocks * DCTSIZE,
  			   (int) (*out_row_group_ctr * compptr->v_samp_factor),
  			   (int) (out_row_groups_avail * compptr->v_samp_factor));
        }
--- 174,180 ----
        for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
  	   ci++, compptr++) {
  	expand_bottom_edge(output_buf[ci],
! 			   compptr->width_in_data_units * cinfo->data_unit,
  			   (int) (*out_row_group_ctr * compptr->v_samp_factor),
  			   (int) (out_row_groups_avail * compptr->v_samp_factor));
        }
***************
*** 288,294 ****
       */
      true_buffer = (*cinfo->mem->alloc_sarray)
        ((j_common_ptr) cinfo, JPOOL_IMAGE,
!        (JDIMENSION) (((long) compptr->width_in_blocks * DCTSIZE *
  		      cinfo->max_h_samp_factor) / compptr->h_samp_factor),
         (JDIMENSION) (3 * rgroup_height));
      /* Copy true buffer row pointers into the middle of the fake row array */
--- 288,294 ----
       */
      true_buffer = (*cinfo->mem->alloc_sarray)
        ((j_common_ptr) cinfo, JPOOL_IMAGE,
!        (JDIMENSION) (((long) compptr->width_in_data_units * cinfo->data_unit *
  		      cinfo->max_h_samp_factor) / compptr->h_samp_factor),
         (JDIMENSION) (3 * rgroup_height));
      /* Copy true buffer row pointers into the middle of the fake row array */
***************
*** 346,352 ****
  	 ci++, compptr++) {
        prep->color_buf[ci] = (*cinfo->mem->alloc_sarray)
  	((j_common_ptr) cinfo, JPOOL_IMAGE,
! 	 (JDIMENSION) (((long) compptr->width_in_blocks * DCTSIZE *
  			cinfo->max_h_samp_factor) / compptr->h_samp_factor),
  	 (JDIMENSION) cinfo->max_v_samp_factor);
      }
--- 346,352 ----
  	 ci++, compptr++) {
        prep->color_buf[ci] = (*cinfo->mem->alloc_sarray)
  	((j_common_ptr) cinfo, JPOOL_IMAGE,
! 	 (JDIMENSION) (((long) compptr->width_in_data_units * cinfo->data_unit *
  			cinfo->max_h_samp_factor) / compptr->h_samp_factor),
  	 (JDIMENSION) cinfo->max_v_samp_factor);
      }
diff -cN ../jpeg-6b/jcsample.c ./jcsample.c
*** ../jpeg-6b/jcsample.c	Sat Jan  6 18:25:54 1996
--- ./jcsample.c	Tue Apr 27 14:58:20 1999
***************
*** 1,7 ****
  /*
   * jcsample.c
   *
!  * Copyright (C) 1991-1996, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jcsample.c
   *
!  * Copyright (C) 1991-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 142,148 ****
  {
    int inrow, outrow, h_expand, v_expand, numpix, numpix2, h, v;
    JDIMENSION outcol, outcol_h;	/* outcol_h == outcol*h_expand */
!   JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
    JSAMPROW inptr, outptr;
    INT32 outvalue;
  
--- 142,148 ----
  {
    int inrow, outrow, h_expand, v_expand, numpix, numpix2, h, v;
    JDIMENSION outcol, outcol_h;	/* outcol_h == outcol*h_expand */
!   JDIMENSION output_cols = compptr->width_in_data_units * cinfo->data_unit;
    JSAMPROW inptr, outptr;
    INT32 outvalue;
  
***************
*** 192,198 ****
  		    cinfo->max_v_samp_factor, cinfo->image_width);
    /* Edge-expand */
    expand_right_edge(output_data, cinfo->max_v_samp_factor,
! 		    cinfo->image_width, compptr->width_in_blocks * DCTSIZE);
  }
  
  
--- 192,198 ----
  		    cinfo->max_v_samp_factor, cinfo->image_width);
    /* Edge-expand */
    expand_right_edge(output_data, cinfo->max_v_samp_factor,
! 		    cinfo->image_width, compptr->width_in_data_units * cinfo->data_unit);
  }
  
  
***************
*** 214,220 ****
  {
    int outrow;
    JDIMENSION outcol;
!   JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
    register JSAMPROW inptr, outptr;
    register int bias;
  
--- 214,220 ----
  {
    int outrow;
    JDIMENSION outcol;
!   JDIMENSION output_cols = compptr->width_in_data_units * cinfo->data_unit;
    register JSAMPROW inptr, outptr;
    register int bias;
  
***************
*** 251,257 ****
  {
    int inrow, outrow;
    JDIMENSION outcol;
!   JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
    register JSAMPROW inptr0, inptr1, outptr;
    register int bias;
  
--- 251,257 ----
  {
    int inrow, outrow;
    JDIMENSION outcol;
!   JDIMENSION output_cols = compptr->width_in_data_units * cinfo->data_unit;
    register JSAMPROW inptr0, inptr1, outptr;
    register int bias;
  
***************
*** 294,300 ****
  {
    int inrow, outrow;
    JDIMENSION colctr;
!   JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
    register JSAMPROW inptr0, inptr1, above_ptr, below_ptr, outptr;
    INT32 membersum, neighsum, memberscale, neighscale;
  
--- 294,300 ----
  {
    int inrow, outrow;
    JDIMENSION colctr;
!   JDIMENSION output_cols = compptr->width_in_data_units * cinfo->data_unit;
    register JSAMPROW inptr0, inptr1, above_ptr, below_ptr, outptr;
    INT32 membersum, neighsum, memberscale, neighscale;
  
***************
*** 394,400 ****
  {
    int outrow;
    JDIMENSION colctr;
!   JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
    register JSAMPROW inptr, above_ptr, below_ptr, outptr;
    INT32 membersum, neighsum, memberscale, neighscale;
    int colsum, lastcolsum, nextcolsum;
--- 394,400 ----
  {
    int outrow;
    JDIMENSION colctr;
!   JDIMENSION output_cols = compptr->width_in_data_units * cinfo->data_unit;
    register JSAMPROW inptr, above_ptr, below_ptr, outptr;
    INT32 membersum, neighsum, memberscale, neighscale;
    int colsum, lastcolsum, nextcolsum;
diff -cN ../jpeg-6b/jcscale.c ./jcscale.c
*** ../jpeg-6b/jcscale.c
--- ./jcscale.c	Tue Apr 27 14:58:21 1999
***************
*** 0 ****
--- 1,62 ----
+ /*
+  * jcscale.c
+  *
+  * Copyright (C) 1998, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+  * This file contains sample downscaling by 2^Pt for lossless JPEG.
+  */
+ 
+ #define JPEG_INTERNALS
+ #include "jinclude.h"
+ #include "jpeglib.h"
+ #include "jlossls.h"		/* Private declarations for lossless codec */
+ 
+ 
+ #ifdef C_LOSSLESS_SUPPORTED
+ 
+ METHODDEF(void)
+ simple_downscale(j_compress_ptr cinfo,
+ 		 JSAMPROW input_buf, JSAMPROW output_buf, JDIMENSION width)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+   int xindex;
+ 
+   for (xindex = 0; xindex < width; xindex++)
+     output_buf[xindex] = (JSAMPLE) RIGHT_SHIFT(GETJSAMPLE(input_buf[xindex]),
+ 					       cinfo->Al);
+ }
+ 
+ 
+ METHODDEF(void)
+ noscale(j_compress_ptr cinfo,
+ 	JSAMPROW input_buf, JSAMPROW output_buf, JDIMENSION width)
+ {
+   MEMCOPY(output_buf, input_buf, width * SIZEOF(JSAMPLE));
+   return;
+ }
+ 
+ 
+ METHODDEF(void)
+ scaler_start_pass (j_compress_ptr cinfo)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+ 
+   /* Set scaler function based on Pt */
+   if (cinfo->Al)
+     losslsc->scaler_scale = simple_downscale;
+   else
+     losslsc->scaler_scale = noscale;
+ }
+ 
+ 
+ GLOBAL(void)
+ jinit_c_scaler (j_compress_ptr cinfo)
+ {
+   j_lossless_c_ptr losslsc = (j_lossless_c_ptr) cinfo->codec;
+ 
+   losslsc->scaler_start_pass = scaler_start_pass;
+ }
+ 
+ #endif /* C_LOSSLESS_SUPPORTED */
diff -cN ../jpeg-6b/jcshuff.c ./jcshuff.c
*** ../jpeg-6b/jcshuff.c
--- ./jcshuff.c	Tue Apr 27 14:58:21 1999
***************
*** 0 ****
--- 1,661 ----
+ /*
+  * jcshuff.c
+  *
+  * Copyright (C) 1991-1998, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+  * This file contains Huffman entropy encoding routines for sequential JPEG.
+  *
+  * Much of the complexity here has to do with supporting output suspension.
+  * If the data destination module demands suspension, we want to be able to
+  * back up to the start of the current MCU.  To do this, we copy state
+  * variables into local working storage, and update them back to the
+  * permanent JPEG objects only upon successful completion of an MCU.
+  */
+ 
+ #define JPEG_INTERNALS
+ #include "jinclude.h"
+ #include "jpeglib.h"
+ #include "jlossy.h"		/* Private declarations for lossy codec */
+ #include "jchuff.h"		/* Declarations shared with jc*huff.c */
+ 
+ 
+ /* Expanded entropy encoder object for Huffman encoding.
+  *
+  * The savable_state subrecord contains fields that change within an MCU,
+  * but must not be updated permanently until we complete the MCU.
+  */
+ 
+ typedef struct {
+   INT32 put_buffer;		/* current bit-accumulation buffer */
+   int put_bits;			/* # of bits now in it */
+   int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */
+ } savable_state;
+ 
+ /* This macro is to work around compilers with missing or broken
+  * structure assignment.  You'll need to fix this code if you have
+  * such a compiler and you change MAX_COMPS_IN_SCAN.
+  */
+ 
+ #ifndef NO_STRUCT_ASSIGN
+ #define ASSIGN_STATE(dest,src)  ((dest) = (src))
+ #else
+ #if MAX_COMPS_IN_SCAN == 4
+ #define ASSIGN_STATE(dest,src)  \
+ 	((dest).put_buffer = (src).put_buffer, \
+ 	 (dest).put_bits = (src).put_bits, \
+ 	 (dest).last_dc_val[0] = (src).last_dc_val[0], \
+ 	 (dest).last_dc_val[1] = (src).last_dc_val[1], \
+ 	 (dest).last_dc_val[2] = (src).last_dc_val[2], \
+ 	 (dest).last_dc_val[3] = (src).last_dc_val[3])
+ #endif
+ #endif
+ 
+ 
+ typedef struct {
+   savable_state saved;		/* Bit buffer & DC state at start of MCU */
+ 
+   /* These fields are NOT loaded into local working state. */
+   unsigned int restarts_to_go;	/* MCUs left in this restart interval */
+   int next_restart_num;		/* next restart number to write (0-7) */
+ 
+   /* Pointers to derived tables (these workspaces have image lifespan) */
+   c_derived_tbl * dc_derived_tbls[NUM_HUFF_TBLS];
+   c_derived_tbl * ac_derived_tbls[NUM_HUFF_TBLS];
+ 
+ #ifdef ENTROPY_OPT_SUPPORTED	/* Statistics tables for optimization */
+   long * dc_count_ptrs[NUM_HUFF_TBLS];
+   long * ac_count_ptrs[NUM_HUFF_TBLS];
+ #endif
+ } shuff_entropy_encoder;
+ 
+ typedef shuff_entropy_encoder * shuff_entropy_ptr;
+ 
+ /* Working state while writing an MCU.
+  * This struct contains all the fields that are needed by subroutines.
+  */
+ 
+ typedef struct {
+   JOCTET * next_output_byte;	/* => next byte to write in buffer */
+   size_t free_in_buffer;	/* # of byte spaces remaining in buffer */
+   savable_state cur;		/* Current bit buffer & DC state */
+   j_compress_ptr cinfo;		/* dump_buffer needs access to this */
+ } working_state;
+ 
+ 
+ /* Forward declarations */
+ METHODDEF(boolean) encode_mcu_huff JPP((j_compress_ptr cinfo,
+ 					JBLOCKROW *MCU_data));
+ METHODDEF(void) finish_pass_huff JPP((j_compress_ptr cinfo));
+ #ifdef ENTROPY_OPT_SUPPORTED
+ METHODDEF(boolean) encode_mcu_gather JPP((j_compress_ptr cinfo,
+ 					  JBLOCKROW *MCU_data));
+ METHODDEF(void) finish_pass_gather JPP((j_compress_ptr cinfo));
+ #endif
+ 
+ 
+ /*
+  * Initialize for a Huffman-compressed scan.
+  * If gather_statistics is TRUE, we do not output anything during the scan,
+  * just count the Huffman symbols used and generate Huffman code tables.
+  */
+ 
+ METHODDEF(void)
+ start_pass_huff (j_compress_ptr cinfo, boolean gather_statistics)
+ {
+   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
+   shuff_entropy_ptr entropy = (shuff_entropy_ptr) lossyc->entropy_private;
+   int ci, dctbl, actbl;
+   jpeg_component_info * compptr;
+ 
+   if (gather_statistics) {
+ #ifdef ENTROPY_OPT_SUPPORTED
+     lossyc->entropy_encode_mcu = encode_mcu_gather;
+     lossyc->pub.entropy_finish_pass = finish_pass_gather;
+ #else
+     ERREXIT(cinfo, JERR_NOT_COMPILED);
+ #endif
+   } else {
+     lossyc->entropy_encode_mcu = encode_mcu_huff;
+     lossyc->pub.entropy_finish_pass = finish_pass_huff;
+   }
+ 
+   for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
+     compptr = cinfo->cur_comp_info[ci];
+     dctbl = compptr->dc_tbl_no;
+     actbl = compptr->ac_tbl_no;
+     if (gather_statistics) {
+ #ifdef ENTROPY_OPT_SUPPORTED
+       /* Check for invalid table indexes */
+       /* (make_c_derived_tbl does this in the other path) */
+       if (dctbl < 0 || dctbl >= NUM_HUFF_TBLS)
+ 	ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, dctbl);
+       if (actbl < 0 || actbl >= NUM_HUFF_TBLS)
+ 	ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, actbl);
+       /* Allocate and zero the statistics tables */
+       /* Note that jpeg_gen_optimal_table expects 257 entries in each table! */
+       if (entropy->dc_count_ptrs[dctbl] == NULL)
+ 	entropy->dc_count_ptrs[dctbl] = (long *)
+ 	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
+ 				      257 * SIZEOF(long));
+       MEMZERO(entropy->dc_count_ptrs[dctbl], 257 * SIZEOF(long));
+       if (entropy->ac_count_ptrs[actbl] == NULL)
+ 	entropy->ac_count_ptrs[actbl] = (long *)
+ 	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
+ 				      257 * SIZEOF(long));
+       MEMZERO(entropy->ac_count_ptrs[actbl], 257 * SIZEOF(long));
+ #endif
+     } else {
+       /* Compute derived values for Huffman tables */
+       /* We may do this more than once for a table, but it's not expensive */
+       jpeg_make_c_derived_tbl(cinfo, TRUE, dctbl,
+ 			      & entropy->dc_derived_tbls[dctbl]);
+       jpeg_make_c_derived_tbl(cinfo, FALSE, actbl,
+ 			      & entropy->ac_derived_tbls[actbl]);
+     }
+     /* Initialize DC predictions to 0 */
+     entropy->saved.last_dc_val[ci] = 0;
+   }
+ 
+   /* Initialize bit buffer to empty */
+   entropy->saved.put_buffer = 0;
+   entropy->saved.put_bits = 0;
+ 
+   /* Initialize restart stuff */
+   entropy->restarts_to_go = cinfo->restart_interval;
+   entropy->next_restart_num = 0;
+ }
+ 
+ 
+ /* Outputting bytes to the file */
+ 
+ /* Emit a byte, taking 'action' if must suspend. */
+ #define emit_byte(state,val,action)  \
+ 	{ *(state)->next_output_byte++ = (JOCTET) (val);  \
+ 	  if (--(state)->free_in_buffer == 0)  \
+ 	    if (! dump_buffer(state))  \
+ 	      { action; } }
+ 
+ 
+ LOCAL(boolean)
+ dump_buffer (working_state * state)
+ /* Empty the output buffer; return TRUE if successful, FALSE if must suspend */
+ {
+   struct jpeg_destination_mgr * dest = state->cinfo->dest;
+ 
+   if (! (*dest->empty_output_buffer) (state->cinfo))
+     return FALSE;
+   /* After a successful buffer dump, must reset buffer pointers */
+   state->next_output_byte = dest->next_output_byte;
+   state->free_in_buffer = dest->free_in_buffer;
+   return TRUE;
+ }
+ 
+ 
+ /* Outputting bits to the file */
+ 
+ /* Only the right 24 bits of put_buffer are used; the valid bits are
+  * left-justified in this part.  At most 16 bits can be passed to emit_bits
+  * in one call, and we never retain more than 7 bits in put_buffer
+  * between calls, so 24 bits are sufficient.
+  */
+ 
+ INLINE
+ LOCAL(boolean)
+ emit_bits (working_state * state, unsigned int code, int size)
+ /* Emit some bits; return TRUE if successful, FALSE if must suspend */
+ {
+   /* This routine is heavily used, so it's worth coding tightly. */
+   register INT32 put_buffer = (INT32) code;
+   register int put_bits = state->cur.put_bits;
+ 
+   /* if size is 0, caller used an invalid Huffman table entry */
+   if (size == 0)
+     ERREXIT(state->cinfo, JERR_HUFF_MISSING_CODE);
+ 
+   put_buffer &= (((INT32) 1)<<size) - 1; /* mask off any extra bits in code */
+   
+   put_bits += size;		/* new number of bits in buffer */
+   
+   put_buffer <<= 24 - put_bits; /* align incoming bits */
+ 
+   put_buffer |= state->cur.put_buffer; /* and merge with old buffer contents */
+   
+   while (put_bits >= 8) {
+     int c = (int) ((put_buffer >> 16) & 0xFF);
+     
+     emit_byte(state, c, return FALSE);
+     if (c == 0xFF) {		/* need to stuff a zero byte? */
+       emit_byte(state, 0, return FALSE);
+     }
+     put_buffer <<= 8;
+     put_bits -= 8;
+   }
+ 
+   state->cur.put_buffer = put_buffer; /* update state variables */
+   state->cur.put_bits = put_bits;
+ 
+   return TRUE;
+ }
+ 
+ 
+ LOCAL(boolean)
+ flush_bits (working_state * state)
+ {
+   if (! emit_bits(state, 0x7F, 7)) /* fill any partial byte with ones */
+     return FALSE;
+   state->cur.put_buffer = 0;	/* and reset bit-buffer to empty */
+   state->cur.put_bits = 0;
+   return TRUE;
+ }
+ 
+ 
+ /* Encode a single block's worth of coefficients */
+ 
+ LOCAL(boolean)
+ encode_one_block (working_state * state, JCOEFPTR block, int last_dc_val,
+ 		  c_derived_tbl *dctbl, c_derived_tbl *actbl)
+ {
+   register int temp, temp2;
+   register int nbits;
+   register int k, r, i;
+   
+   /* Encode the DC coefficient difference per section F.1.2.1 */
+   
+   temp = temp2 = block[0] - last_dc_val;
+ 
+   if (temp < 0) {
+     temp = -temp;		/* temp is abs value of input */
+     /* For a negative input, want temp2 = bitwise complement of abs(input) */
+     /* This code assumes we are on a two's complement machine */
+     temp2--;
+   }
+   
+   /* Find the number of bits needed for the magnitude of the coefficient */
+   nbits = 0;
+   while (temp) {
+     nbits++;
+     temp >>= 1;
+   }
+   /* Check for out-of-range coefficient values.
+    * Since we're encoding a difference, the range limit is twice as much.
+    */
+   if (nbits > MAX_COEF_BITS+1)
+     ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);
+   
+   /* Emit the Huffman-coded symbol for the number of bits */
+   if (! emit_bits(state, dctbl->ehufco[nbits], dctbl->ehufsi[nbits]))
+     return FALSE;
+ 
+   /* Emit that number of bits of the value, if positive, */
+   /* or the complement of its magnitude, if negative. */
+   if (nbits)			/* emit_bits rejects calls with size 0 */
+     if (! emit_bits(state, (unsigned int) temp2, nbits))
+       return FALSE;
+ 
+   /* Encode the AC coefficients per section F.1.2.2 */
+   
+   r = 0;			/* r = run length of zeros */
+   
+   for (k = 1; k < DCTSIZE2; k++) {
+     if ((temp = block[jpeg_natural_order[k]]) == 0) {
+       r++;
+     } else {
+       /* if run length > 15, must emit special run-length-16 codes (0xF0) */
+       while (r > 15) {
+ 	if (! emit_bits(state, actbl->ehufco[0xF0], actbl->ehufsi[0xF0]))
+ 	  return FALSE;
+ 	r -= 16;
+       }
+ 
+       temp2 = temp;
+       if (temp < 0) {
+ 	temp = -temp;		/* temp is abs value of input */
+ 	/* This code assumes we are on a two's complement machine */
+ 	temp2--;
+       }
+       
+       /* Find the number of bits needed for the magnitude of the coefficient */
+       nbits = 1;		/* there must be at least one 1 bit */
+       while ((temp >>= 1))
+ 	nbits++;
+       /* Check for out-of-range coefficient values */
+       if (nbits > MAX_COEF_BITS)
+ 	ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);
+       
+       /* Emit Huffman symbol for run length / number of bits */
+       i = (r << 4) + nbits;
+       if (! emit_bits(state, actbl->ehufco[i], actbl->ehufsi[i]))
+ 	return FALSE;
+ 
+       /* Emit that number of bits of the value, if positive, */
+       /* or the complement of its magnitude, if negative. */
+       if (! emit_bits(state, (unsigned int) temp2, nbits))
+ 	return FALSE;
+       
+       r = 0;
+     }
+   }
+ 
+   /* If the last coef(s) were zero, emit an end-of-block code */
+   if (r > 0)
+     if (! emit_bits(state, actbl->ehufco[0], actbl->ehufsi[0]))
+       return FALSE;
+ 
+   return TRUE;
+ }
+ 
+ 
+ /*
+  * Emit a restart marker & resynchronize predictions.
+  */
+ 
+ LOCAL(boolean)
+ emit_restart (working_state * state, int restart_num)
+ {
+   int ci;
+ 
+   if (! flush_bits(state))
+     return FALSE;
+ 
+   emit_byte(state, 0xFF, return FALSE);
+   emit_byte(state, JPEG_RST0 + restart_num, return FALSE);
+ 
+   /* Re-initialize DC predictions to 0 */
+   for (ci = 0; ci < state->cinfo->comps_in_scan; ci++)
+     state->cur.last_dc_val[ci] = 0;
+ 
+   /* The restart counter is not updated until we successfully write the MCU. */
+ 
+   return TRUE;
+ }
+ 
+ 
+ /*
+  * Encode and output one MCU's worth of Huffman-compressed coefficients.
+  */
+ 
+ METHODDEF(boolean)
+ encode_mcu_huff (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
+ {
+   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
+   shuff_entropy_ptr entropy = (shuff_entropy_ptr) lossyc->entropy_private;
+   working_state state;
+   int blkn, ci;
+   jpeg_component_info * compptr;
+ 
+   /* Load up working state */
+   state.next_output_byte = cinfo->dest->next_output_byte;
+   state.free_in_buffer = cinfo->dest->free_in_buffer;
+   ASSIGN_STATE(state.cur, entropy->saved);
+   state.cinfo = cinfo;
+ 
+   /* Emit restart marker if needed */
+   if (cinfo->restart_interval) {
+     if (entropy->restarts_to_go == 0)
+       if (! emit_restart(&state, entropy->next_restart_num))
+ 	return FALSE;
+   }
+ 
+   /* Encode the MCU data blocks */
+   for (blkn = 0; blkn < cinfo->data_units_in_MCU; blkn++) {
+     ci = cinfo->MCU_membership[blkn];
+     compptr = cinfo->cur_comp_info[ci];
+     if (! encode_one_block(&state,
+ 			   MCU_data[blkn][0], state.cur.last_dc_val[ci],
+ 			   entropy->dc_derived_tbls[compptr->dc_tbl_no],
+ 			   entropy->ac_derived_tbls[compptr->ac_tbl_no]))
+       return FALSE;
+     /* Update last_dc_val */
+     state.cur.last_dc_val[ci] = MCU_data[blkn][0][0];
+   }
+ 
+   /* Completed MCU, so update state */
+   cinfo->dest->next_output_byte = state.next_output_byte;
+   cinfo->dest->free_in_buffer = state.free_in_buffer;
+   ASSIGN_STATE(entropy->saved, state.cur);
+ 
+   /* Update restart-interval state too */
+   if (cinfo->restart_interval) {
+     if (entropy->restarts_to_go == 0) {
+       entropy->restarts_to_go = cinfo->restart_interval;
+       entropy->next_restart_num++;
+       entropy->next_restart_num &= 7;
+     }
+     entropy->restarts_to_go--;
+   }
+ 
+   return TRUE;
+ }
+ 
+ 
+ /*
+  * Finish up at the end of a Huffman-compressed scan.
+  */
+ 
+ METHODDEF(void)
+ finish_pass_huff (j_compress_ptr cinfo)
+ {
+   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
+   shuff_entropy_ptr entropy = (shuff_entropy_ptr) lossyc->entropy_private;
+   working_state state;
+ 
+   /* Load up working state ... flush_bits needs it */
+   state.next_output_byte = cinfo->dest->next_output_byte;
+   state.free_in_buffer = cinfo->dest->free_in_buffer;
+   ASSIGN_STATE(state.cur, entropy->saved);
+   state.cinfo = cinfo;
+ 
+   /* Flush out the last data */
+   if (! flush_bits(&state))
+     ERREXIT(cinfo, JERR_CANT_SUSPEND);
+ 
+   /* Update state */
+   cinfo->dest->next_output_byte = state.next_output_byte;
+   cinfo->dest->free_in_buffer = state.free_in_buffer;
+   ASSIGN_STATE(entropy->saved, state.cur);
+ }
+ 
+ 
+ /*
+  * Huffman coding optimization.
+  *
+  * We first scan the supplied data and count the number of uses of each symbol
+  * that is to be Huffman-coded. (This process MUST agree with the code above.)
+  * Then we build a Huffman coding tree for the observed counts.
+  * Symbols which are not needed at all for the particular image are not
+  * assigned any code, which saves space in the DHT marker as well as in
+  * the compressed data.
+  */
+ 
+ #ifdef ENTROPY_OPT_SUPPORTED
+ 
+ 
+ /* Process a single block's worth of coefficients */
+ 
+ LOCAL(void)
+ htest_one_block (j_compress_ptr cinfo, JCOEFPTR block, int last_dc_val,
+ 		 long dc_counts[], long ac_counts[])
+ {
+   register int temp;
+   register int nbits;
+   register int k, r;
+   
+   /* Encode the DC coefficient difference per section F.1.2.1 */
+   
+   temp = block[0] - last_dc_val;
+   if (temp < 0)
+     temp = -temp;
+   
+   /* Find the number of bits needed for the magnitude of the coefficient */
+   nbits = 0;
+   while (temp) {
+     nbits++;
+     temp >>= 1;
+   }
+   /* Check for out-of-range coefficient values.
+    * Since we're encoding a difference, the range limit is twice as much.
+    */
+   if (nbits > MAX_COEF_BITS+1)
+     ERREXIT(cinfo, JERR_BAD_DCT_COEF);
+ 
+   /* Count the Huffman symbol for the number of bits */
+   dc_counts[nbits]++;
+   
+   /* Encode the AC coefficients per section F.1.2.2 */
+   
+   r = 0;			/* r = run length of zeros */
+   
+   for (k = 1; k < DCTSIZE2; k++) {
+     if ((temp = block[jpeg_natural_order[k]]) == 0) {
+       r++;
+     } else {
+       /* if run length > 15, must emit special run-length-16 codes (0xF0) */
+       while (r > 15) {
+ 	ac_counts[0xF0]++;
+ 	r -= 16;
+       }
+       
+       /* Find the number of bits needed for the magnitude of the coefficient */
+       if (temp < 0)
+ 	temp = -temp;
+       
+       /* Find the number of bits needed for the magnitude of the coefficient */
+       nbits = 1;		/* there must be at least one 1 bit */
+       while ((temp >>= 1))
+ 	nbits++;
+       /* Check for out-of-range coefficient values */
+       if (nbits > MAX_COEF_BITS)
+ 	ERREXIT(cinfo, JERR_BAD_DCT_COEF);
+       
+       /* Count Huffman symbol for run length / number of bits */
+       ac_counts[(r << 4) + nbits]++;
+       
+       r = 0;
+     }
+   }
+ 
+   /* If the last coef(s) were zero, emit an end-of-block code */
+   if (r > 0)
+     ac_counts[0]++;
+ }
+ 
+ 
+ /*
+  * Trial-encode one MCU's worth of Huffman-compressed coefficients.
+  * No data is actually output, so no suspension return is possible.
+  */
+ 
+ METHODDEF(boolean)
+ encode_mcu_gather (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
+ {
+   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
+   shuff_entropy_ptr entropy = (shuff_entropy_ptr) lossyc->entropy_private;
+   int blkn, ci;
+   jpeg_component_info * compptr;
+ 
+   /* Take care of restart intervals if needed */
+   if (cinfo->restart_interval) {
+     if (entropy->restarts_to_go == 0) {
+       /* Re-initialize DC predictions to 0 */
+       for (ci = 0; ci < cinfo->comps_in_scan; ci++)
+ 	entropy->saved.last_dc_val[ci] = 0;
+       /* Update restart state */
+       entropy->restarts_to_go = cinfo->restart_interval;
+     }
+     entropy->restarts_to_go--;
+   }
+ 
+   for (blkn = 0; blkn < cinfo->data_units_in_MCU; blkn++) {
+     ci = cinfo->MCU_membership[blkn];
+     compptr = cinfo->cur_comp_info[ci];
+     htest_one_block(cinfo, MCU_data[blkn][0], entropy->saved.last_dc_val[ci],
+ 		    entropy->dc_count_ptrs[compptr->dc_tbl_no],
+ 		    entropy->ac_count_ptrs[compptr->ac_tbl_no]);
+     entropy->saved.last_dc_val[ci] = MCU_data[blkn][0][0];
+   }
+ 
+   return TRUE;
+ }
+ 
+ 
+ /*
+  * Finish up a statistics-gathering pass and create the new Huffman tables.
+  */
+ 
+ METHODDEF(void)
+ finish_pass_gather (j_compress_ptr cinfo)
+ {
+   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
+   shuff_entropy_ptr entropy = (shuff_entropy_ptr) lossyc->entropy_private;
+   int ci, dctbl, actbl;
+   jpeg_component_info * compptr;
+   JHUFF_TBL **htblptr;
+   boolean did_dc[NUM_HUFF_TBLS];
+   boolean did_ac[NUM_HUFF_TBLS];
+ 
+   /* It's important not to apply jpeg_gen_optimal_table more than once
+    * per table, because it clobbers the input frequency counts!
+    */
+   MEMZERO(did_dc, SIZEOF(did_dc));
+   MEMZERO(did_ac, SIZEOF(did_ac));
+ 
+   for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
+     compptr = cinfo->cur_comp_info[ci];
+     dctbl = compptr->dc_tbl_no;
+     actbl = compptr->ac_tbl_no;
+     if (! did_dc[dctbl]) {
+       htblptr = & cinfo->dc_huff_tbl_ptrs[dctbl];
+       if (*htblptr == NULL)
+ 	*htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
+       jpeg_gen_optimal_table(cinfo, *htblptr, entropy->dc_count_ptrs[dctbl]);
+       did_dc[dctbl] = TRUE;
+     }
+     if (! did_ac[actbl]) {
+       htblptr = & cinfo->ac_huff_tbl_ptrs[actbl];
+       if (*htblptr == NULL)
+ 	*htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
+       jpeg_gen_optimal_table(cinfo, *htblptr, entropy->ac_count_ptrs[actbl]);
+       did_ac[actbl] = TRUE;
+     }
+   }
+ }
+ 
+ 
+ #endif /* ENTROPY_OPT_SUPPORTED */
+ 
+ 
+ METHODDEF(boolean)
+ need_optimization_pass (j_compress_ptr cinfo)
+ {
+   return TRUE;
+ }
+ 
+ 
+ /*
+  * Module initialization routine for Huffman entropy encoding.
+  */
+ 
+ GLOBAL(void)
+ jinit_shuff_encoder (j_compress_ptr cinfo)
+ {
+   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
+   shuff_entropy_ptr entropy;
+   int i;
+ 
+   entropy = (shuff_entropy_ptr)
+     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
+ 				SIZEOF(shuff_entropy_encoder));
+   lossyc->entropy_private = (struct jpeg_entropy_encoder *) entropy;
+   lossyc->pub.entropy_start_pass = start_pass_huff;
+   lossyc->pub.need_optimization_pass = need_optimization_pass;
+ 
+   /* Mark tables unallocated */
+   for (i = 0; i < NUM_HUFF_TBLS; i++) {
+     entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
+ #ifdef ENTROPY_OPT_SUPPORTED
+     entropy->dc_count_ptrs[i] = entropy->ac_count_ptrs[i] = NULL;
+ #endif
+   }
+ }
diff -cN ../jpeg-6b/jctrans.c ./jctrans.c
*** ../jpeg-6b/jctrans.c	Sat Feb 21 15:03:25 1998
--- ./jctrans.c	Tue Apr 27 14:58:21 1999
***************
*** 13,23 ****
--- 13,26 ----
  #define JPEG_INTERNALS
  #include "jinclude.h"
  #include "jpeglib.h"
+ #include "jlossy.h"		/* Private declarations for lossy codec */
  
  
  /* Forward declarations */
  LOCAL(void) transencode_master_selection
  	JPP((j_compress_ptr cinfo, jvirt_barray_ptr * coef_arrays));
+ LOCAL(void) transencode_codec
+ 	JPP((j_compress_ptr cinfo, jvirt_barray_ptr * coef_arrays));
  LOCAL(void) transencode_coef_controller
  	JPP((j_compress_ptr cinfo, jvirt_barray_ptr * coef_arrays));
  
***************
*** 158,163 ****
--- 161,167 ----
  transencode_master_selection (j_compress_ptr cinfo,
  			      jvirt_barray_ptr * coef_arrays)
  {
+   cinfo->data_unit = DCTSIZE;
    /* Although we don't actually use input_components for transcoding,
     * jcmaster.c's initial_setup will complain if input_components is 0.
     */
***************
*** 165,186 ****
    /* Initialize master control (includes parameter checking/processing) */
    jinit_c_master_control(cinfo, TRUE /* transcode only */);
  
!   /* Entropy encoding: either Huffman or arithmetic coding. */
!   if (cinfo->arith_code) {
!     ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
!   } else {
!     if (cinfo->progressive_mode) {
! #ifdef C_PROGRESSIVE_SUPPORTED
!       jinit_phuff_encoder(cinfo);
! #else
!       ERREXIT(cinfo, JERR_NOT_COMPILED);
! #endif
!     } else
!       jinit_huff_encoder(cinfo);
!   }
! 
!   /* We need a special coefficient buffer controller. */
!   transencode_coef_controller(cinfo, coef_arrays);
  
    jinit_marker_writer(cinfo);
  
--- 169,176 ----
    /* Initialize master control (includes parameter checking/processing) */
    jinit_c_master_control(cinfo, TRUE /* transcode only */);
  
!   /* We need a special compression codec. */
!   transencode_codec(cinfo, coef_arrays);
  
    jinit_marker_writer(cinfo);
  
***************
*** 206,213 ****
  /* Private buffer controller object */
  
  typedef struct {
-   struct jpeg_c_coef_controller pub; /* public fields */
- 
    JDIMENSION iMCU_row_num;	/* iMCU row # within image */
    JDIMENSION mcu_ctr;		/* counts MCUs processed in current row */
    int MCU_vert_offset;		/* counts MCU rows within iMCU row */
--- 196,201 ----
***************
*** 217,226 ****
    jvirt_barray_ptr * whole_image;
  
    /* Workspace for constructing dummy blocks at right/bottom edges. */
!   JBLOCKROW dummy_buffer[C_MAX_BLOCKS_IN_MCU];
! } my_coef_controller;
  
! typedef my_coef_controller * my_coef_ptr;
  
  
  LOCAL(void)
--- 205,214 ----
    jvirt_barray_ptr * whole_image;
  
    /* Workspace for constructing dummy blocks at right/bottom edges. */
!   JBLOCKROW dummy_buffer[C_MAX_DATA_UNITS_IN_MCU];
! } c_coef_controller;
  
! typedef c_coef_controller * c_coef_ptr;
  
  
  LOCAL(void)
***************
*** 227,233 ****
  start_iMCU_row (j_compress_ptr cinfo)
  /* Reset within-iMCU-row counters for a new row */
  {
!   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  
    /* In an interleaved scan, an MCU row is the same as an iMCU row.
     * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
--- 215,222 ----
  start_iMCU_row (j_compress_ptr cinfo)
  /* Reset within-iMCU-row counters for a new row */
  {
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   c_coef_ptr coef = (c_coef_ptr) lossyc->coef_private;
  
    /* In an interleaved scan, an MCU row is the same as an iMCU row.
     * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
***************
*** 254,260 ****
  METHODDEF(void)
  start_pass_coef (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
  {
!   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  
    if (pass_mode != JBUF_CRANK_DEST)
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
--- 243,250 ----
  METHODDEF(void)
  start_pass_coef (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
  {
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   c_coef_ptr coef = (c_coef_ptr) lossyc->coef_private;
  
    if (pass_mode != JBUF_CRANK_DEST)
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
***************
*** 277,283 ****
  METHODDEF(boolean)
  compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
  {
!   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
    JDIMENSION MCU_col_num;	/* index of current MCU within row */
    JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
    JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
--- 267,274 ----
  METHODDEF(boolean)
  compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
  {
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   c_coef_ptr coef = (c_coef_ptr) lossyc->coef_private;
    JDIMENSION MCU_col_num;	/* index of current MCU within row */
    JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
    JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
***************
*** 284,290 ****
    int blkn, ci, xindex, yindex, yoffset, blockcnt;
    JDIMENSION start_col;
    JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
!   JBLOCKROW MCU_buffer[C_MAX_BLOCKS_IN_MCU];
    JBLOCKROW buffer_ptr;
    jpeg_component_info *compptr;
  
--- 275,281 ----
    int blkn, ci, xindex, yindex, yoffset, blockcnt;
    JDIMENSION start_col;
    JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
!   JBLOCKROW MCU_buffer[C_MAX_DATA_UNITS_IN_MCU];
    JBLOCKROW buffer_ptr;
    jpeg_component_info *compptr;
  
***************
*** 334,340 ****
  	}
        }
        /* Try to write the MCU. */
!       if (! (*cinfo->entropy->encode_mcu) (cinfo, MCU_buffer)) {
  	/* Suspension forced; update state counters and exit */
  	coef->MCU_vert_offset = yoffset;
  	coef->mcu_ctr = MCU_col_num;
--- 325,331 ----
  	}
        }
        /* Try to write the MCU. */
!       if (! (*lossyc->entropy_encode_mcu) (cinfo, MCU_buffer)) {
  	/* Suspension forced; update state counters and exit */
  	coef->MCU_vert_offset = yoffset;
  	coef->mcu_ctr = MCU_col_num;
***************
*** 355,361 ****
   * Initialize coefficient buffer controller.
   *
   * Each passed coefficient array must be the right size for that
!  * coefficient: width_in_blocks wide and height_in_blocks high,
   * with unitheight at least v_samp_factor.
   */
  
--- 346,352 ----
   * Initialize coefficient buffer controller.
   *
   * Each passed coefficient array must be the right size for that
!  * coefficient: width_in_data_units wide and height_in_data_units high,
   * with unitheight at least v_samp_factor.
   */
  
***************
*** 363,378 ****
  transencode_coef_controller (j_compress_ptr cinfo,
  			     jvirt_barray_ptr * coef_arrays)
  {
!   my_coef_ptr coef;
    JBLOCKROW buffer;
    int i;
  
!   coef = (my_coef_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				SIZEOF(my_coef_controller));
!   cinfo->coef = (struct jpeg_c_coef_controller *) coef;
!   coef->pub.start_pass = start_pass_coef;
!   coef->pub.compress_data = compress_output;
  
    /* Save pointer to virtual arrays */
    coef->whole_image = coef_arrays;
--- 354,368 ----
  transencode_coef_controller (j_compress_ptr cinfo,
  			     jvirt_barray_ptr * coef_arrays)
  {
!   j_lossy_c_ptr lossyc = (j_lossy_c_ptr) cinfo->codec;
!   c_coef_ptr coef;
    JBLOCKROW buffer;
    int i;
  
!   coef = (c_coef_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				SIZEOF(c_coef_controller));
!   lossyc->coef_private = (struct jpeg_c_coef_controller *) coef;
  
    /* Save pointer to virtual arrays */
    coef->whole_image = coef_arrays;
***************
*** 380,388 ****
    /* Allocate and pre-zero space for dummy DCT blocks. */
    buffer = (JBLOCKROW)
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				C_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
!   jzero_far((void FAR *) buffer, C_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
!   for (i = 0; i < C_MAX_BLOCKS_IN_MCU; i++) {
      coef->dummy_buffer[i] = buffer + i;
    }
  }
--- 370,420 ----
    /* Allocate and pre-zero space for dummy DCT blocks. */
    buffer = (JBLOCKROW)
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				C_MAX_DATA_UNITS_IN_MCU * SIZEOF(JBLOCK));
!   jzero_far((void FAR *) buffer, C_MAX_DATA_UNITS_IN_MCU * SIZEOF(JBLOCK));
!   for (i = 0; i < C_MAX_DATA_UNITS_IN_MCU; i++) {
      coef->dummy_buffer[i] = buffer + i;
    }
+ }
+ 
+ 
+ /*
+  * Initialize the transencoer codec.
+  * This is called only once, during master selection.
+  */
+ 
+ LOCAL(void)
+ transencode_codec (j_compress_ptr cinfo,
+ 		   jvirt_barray_ptr * coef_arrays)
+ {
+   j_lossy_c_ptr lossyc;
+ 
+   /* Create subobject in permanent pool */
+   lossyc = (j_lossy_c_ptr)
+     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
+ 				SIZEOF(jpeg_lossy_c_codec));
+   cinfo->codec = (struct jpeg_c_codec *) lossyc;
+ 
+   /* Initialize sub-modules */
+ 
+   /* Entropy encoding: either Huffman or arithmetic coding. */
+   if (cinfo->arith_code) {
+     ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
+   } else {
+     if (cinfo->process == JPROC_PROGRESSIVE) {
+ #ifdef C_PROGRESSIVE_SUPPORTED
+       jinit_phuff_encoder(cinfo);
+ #else
+       ERREXIT(cinfo, JERR_NOT_COMPILED);
+ #endif
+     } else
+       jinit_shuff_encoder(cinfo);
+   }
+ 
+   /* We need a special coefficient buffer controller. */
+   transencode_coef_controller(cinfo, coef_arrays);
+ 
+   /* Initialize method pointers */
+   lossyc->pub.start_pass = start_pass_coef;
+   lossyc->pub.compress_data = compress_output;
  }
diff -cN ../jpeg-6b/jdapimin.c ./jdapimin.c
*** ../jpeg-6b/jdapimin.c	Sat Jan 24 16:22:44 1998
--- ./jdapimin.c	Tue Apr 27 14:58:21 1999
***************
*** 149,156 ****
        else if (cid0 == 82 && cid1 == 71 && cid2 == 66)
  	cinfo->jpeg_color_space = JCS_RGB; /* ASCII 'R', 'G', 'B' */
        else {
! 	TRACEMS3(cinfo, 1, JTRC_UNKNOWN_IDS, cid0, cid1, cid2);
! 	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
        }
      }
      /* Always guess RGB is proper output colorspace. */
--- 149,162 ----
        else if (cid0 == 82 && cid1 == 71 && cid2 == 66)
  	cinfo->jpeg_color_space = JCS_RGB; /* ASCII 'R', 'G', 'B' */
        else {
! 	if (cinfo->process == JPROC_LOSSLESS) {
! 	  TRACEMS3(cinfo, 1, JTRC_UNKNOWN_LOSSLESS_IDS, cid0, cid1, cid2);
! 	  cinfo->jpeg_color_space = JCS_RGB; /* assume it's RGB */
! 	}
! 	else {  /* Lossy processes */
! 	  TRACEMS3(cinfo, 1, JTRC_UNKNOWN_LOSSY_IDS, cid0, cid1, cid2);
! 	  cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
! 	}
        }
      }
      /* Always guess RGB is proper output colorspace. */
diff -cN ../jpeg-6b/jdapistd.c ./jdapistd.c
*** ../jpeg-6b/jdapistd.c	Sat Jan  6 18:26:28 1996
--- ./jdapistd.c	Tue Apr 27 14:58:22 1999
***************
*** 1,7 ****
  /*
   * jdapistd.c
   *
!  * Copyright (C) 1994-1996, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jdapistd.c
   *
!  * Copyright (C) 1994-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 202,213 ****
    }
  
    /* Verify that at least one iMCU row can be returned. */
!   lines_per_iMCU_row = cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size;
    if (max_lines < lines_per_iMCU_row)
      ERREXIT(cinfo, JERR_BUFFER_SIZE);
  
    /* Decompress directly into user's buffer. */
!   if (! (*cinfo->coef->decompress_data) (cinfo, data))
      return 0;			/* suspension forced, can do nothing more */
  
    /* OK, we processed one iMCU row. */
--- 202,213 ----
    }
  
    /* Verify that at least one iMCU row can be returned. */
!   lines_per_iMCU_row = cinfo->max_v_samp_factor * cinfo->min_codec_data_unit;
    if (max_lines < lines_per_iMCU_row)
      ERREXIT(cinfo, JERR_BUFFER_SIZE);
  
    /* Decompress directly into user's buffer. */
!   if (! (*cinfo->codec->decompress_data) (cinfo, data))
      return 0;			/* suspension forced, can do nothing more */
  
    /* OK, we processed one iMCU row. */
diff -cN ../jpeg-6b/jdcoefct.c ./jdcoefct.c
*** ../jpeg-6b/jdcoefct.c	Mon Oct 27 22:12:10 1997
--- ./jdcoefct.c	Tue Apr 27 14:58:22 1999
***************
*** 1,12 ****
  /*
   * jdcoefct.c
   *
!  * Copyright (C) 1994-1997, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
   * This file contains the coefficient buffer controller for decompression.
!  * This controller is the top level of the JPEG decompressor proper.
   * The coefficient buffer lies between entropy decoding and inverse-DCT steps.
   *
   * In buffered-image mode, this controller is the interface between
--- 1,12 ----
  /*
   * jdcoefct.c
   *
!  * Copyright (C) 1994-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
   * This file contains the coefficient buffer controller for decompression.
!  * This controller is the top level of the lossy JPEG decompressor proper.
   * The coefficient buffer lies between entropy decoding and inverse-DCT steps.
   *
   * In buffered-image mode, this controller is the interface between
***************
*** 17,22 ****
--- 17,23 ----
  #define JPEG_INTERNALS
  #include "jinclude.h"
  #include "jpeglib.h"
+ #include "jlossy.h"
  
  /* Block smoothing is only applicable for progressive JPEG, so: */
  #ifndef D_PROGRESSIVE_SUPPORTED
***************
*** 26,33 ****
  /* Private buffer controller object */
  
  typedef struct {
-   struct jpeg_d_coef_controller pub; /* public fields */
- 
    /* These variables keep track of the current location of the input side. */
    /* cinfo->input_iMCU_row is also used for this. */
    JDIMENSION MCU_ctr;		/* counts MCUs processed in current row */
--- 27,32 ----
***************
*** 37,43 ****
    /* The output side's location is represented by cinfo->output_iMCU_row. */
  
    /* In single-pass modes, it's sufficient to buffer just one MCU.
!    * We allocate a workspace of D_MAX_BLOCKS_IN_MCU coefficient blocks,
     * and let the entropy decoder write into that workspace each time.
     * (On 80x86, the workspace is FAR even though it's not really very big;
     * this is to keep the module interfaces unchanged when a large coefficient
--- 36,42 ----
    /* The output side's location is represented by cinfo->output_iMCU_row. */
  
    /* In single-pass modes, it's sufficient to buffer just one MCU.
!    * We allocate a workspace of D_MAX_DATA_UNITS_IN_MCU coefficient blocks,
     * and let the entropy decoder write into that workspace each time.
     * (On 80x86, the workspace is FAR even though it's not really very big;
     * this is to keep the module interfaces unchanged when a large coefficient
***************
*** 45,51 ****
     * In multi-pass modes, this array points to the current MCU's blocks
     * within the virtual arrays; it is used only by the input side.
     */
!   JBLOCKROW MCU_buffer[D_MAX_BLOCKS_IN_MCU];
  
  #ifdef D_MULTISCAN_FILES_SUPPORTED
    /* In multi-pass modes, we need a virtual block array for each component. */
--- 44,50 ----
     * In multi-pass modes, this array points to the current MCU's blocks
     * within the virtual arrays; it is used only by the input side.
     */
!   JBLOCKROW MCU_buffer[D_MAX_DATA_UNITS_IN_MCU];
  
  #ifdef D_MULTISCAN_FILES_SUPPORTED
    /* In multi-pass modes, we need a virtual block array for each component. */
***************
*** 57,65 ****
    int * coef_bits_latch;
  #define SAVED_COEFS  6		/* we save coef_bits[0..5] */
  #endif
! } my_coef_controller;
  
! typedef my_coef_controller * my_coef_ptr;
  
  /* Forward declarations */
  METHODDEF(int) decompress_onepass
--- 56,64 ----
    int * coef_bits_latch;
  #define SAVED_COEFS  6		/* we save coef_bits[0..5] */
  #endif
! } d_coef_controller;
  
! typedef d_coef_controller * d_coef_ptr;
  
  /* Forward declarations */
  METHODDEF(int) decompress_onepass
***************
*** 79,85 ****
  start_iMCU_row (j_decompress_ptr cinfo)
  /* Reset within-iMCU-row counters for a new row (input side) */
  {
!   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  
    /* In an interleaved scan, an MCU row is the same as an iMCU row.
     * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
--- 78,85 ----
  start_iMCU_row (j_decompress_ptr cinfo)
  /* Reset within-iMCU-row counters for a new row (input side) */
  {
!   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
!   d_coef_ptr coef = (d_coef_ptr) lossyd->coef_private;
  
    /* In an interleaved scan, an MCU row is the same as an iMCU row.
     * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
***************
*** 119,132 ****
  start_output_pass (j_decompress_ptr cinfo)
  {
  #ifdef BLOCK_SMOOTHING_SUPPORTED
!   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  
    /* If multipass, check to see whether to use block smoothing on this pass */
!   if (coef->pub.coef_arrays != NULL) {
      if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
!       coef->pub.decompress_data = decompress_smooth_data;
      else
!       coef->pub.decompress_data = decompress_data;
    }
  #endif
    cinfo->output_iMCU_row = 0;
--- 119,133 ----
  start_output_pass (j_decompress_ptr cinfo)
  {
  #ifdef BLOCK_SMOOTHING_SUPPORTED
!   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
!   d_coef_ptr coef = (d_coef_ptr) lossyd->coef_private;
  
    /* If multipass, check to see whether to use block smoothing on this pass */
!   if (lossyd->coef_arrays != NULL) {
      if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
!       lossyd->pub.decompress_data = decompress_smooth_data;
      else
!       lossyd->pub.decompress_data = decompress_data;
    }
  #endif
    cinfo->output_iMCU_row = 0;
***************
*** 146,152 ****
  METHODDEF(int)
  decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
  {
!   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
    JDIMENSION MCU_col_num;	/* index of current MCU within row */
    JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
    JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
--- 147,154 ----
  METHODDEF(int)
  decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
  {
!   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
!   d_coef_ptr coef = (d_coef_ptr) lossyd->coef_private;
    JDIMENSION MCU_col_num;	/* index of current MCU within row */
    JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
    JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
***************
*** 163,170 ****
  	 MCU_col_num++) {
        /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
        jzero_far((void FAR *) coef->MCU_buffer[0],
! 		(size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
!       if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
  	/* Suspension forced; update state counters and exit */
  	coef->MCU_vert_offset = yoffset;
  	coef->MCU_ctr = MCU_col_num;
--- 165,172 ----
  	 MCU_col_num++) {
        /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
        jzero_far((void FAR *) coef->MCU_buffer[0],
! 		(size_t) (cinfo->data_units_in_MCU * SIZEOF(JBLOCK)));
!       if (! (*lossyd->entropy_decode_mcu) (cinfo, coef->MCU_buffer)) {
  	/* Suspension forced; update state counters and exit */
  	coef->MCU_vert_offset = yoffset;
  	coef->MCU_ctr = MCU_col_num;
***************
*** 180,193 ****
  	compptr = cinfo->cur_comp_info[ci];
  	/* Don't bother to IDCT an uninteresting component. */
  	if (! compptr->component_needed) {
! 	  blkn += compptr->MCU_blocks;
  	  continue;
  	}
! 	inverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];
  	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
  						    : compptr->last_col_width;
  	output_ptr = output_buf[compptr->component_index] +
! 	  yoffset * compptr->DCT_scaled_size;
  	start_col = MCU_col_num * compptr->MCU_sample_width;
  	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
  	  if (cinfo->input_iMCU_row < last_iMCU_row ||
--- 182,195 ----
  	compptr = cinfo->cur_comp_info[ci];
  	/* Don't bother to IDCT an uninteresting component. */
  	if (! compptr->component_needed) {
! 	  blkn += compptr->MCU_data_units;
  	  continue;
  	}
! 	inverse_DCT = lossyd->inverse_DCT[compptr->component_index];
  	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
  						    : compptr->last_col_width;
  	output_ptr = output_buf[compptr->component_index] +
! 	  yoffset * compptr->codec_data_unit;
  	start_col = MCU_col_num * compptr->MCU_sample_width;
  	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
  	  if (cinfo->input_iMCU_row < last_iMCU_row ||
***************
*** 197,207 ****
  	      (*inverse_DCT) (cinfo, compptr,
  			      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],
  			      output_ptr, output_col);
! 	      output_col += compptr->DCT_scaled_size;
  	    }
  	  }
  	  blkn += compptr->MCU_width;
! 	  output_ptr += compptr->DCT_scaled_size;
  	}
        }
      }
--- 199,209 ----
  	      (*inverse_DCT) (cinfo, compptr,
  			      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],
  			      output_ptr, output_col);
! 	      output_col += compptr->codec_data_unit;
  	    }
  	  }
  	  blkn += compptr->MCU_width;
! 	  output_ptr += compptr->codec_data_unit;
  	}
        }
      }
***************
*** 243,249 ****
  METHODDEF(int)
  consume_data (j_decompress_ptr cinfo)
  {
!   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
    JDIMENSION MCU_col_num;	/* index of current MCU within row */
    int blkn, ci, xindex, yindex, yoffset;
    JDIMENSION start_col;
--- 245,252 ----
  METHODDEF(int)
  consume_data (j_decompress_ptr cinfo)
  {
!   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
!   d_coef_ptr coef = (d_coef_ptr) lossyd->coef_private;
    JDIMENSION MCU_col_num;	/* index of current MCU within row */
    int blkn, ci, xindex, yindex, yoffset;
    JDIMENSION start_col;
***************
*** 282,288 ****
  	}
        }
        /* Try to fetch the MCU. */
!       if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
  	/* Suspension forced; update state counters and exit */
  	coef->MCU_vert_offset = yoffset;
  	coef->MCU_ctr = MCU_col_num;
--- 285,291 ----
  	}
        }
        /* Try to fetch the MCU. */
!       if (! (*lossyd->entropy_decode_mcu) (cinfo, coef->MCU_buffer)) {
  	/* Suspension forced; update state counters and exit */
  	coef->MCU_vert_offset = yoffset;
  	coef->MCU_ctr = MCU_col_num;
***************
*** 314,320 ****
  METHODDEF(int)
  decompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
  {
!   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
    JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
    JDIMENSION block_num;
    int ci, block_row, block_rows;
--- 317,324 ----
  METHODDEF(int)
  decompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
  {
!   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
!   d_coef_ptr coef = (d_coef_ptr) lossyd->coef_private;
    JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
    JDIMENSION block_num;
    int ci, block_row, block_rows;
***************
*** 349,370 ****
        block_rows = compptr->v_samp_factor;
      else {
        /* NB: can't use last_row_height here; it is input-side-dependent! */
!       block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
        if (block_rows == 0) block_rows = compptr->v_samp_factor;
      }
!     inverse_DCT = cinfo->idct->inverse_DCT[ci];
      output_ptr = output_buf[ci];
      /* Loop over all DCT blocks to be processed. */
      for (block_row = 0; block_row < block_rows; block_row++) {
        buffer_ptr = buffer[block_row];
        output_col = 0;
!       for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
  	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,
  			output_ptr, output_col);
  	buffer_ptr++;
! 	output_col += compptr->DCT_scaled_size;
        }
!       output_ptr += compptr->DCT_scaled_size;
      }
    }
  
--- 353,374 ----
        block_rows = compptr->v_samp_factor;
      else {
        /* NB: can't use last_row_height here; it is input-side-dependent! */
!       block_rows = (int) (compptr->height_in_data_units % compptr->v_samp_factor);
        if (block_rows == 0) block_rows = compptr->v_samp_factor;
      }
!     inverse_DCT = lossyd->inverse_DCT[ci];
      output_ptr = output_buf[ci];
      /* Loop over all DCT blocks to be processed. */
      for (block_row = 0; block_row < block_rows; block_row++) {
        buffer_ptr = buffer[block_row];
        output_col = 0;
!       for (block_num = 0; block_num < compptr->width_in_data_units; block_num++) {
  	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,
  			output_ptr, output_col);
  	buffer_ptr++;
! 	output_col += compptr->codec_data_unit;
        }
!       output_ptr += compptr->codec_data_unit;
      }
    }
  
***************
*** 404,410 ****
  LOCAL(boolean)
  smoothing_ok (j_decompress_ptr cinfo)
  {
!   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
    boolean smoothing_useful = FALSE;
    int ci, coefi;
    jpeg_component_info *compptr;
--- 408,415 ----
  LOCAL(boolean)
  smoothing_ok (j_decompress_ptr cinfo)
  {
!   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
!   d_coef_ptr coef = (d_coef_ptr) lossyd->coef_private;
    boolean smoothing_useful = FALSE;
    int ci, coefi;
    jpeg_component_info *compptr;
***************
*** 412,418 ****
    int * coef_bits;
    int * coef_bits_latch;
  
!   if (! cinfo->progressive_mode || cinfo->coef_bits == NULL)
      return FALSE;
  
    /* Allocate latch area if not already done */
--- 417,423 ----
    int * coef_bits;
    int * coef_bits_latch;
  
!   if (! cinfo->process == JPROC_PROGRESSIVE || cinfo->coef_bits == NULL)
      return FALSE;
  
    /* Allocate latch area if not already done */
***************
*** 460,466 ****
  METHODDEF(int)
  decompress_smooth_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
  {
!   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
    JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
    JDIMENSION block_num, last_block_column;
    int ci, block_row, block_rows, access_rows;
--- 465,472 ----
  METHODDEF(int)
  decompress_smooth_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
  {
!   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
!   d_coef_ptr coef = (d_coef_ptr) lossyd->coef_private;
    JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
    JDIMENSION block_num, last_block_column;
    int ci, block_row, block_rows, access_rows;
***************
*** 508,514 ****
        last_row = FALSE;
      } else {
        /* NB: can't use last_row_height here; it is input-side-dependent! */
!       block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
        if (block_rows == 0) block_rows = compptr->v_samp_factor;
        access_rows = block_rows; /* this iMCU row only */
        last_row = TRUE;
--- 514,520 ----
        last_row = FALSE;
      } else {
        /* NB: can't use last_row_height here; it is input-side-dependent! */
!       block_rows = (int) (compptr->height_in_data_units % compptr->v_samp_factor);
        if (block_rows == 0) block_rows = compptr->v_samp_factor;
        access_rows = block_rows; /* this iMCU row only */
        last_row = TRUE;
***************
*** 537,543 ****
      Q20 = quanttbl->quantval[Q20_POS];
      Q11 = quanttbl->quantval[Q11_POS];
      Q02 = quanttbl->quantval[Q02_POS];
!     inverse_DCT = cinfo->idct->inverse_DCT[ci];
      output_ptr = output_buf[ci];
      /* Loop over all DCT blocks to be processed. */
      for (block_row = 0; block_row < block_rows; block_row++) {
--- 543,549 ----
      Q20 = quanttbl->quantval[Q20_POS];
      Q11 = quanttbl->quantval[Q11_POS];
      Q02 = quanttbl->quantval[Q02_POS];
!     inverse_DCT = lossyd->inverse_DCT[ci];
      output_ptr = output_buf[ci];
      /* Loop over all DCT blocks to be processed. */
      for (block_row = 0; block_row < block_rows; block_row++) {
***************
*** 557,563 ****
        DC4 = DC5 = DC6 = (int) buffer_ptr[0][0];
        DC7 = DC8 = DC9 = (int) next_block_row[0][0];
        output_col = 0;
!       last_block_column = compptr->width_in_blocks - 1;
        for (block_num = 0; block_num <= last_block_column; block_num++) {
  	/* Fetch current DCT block into workspace so we can modify it. */
  	jcopy_block_row(buffer_ptr, (JBLOCKROW) workspace, (JDIMENSION) 1);
--- 563,569 ----
        DC4 = DC5 = DC6 = (int) buffer_ptr[0][0];
        DC7 = DC8 = DC9 = (int) next_block_row[0][0];
        output_col = 0;
!       last_block_column = compptr->width_in_data_units - 1;
        for (block_num = 0; block_num <= last_block_column; block_num++) {
  	/* Fetch current DCT block into workspace so we can modify it. */
  	jcopy_block_row(buffer_ptr, (JBLOCKROW) workspace, (JDIMENSION) 1);
***************
*** 654,662 ****
  	DC4 = DC5; DC5 = DC6;
  	DC7 = DC8; DC8 = DC9;
  	buffer_ptr++, prev_block_row++, next_block_row++;
! 	output_col += compptr->DCT_scaled_size;
        }
!       output_ptr += compptr->DCT_scaled_size;
      }
    }
  
--- 660,668 ----
  	DC4 = DC5; DC5 = DC6;
  	DC7 = DC8; DC8 = DC9;
  	buffer_ptr++, prev_block_row++, next_block_row++;
! 	output_col += compptr->codec_data_unit;
        }
!       output_ptr += compptr->codec_data_unit;
      }
    }
  
***************
*** 675,688 ****
  GLOBAL(void)
  jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
  {
!   my_coef_ptr coef;
  
!   coef = (my_coef_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				SIZEOF(my_coef_controller));
!   cinfo->coef = (struct jpeg_d_coef_controller *) coef;
!   coef->pub.start_input_pass = start_input_pass;
!   coef->pub.start_output_pass = start_output_pass;
  #ifdef BLOCK_SMOOTHING_SUPPORTED
    coef->coef_bits_latch = NULL;
  #endif
--- 681,695 ----
  GLOBAL(void)
  jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
  {
!   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
!   d_coef_ptr coef;
  
!   coef = (d_coef_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				SIZEOF(d_coef_controller));
!   lossyd->coef_private = (void *) coef;
!   lossyd->coef_start_input_pass = start_input_pass;
!   lossyd->coef_start_output_pass = start_output_pass;
  #ifdef BLOCK_SMOOTHING_SUPPORTED
    coef->coef_bits_latch = NULL;
  #endif
***************
*** 701,720 ****
        access_rows = compptr->v_samp_factor;
  #ifdef BLOCK_SMOOTHING_SUPPORTED
        /* If block smoothing could be used, need a bigger window */
!       if (cinfo->progressive_mode)
  	access_rows *= 3;
  #endif
        coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
  	((j_common_ptr) cinfo, JPOOL_IMAGE, TRUE,
! 	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
  				(long) compptr->h_samp_factor),
! 	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
  				(long) compptr->v_samp_factor),
  	 (JDIMENSION) access_rows);
      }
!     coef->pub.consume_data = consume_data;
!     coef->pub.decompress_data = decompress_data;
!     coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */
  #else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
  #endif
--- 708,727 ----
        access_rows = compptr->v_samp_factor;
  #ifdef BLOCK_SMOOTHING_SUPPORTED
        /* If block smoothing could be used, need a bigger window */
!       if (cinfo->process == JPROC_PROGRESSIVE)
  	access_rows *= 3;
  #endif
        coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
  	((j_common_ptr) cinfo, JPOOL_IMAGE, TRUE,
! 	 (JDIMENSION) jround_up((long) compptr->width_in_data_units,
  				(long) compptr->h_samp_factor),
! 	 (JDIMENSION) jround_up((long) compptr->height_in_data_units,
  				(long) compptr->v_samp_factor),
  	 (JDIMENSION) access_rows);
      }
!     lossyd->pub.consume_data = consume_data;
!     lossyd->pub.decompress_data = decompress_data;
!     lossyd->coef_arrays = coef->whole_image; /* link to virtual arrays */
  #else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
  #endif
***************
*** 725,736 ****
  
      buffer = (JBLOCKROW)
        (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				  D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
!     for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {
        coef->MCU_buffer[i] = buffer + i;
      }
!     coef->pub.consume_data = dummy_consume_data;
!     coef->pub.decompress_data = decompress_onepass;
!     coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
    }
  }
--- 732,743 ----
  
      buffer = (JBLOCKROW)
        (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				  D_MAX_DATA_UNITS_IN_MCU * SIZEOF(JBLOCK));
!     for (i = 0; i < D_MAX_DATA_UNITS_IN_MCU; i++) {
        coef->MCU_buffer[i] = buffer + i;
      }
!     lossyd->pub.consume_data = dummy_consume_data;
!     lossyd->pub.decompress_data = decompress_onepass;
!     lossyd->coef_arrays = NULL; /* flag for no virtual arrays */
    }
  }
diff -cN ../jpeg-6b/jddctmgr.c ./jddctmgr.c
*** ../jpeg-6b/jddctmgr.c	Sat Jan 13 14:38:21 1996
--- ./jddctmgr.c	Tue Apr 27 14:58:22 1999
***************
*** 1,7 ****
  /*
   * jddctmgr.c
   *
!  * Copyright (C) 1994-1996, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jddctmgr.c
   *
!  * Copyright (C) 1994-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 18,23 ****
--- 18,24 ----
  #define JPEG_INTERNALS
  #include "jinclude.h"
  #include "jpeglib.h"
+ #include "jlossy.h"		/* Private declarations for lossy subsystem */
  #include "jdct.h"		/* Private declarations for DCT subsystem */
  
  
***************
*** 41,48 ****
  /* Private subobject for this module */
  
  typedef struct {
-   struct jpeg_inverse_dct pub;	/* public fields */
- 
    /* This array contains the IDCT method code that each multiplier table
     * is currently set up for, or -1 if it's not yet set up.
     * The actual multiplier tables are pointed to by dct_table in the
--- 42,47 ----
***************
*** 49,57 ****
     * per-component comp_info structures.
     */
    int cur_method[MAX_COMPONENTS];
! } my_idct_controller;
  
! typedef my_idct_controller * my_idct_ptr;
  
  
  /* Allocated multiplier tables: big enough for any supported variant */
--- 48,56 ----
     * per-component comp_info structures.
     */
    int cur_method[MAX_COMPONENTS];
! } idct_controller;
  
! typedef idct_controller * idct_ptr;
  
  
  /* Allocated multiplier tables: big enough for any supported variant */
***************
*** 88,94 ****
  METHODDEF(void)
  start_pass (j_decompress_ptr cinfo)
  {
!   my_idct_ptr idct = (my_idct_ptr) cinfo->idct;
    int ci, i;
    jpeg_component_info *compptr;
    int method = 0;
--- 87,94 ----
  METHODDEF(void)
  start_pass (j_decompress_ptr cinfo)
  {
!   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
!   idct_ptr idct = (idct_ptr) lossyd->idct_private;
    int ci, i;
    jpeg_component_info *compptr;
    int method = 0;
***************
*** 98,104 ****
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
         ci++, compptr++) {
      /* Select the proper IDCT routine for this component's scaling */
!     switch (compptr->DCT_scaled_size) {
  #ifdef IDCT_SCALING_SUPPORTED
      case 1:
        method_ptr = jpeg_idct_1x1;
--- 98,104 ----
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
         ci++, compptr++) {
      /* Select the proper IDCT routine for this component's scaling */
!     switch (compptr->codec_data_unit) {
  #ifdef IDCT_SCALING_SUPPORTED
      case 1:
        method_ptr = jpeg_idct_1x1;
***************
*** 139,148 ****
        }
        break;
      default:
!       ERREXIT1(cinfo, JERR_BAD_DCTSIZE, compptr->DCT_scaled_size);
        break;
      }
!     idct->pub.inverse_DCT[ci] = method_ptr;
      /* Create multiplier table from quant table.
       * However, we can skip this if the component is uninteresting
       * or if we already built the table.  Also, if no quant table
--- 139,148 ----
        }
        break;
      default:
!       ERREXIT1(cinfo, JERR_BAD_DCTSIZE, compptr->codec_data_unit);
        break;
      }
!     lossyd->inverse_DCT[ci] = method_ptr;
      /* Create multiplier table from quant table.
       * However, we can skip this if the component is uninteresting
       * or if we already built the table.  Also, if no quant table
***************
*** 246,260 ****
  GLOBAL(void)
  jinit_inverse_dct (j_decompress_ptr cinfo)
  {
!   my_idct_ptr idct;
    int ci;
    jpeg_component_info *compptr;
  
!   idct = (my_idct_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				SIZEOF(my_idct_controller));
!   cinfo->idct = (struct jpeg_inverse_dct *) idct;
!   idct->pub.start_pass = start_pass;
  
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
         ci++, compptr++) {
--- 246,261 ----
  GLOBAL(void)
  jinit_inverse_dct (j_decompress_ptr cinfo)
  {
!   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
!   idct_ptr idct;
    int ci;
    jpeg_component_info *compptr;
  
!   idct = (idct_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
! 				SIZEOF(idct_controller));
!   lossyd->idct_private = (void *) idct;
!   lossyd->idct_start_pass = start_pass;
  
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
         ci++, compptr++) {
diff -cN ../jpeg-6b/jddiffct.c ./jddiffct.c
*** ../jpeg-6b/jddiffct.c
--- ./jddiffct.c	Tue Apr 27 14:58:23 1999
***************
*** 0 ****
--- 1,398 ----
+ /*
+  * jddiffct.c
+  *
+  * Copyright (C) 1994-1998, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+  * This file contains the [un]difference buffer controller for decompression.
+  * This controller is the top level of the lossless JPEG decompressor proper.
+  * The difference buffer lies between the entropy decoding and
+  * prediction/undifferencing steps.  The undifference buffer lies between the
+  * prediction/undifferencing and scaling steps.
+  *
+  * In buffered-image mode, this controller is the interface between
+  * input-oriented processing and output-oriented processing.
+  */
+ 
+ #define JPEG_INTERNALS
+ #include "jinclude.h"
+ #include "jpeglib.h"
+ #include "jlossls.h"
+ 
+ 
+ #ifdef D_LOSSLESS_SUPPORTED
+ 
+ /* Private buffer controller object */
+ 
+ typedef struct {
+   /* These variables keep track of the current location of the input side. */
+   /* cinfo->input_iMCU_row is also used for this. */
+   JDIMENSION MCU_ctr;		/* counts MCUs processed in current row */
+   unsigned int restart_rows_to_go;	/* MCU-rows left in this restart interval */
+   unsigned int MCU_vert_offset;		/* counts MCU rows within iMCU row */
+   unsigned int MCU_rows_per_iMCU_row;	/* number of such rows needed */
+ 
+   /* The output side's location is represented by cinfo->output_iMCU_row. */
+ 
+   JDIFFARRAY diff_buf[MAX_COMPONENTS];	/* iMCU row of differences */
+   JDIFFARRAY undiff_buf[MAX_COMPONENTS]; /* iMCU row of undiff'd samples */
+ 
+ #ifdef D_MULTISCAN_FILES_SUPPORTED
+   /* In multi-pass modes, we need a virtual sample array for each component. */
+   jvirt_sarray_ptr whole_image[MAX_COMPONENTS];
+ #endif
+ } d_diff_controller;
+ 
+ typedef d_diff_controller * d_diff_ptr;
+ 
+ /* Forward declarations */
+ METHODDEF(int) decompress_data
+ 	JPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));
+ #ifdef D_MULTISCAN_FILES_SUPPORTED
+ METHODDEF(int) output_data
+ 	JPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));
+ #endif
+ 
+ 
+ LOCAL(void)
+ start_iMCU_row (j_decompress_ptr cinfo)
+ /* Reset within-iMCU-row counters for a new row (input side) */
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+   d_diff_ptr diff = (d_diff_ptr) losslsd->diff_private;
+ 
+   /* In an interleaved scan, an MCU row is the same as an iMCU row.
+    * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
+    * But at the bottom of the image, process only what's left.
+    */
+   if (cinfo->comps_in_scan > 1) {
+     diff->MCU_rows_per_iMCU_row = 1;
+   } else {
+     if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))
+       diff->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
+     else
+       diff->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
+   }
+ 
+   diff->MCU_ctr = 0;
+   diff->MCU_vert_offset = 0;
+ }
+ 
+ 
+ /*
+  * Initialize for an input processing pass.
+  */
+ 
+ METHODDEF(void)
+ start_input_pass (j_decompress_ptr cinfo)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+   d_diff_ptr diff = (d_diff_ptr) losslsd->diff_private;
+ 
+   /* Check that the restart interval is an integer multiple of the number 
+    * of MCU in an MCU-row.
+    */
+   if (cinfo->restart_interval % cinfo->MCUs_per_row != 0)
+     ERREXIT2(cinfo, JERR_BAD_RESTART,
+ 	     cinfo->restart_interval, cinfo->MCUs_per_row);
+ 
+   /* Initialize restart counter */
+   diff->restart_rows_to_go = cinfo->restart_interval / cinfo->MCUs_per_row;
+ 
+   cinfo->input_iMCU_row = 0;
+   start_iMCU_row(cinfo);
+ }
+ 
+ 
+ /*
+  * Check for a restart marker & resynchronize decoder, undifferencer.
+  * Returns FALSE if must suspend.
+  */
+ 
+ METHODDEF(boolean)
+ process_restart (j_decompress_ptr cinfo)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+   d_diff_ptr diff = (d_diff_ptr) losslsd->diff_private;
+ 
+   if (! (*losslsd->entropy_process_restart) (cinfo))
+     return FALSE;
+ 
+   (*losslsd->predict_process_restart) (cinfo);
+ 
+   /* Reset restart counter */
+   diff->restart_rows_to_go = cinfo->restart_interval / cinfo->MCUs_per_row;
+ 
+   return TRUE;
+ }
+ 
+ 
+ /*
+  * Initialize for an output processing pass.
+  */
+ 
+ METHODDEF(void)
+ start_output_pass (j_decompress_ptr cinfo)
+ {
+   cinfo->output_iMCU_row = 0;
+ }
+ 
+ 
+ /*
+  * Decompress and return some data in the supplied buffer.
+  * Always attempts to emit one fully interleaved MCU row ("iMCU" row).
+  * Input and output must run in lockstep since we have only a one-MCU buffer.
+  * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
+  *
+  * NB: output_buf contains a plane for each component in image,
+  * which we index according to the component's SOF position.
+  */
+ 
+ METHODDEF(int)
+ decompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+   d_diff_ptr diff = (d_diff_ptr) losslsd->diff_private;
+   JDIMENSION MCU_col_num;	/* index of current MCU within row */
+   JDIMENSION MCU_count;		/* number of MCUs decoded */
+   JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
+   int comp, ci, yoffset, row, prev_row;
+   jpeg_component_info *compptr;
+ 
+   /* Loop to process as much as one whole iMCU row */
+   for (yoffset = diff->MCU_vert_offset; yoffset < diff->MCU_rows_per_iMCU_row;
+        yoffset++) {
+ 
+     /* Process restart marker if needed; may have to suspend */
+     if (cinfo->restart_interval) {
+       if (diff->restart_rows_to_go == 0)
+ 	if (! process_restart(cinfo))
+ 	  return JPEG_SUSPENDED;
+     }
+ 
+     MCU_col_num = diff->MCU_ctr;
+     /* Try to fetch an MCU-row (or remaining portion of suspended MCU-row). */
+     MCU_count =
+       (*losslsd->entropy_decode_mcus) (cinfo,
+ 				       diff->diff_buf, yoffset, MCU_col_num,
+ 				       cinfo->MCUs_per_row - MCU_col_num);
+     if (MCU_count != cinfo->MCUs_per_row - MCU_col_num) {
+       /* Suspension forced; update state counters and exit */
+       diff->MCU_vert_offset = yoffset;
+       diff->MCU_ctr += MCU_count;
+       return JPEG_SUSPENDED;
+     }
+ 
+     /* Account for restart interval (no-op if not using restarts) */
+     diff->restart_rows_to_go--;
+ 
+     /* Completed an MCU row, but perhaps not an iMCU row */
+     diff->MCU_ctr = 0;
+   }
+ 
+   /*
+    * Undifference and scale each scanline of the disassembled MCU-row
+    * separately.  We do not process dummy samples at the end of a scanline
+    * or dummy rows at the end of the image.
+    */
+   for (comp = 0; comp < cinfo->comps_in_scan; comp++) {
+     compptr = cinfo->cur_comp_info[comp];
+     ci = compptr->component_index;
+     for (row = 0, prev_row = compptr->v_samp_factor - 1;
+ 	 row < (cinfo->input_iMCU_row == last_iMCU_row ?
+ 		compptr->last_row_height : compptr->v_samp_factor);
+ 	 prev_row = row, row++) {
+       (*losslsd->predict_undifference[ci]) (cinfo, ci,
+ 					    diff->diff_buf[ci][row],
+ 					    diff->undiff_buf[ci][prev_row],
+ 					    diff->undiff_buf[ci][row],
+ 					    compptr->width_in_data_units);
+       (*losslsd->scaler_scale) (cinfo, diff->undiff_buf[ci][row],
+ 				output_buf[ci][row],
+ 				compptr->width_in_data_units);
+     }
+   }
+ 
+   /* Completed the iMCU row, advance counters for next one.
+    *
+    * NB: output_data will increment output_iMCU_row.
+    * This counter is not needed for the single-pass case
+    * or the input side of the multi-pass case.
+    */
+   if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
+     start_iMCU_row(cinfo);
+     return JPEG_ROW_COMPLETED;
+   }
+   /* Completed the scan */
+   (*cinfo->inputctl->finish_input_pass) (cinfo);
+   return JPEG_SCAN_COMPLETED;
+ }
+ 
+ 
+ /*
+  * Dummy consume-input routine for single-pass operation.
+  */
+ 
+ METHODDEF(int)
+ dummy_consume_data (j_decompress_ptr cinfo)
+ {
+   return JPEG_SUSPENDED;	/* Always indicate nothing was done */
+ }
+ 
+ 
+ #ifdef D_MULTISCAN_FILES_SUPPORTED
+ 
+ /*
+  * Consume input data and store it in the full-image sample buffer.
+  * We read as much as one fully interleaved MCU row ("iMCU" row) per call,
+  * ie, v_samp_factor rows for each component in the scan.
+  * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
+  */
+ 
+ METHODDEF(int)
+ consume_data (j_decompress_ptr cinfo)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+   d_diff_ptr diff = (d_diff_ptr) losslsd->diff_private;
+   JDIMENSION MCU_col_num;	/* index of current MCU within row */
+   JDIMENSION MCU_count;		/* number of MCUs decoded */
+   JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
+   int comp, ci, yoffset, row, prev_row;
+   JSAMPARRAY buffer[MAX_COMPS_IN_SCAN];
+   jpeg_component_info *compptr;
+ 
+   /* Align the virtual buffers for the components used in this scan. */
+   for (comp = 0; comp < cinfo->comps_in_scan; comp++) {
+     compptr = cinfo->cur_comp_info[comp];
+     ci = compptr->component_index;
+     buffer[ci] = (*cinfo->mem->access_virt_sarray)
+       ((j_common_ptr) cinfo, diff->whole_image[ci],
+        cinfo->input_iMCU_row * compptr->v_samp_factor,
+        (JDIMENSION) compptr->v_samp_factor, TRUE);
+   }
+ 
+   return decompress_data(cinfo, buffer);
+ }
+ 
+ 
+ /*
+  * Output some data from the full-image buffer sample in the multi-pass case.
+  * Always attempts to emit one fully interleaved MCU row ("iMCU" row).
+  * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
+  *
+  * NB: output_buf contains a plane for each component in image.
+  */
+ 
+ METHODDEF(int)
+ output_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+   d_diff_ptr diff = (d_diff_ptr) losslsd->diff_private;
+   JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
+   int ci, samp_rows, row;
+   JSAMPARRAY buffer;
+   jpeg_component_info *compptr;
+ 
+   /* Force some input to be done if we are getting ahead of the input. */
+   while (cinfo->input_scan_number < cinfo->output_scan_number ||
+ 	 (cinfo->input_scan_number == cinfo->output_scan_number &&
+ 	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
+     if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
+       return JPEG_SUSPENDED;
+   }
+ 
+   /* OK, output from the virtual arrays. */
+   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
+        ci++, compptr++) {
+     /* Align the virtual buffer for this component. */
+     buffer = (*cinfo->mem->access_virt_sarray)
+       ((j_common_ptr) cinfo, diff->whole_image[ci],
+        cinfo->output_iMCU_row * compptr->v_samp_factor,
+        (JDIMENSION) compptr->v_samp_factor, FALSE);
+ 
+     if (cinfo->output_iMCU_row < last_iMCU_row)
+       samp_rows = compptr->v_samp_factor;
+     else {
+       /* NB: can't use last_row_height here; it is input-side-dependent! */
+       samp_rows = (int) (compptr->height_in_data_units % compptr->v_samp_factor);
+       if (samp_rows == 0) samp_rows = compptr->v_samp_factor;
+     }
+ 
+     for (row = 0; row < samp_rows; row++) {
+       MEMCOPY(output_buf[ci][row], buffer[row],
+ 	      compptr->width_in_data_units * SIZEOF(JSAMPLE));
+     }
+   }
+ 
+   if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
+     return JPEG_ROW_COMPLETED;
+   return JPEG_SCAN_COMPLETED;
+ }
+ 
+ #endif /* D_MULTISCAN_FILES_SUPPORTED */
+ 
+ 
+ /*
+  * Initialize difference buffer controller.
+  */
+ 
+ GLOBAL(void)
+ jinit_d_diff_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+   d_diff_ptr diff;
+   int ci;
+   jpeg_component_info *compptr;
+ 
+   diff = (d_diff_ptr)
+     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
+ 				SIZEOF(d_diff_controller));
+   losslsd->diff_private = (void *) diff;
+   losslsd->diff_start_input_pass = start_input_pass;
+   losslsd->pub.start_output_pass = start_output_pass;
+ 
+   /* Create the [un]difference buffers. */
+   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
+        ci++, compptr++) {
+     diff->diff_buf[ci] = (*cinfo->mem->alloc_darray)
+       ((j_common_ptr) cinfo, JPOOL_IMAGE,
+        (JDIMENSION) jround_up((long) compptr->width_in_data_units,
+ 			      (long) compptr->h_samp_factor),
+        (JDIMENSION) compptr->v_samp_factor);
+     diff->undiff_buf[ci] = (*cinfo->mem->alloc_darray)
+       ((j_common_ptr) cinfo, JPOOL_IMAGE,
+        (JDIMENSION) jround_up((long) compptr->width_in_data_units,
+ 			      (long) compptr->h_samp_factor),
+        (JDIMENSION) compptr->v_samp_factor);
+   }
+ 
+   if (need_full_buffer) {
+ #ifdef D_MULTISCAN_FILES_SUPPORTED
+     /* Allocate a full-image virtual array for each component. */
+     int access_rows;
+ 
+     for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
+ 	 ci++, compptr++) {
+       access_rows = compptr->v_samp_factor;
+       diff->whole_image[ci] = (*cinfo->mem->request_virt_sarray)
+ 	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
+ 	 (JDIMENSION) jround_up((long) compptr->width_in_data_units,
+ 				(long) compptr->h_samp_factor),
+ 	 (JDIMENSION) jround_up((long) compptr->height_in_data_units,
+ 				(long) compptr->v_samp_factor),
+ 	 (JDIMENSION) access_rows);
+     }
+     losslsd->pub.consume_data = consume_data;
+     losslsd->pub.decompress_data = output_data;
+ #else
+     ERREXIT(cinfo, JERR_NOT_COMPILED);
+ #endif
+   } else {
+     losslsd->pub.consume_data = dummy_consume_data;
+     losslsd->pub.decompress_data = decompress_data;
+     diff->whole_image[0] = NULL; /* flag for no virtual arrays */
+   }
+ }
+ 
+ #endif /* D_LOSSLESS_SUPPORTED */
diff -cN ../jpeg-6b/jdhuff.c ./jdhuff.c
*** ../jpeg-6b/jdhuff.c	Mon Oct 20 20:51:10 1997
--- ./jdhuff.c	Tue Apr 27 14:58:23 1999
***************
*** 1,148 ****
  /*
   * jdhuff.c
   *
!  * Copyright (C) 1991-1997, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
!  * This file contains Huffman entropy decoding routines.
!  *
!  * Much of the complexity here has to do with supporting input suspension.
!  * If the data source module demands suspension, we want to be able to back
!  * up to the start of the current MCU.  To do this, we copy state variables
!  * into local working storage, and update them back to the permanent
!  * storage only upon successful completion of an MCU.
   */
  
  #define JPEG_INTERNALS
  #include "jinclude.h"
  #include "jpeglib.h"
! #include "jdhuff.h"		/* Declarations shared with jdphuff.c */
! 
! 
! /*
!  * Expanded entropy decoder object for Huffman decoding.
!  *
!  * The savable_state subrecord contains fields that change within an MCU,
!  * but must not be updated permanently until we complete the MCU.
!  */
! 
! typedef struct {
!   int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */
! } savable_state;
! 
! /* This macro is to work around compilers with missing or broken
!  * structure assignment.  You'll need to fix this code if you have
!  * such a compiler and you change MAX_COMPS_IN_SCAN.
!  */
! 
! #ifndef NO_STRUCT_ASSIGN
! #define ASSIGN_STATE(dest,src)  ((dest) = (src))
! #else
! #if MAX_COMPS_IN_SCAN == 4
! #define ASSIGN_STATE(dest,src)  \
! 	((dest).last_dc_val[0] = (src).last_dc_val[0], \
! 	 (dest).last_dc_val[1] = (src).last_dc_val[1], \
! 	 (dest).last_dc_val[2] = (src).last_dc_val[2], \
! 	 (dest).last_dc_val[3] = (src).last_dc_val[3])
! #endif
! #endif
! 
! 
! typedef struct {
!   struct jpeg_entropy_decoder pub; /* public fields */
! 
!   /* These fields are loaded into local variables at start of each MCU.
!    * In case of suspension, we exit WITHOUT updating them.
!    */
!   bitread_perm_state bitstate;	/* Bit buffer at start of MCU */
!   savable_state saved;		/* Other state at start of MCU */
! 
!   /* These fields are NOT loaded into local working state. */
!   unsigned int restarts_to_go;	/* MCUs left in this restart interval */
! 
!   /* Pointers to derived tables (these workspaces have image lifespan) */
!   d_derived_tbl * dc_derived_tbls[NUM_HUFF_TBLS];
!   d_derived_tbl * ac_derived_tbls[NUM_HUFF_TBLS];
! 
!   /* Precalculated info set up by start_pass for use in decode_mcu: */
! 
!   /* Pointers to derived tables to be used for each block within an MCU */
!   d_derived_tbl * dc_cur_tbls[D_MAX_BLOCKS_IN_MCU];
!   d_derived_tbl * ac_cur_tbls[D_MAX_BLOCKS_IN_MCU];
!   /* Whether we care about the DC and AC coefficient values for each block */
!   boolean dc_needed[D_MAX_BLOCKS_IN_MCU];
!   boolean ac_needed[D_MAX_BLOCKS_IN_MCU];
! } huff_entropy_decoder;
! 
! typedef huff_entropy_decoder * huff_entropy_ptr;
! 
! 
! /*
!  * Initialize for a Huffman-compressed scan.
!  */
! 
! METHODDEF(void)
! start_pass_huff_decoder (j_decompress_ptr cinfo)
! {
!   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
!   int ci, blkn, dctbl, actbl;
!   jpeg_component_info * compptr;
! 
!   /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
!    * This ought to be an error condition, but we make it a warning because
!    * there are some baseline files out there with all zeroes in these bytes.
!    */
!   if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2-1 ||
!       cinfo->Ah != 0 || cinfo->Al != 0)
!     WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);
! 
!   for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
!     compptr = cinfo->cur_comp_info[ci];
!     dctbl = compptr->dc_tbl_no;
!     actbl = compptr->ac_tbl_no;
!     /* Compute derived values for Huffman tables */
!     /* We may do this more than once for a table, but it's not expensive */
!     jpeg_make_d_derived_tbl(cinfo, TRUE, dctbl,
! 			    & entropy->dc_derived_tbls[dctbl]);
!     jpeg_make_d_derived_tbl(cinfo, FALSE, actbl,
! 			    & entropy->ac_derived_tbls[actbl]);
!     /* Initialize DC predictions to 0 */
!     entropy->saved.last_dc_val[ci] = 0;
!   }
! 
!   /* Precalculate decoding info for each block in an MCU of this scan */
!   for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
!     ci = cinfo->MCU_membership[blkn];
!     compptr = cinfo->cur_comp_info[ci];
!     /* Precalculate which table to use for each block */
!     entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
!     entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
!     /* Decide whether we really care about the coefficient values */
!     if (compptr->component_needed) {
!       entropy->dc_needed[blkn] = TRUE;
!       /* we don't need the ACs if producing a 1/8th-size image */
!       entropy->ac_needed[blkn] = (compptr->DCT_scaled_size > 1);
!     } else {
!       entropy->dc_needed[blkn] = entropy->ac_needed[blkn] = FALSE;
!     }
!   }
! 
!   /* Initialize bitread state variables */
!   entropy->bitstate.bits_left = 0;
!   entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
!   entropy->pub.insufficient_data = FALSE;
  
-   /* Initialize restart counter */
-   entropy->restarts_to_go = cinfo->restart_interval;
- }
- 
  
  /*
   * Compute the derived values for a Huffman table.
   * This routine also performs some validation checks on the table.
-  *
-  * Note this is also used by jdphuff.c.
   */
  
  GLOBAL(void)
--- 1,25 ----
  /*
   * jdhuff.c
   *
!  * Copyright (C) 1991-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
!  * This file contains Huffman entropy decoding routines which are shared
!  * by the sequential, progressive and lossless decoders.
   */
  
  #define JPEG_INTERNALS
  #include "jinclude.h"
  #include "jpeglib.h"
! #include "jlossy.h"		/* Private declarations for lossy codec */
! #include "jlossls.h"		/* Private declarations for lossless codec */
! #include "jdhuff.h"		/* Declarations shared with jd*huff.c */
  
  
  /*
   * Compute the derived values for a Huffman table.
   * This routine also performs some validation checks on the table.
   */
  
  GLOBAL(void)
***************
*** 252,258 ****
  
    /* Validate symbols as being reasonable.
     * For AC tables, we make no check, but accept all byte values 0..255.
!    * For DC tables, we require the symbols to be in range 0..15.
     * (Tighter bounds could be applied depending on the data depth and mode,
     * but this is sufficient to ensure safe decoding.)
     */
--- 129,135 ----
  
    /* Validate symbols as being reasonable.
     * For AC tables, we make no check, but accept all byte values 0..255.
!    * For DC tables, we require the symbols to be in range 0..16.
     * (Tighter bounds could be applied depending on the data depth and mode,
     * but this is sufficient to ensure safe decoding.)
     */
***************
*** 259,265 ****
    if (isDC) {
      for (i = 0; i < numsymbols; i++) {
        int sym = htbl->huffval[i];
!       if (sym < 0 || sym > 15)
  	ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
      }
    }
--- 136,142 ----
    if (isDC) {
      for (i = 0; i < numsymbols; i++) {
        int sym = htbl->huffval[i];
!       if (sym < 0 || sym > 16)
  	ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
      }
    }
***************
*** 267,273 ****
  
  
  /*
!  * Out-of-line code for bit fetching (shared with jdphuff.c).
   * See jdhuff.h for info about usage.
   * Note: current values of get_buffer and bits_left are passed as parameters,
   * but are returned in the corresponding fields of the state struct.
--- 144,150 ----
  
  
  /*
!  * Out-of-line code for bit fetching.
   * See jdhuff.h for info about usage.
   * Note: current values of get_buffer and bits_left are passed as parameters,
   * but are returned in the corresponding fields of the state struct.
***************
*** 369,377 ****
         * We use a nonvolatile flag to ensure that only one warning message
         * appears per data segment.
         */
!       if (! cinfo->entropy->insufficient_data) {
  	WARNMS(cinfo, JWRN_HIT_MARKER);
! 	cinfo->entropy->insufficient_data = TRUE;
        }
        /* Fill the buffer with zero bits */
        get_buffer <<= MIN_GET_BITS - bits_left;
--- 246,259 ----
         * We use a nonvolatile flag to ensure that only one warning message
         * appears per data segment.
         */
!       huffd_common_ptr huffd;
!       if (cinfo->process == JPROC_LOSSLESS)
! 	huffd = (huffd_common_ptr) ((j_lossless_d_ptr) cinfo->codec)->entropy_private;
!       else
! 	huffd = (huffd_common_ptr) ((j_lossy_d_ptr) cinfo->codec)->entropy_private;
!       if (! huffd->insufficient_data) {
  	WARNMS(cinfo, JWRN_HIT_MARKER);
! 	huffd->insufficient_data = TRUE;
        }
        /* Fill the buffer with zero bits */
        get_buffer <<= MIN_GET_BITS - bits_left;
***************
*** 430,651 ****
    }
  
    return htbl->pub->huffval[ (int) (code + htbl->valoffset[l]) ];
- }
- 
- 
- /*
-  * Figure F.12: extend sign bit.
-  * On some machines, a shift and add will be faster than a table lookup.
-  */
- 
- #ifdef AVOID_TABLES
- 
- #define HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) + (((-1)<<(s)) + 1) : (x))
- 
- #else
- 
- #define HUFF_EXTEND(x,s)  ((x) < extend_test[s] ? (x) + extend_offset[s] : (x))
- 
- static const int extend_test[16] =   /* entry n is 2**(n-1) */
-   { 0, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
-     0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000 };
- 
- static const int extend_offset[16] = /* entry n is (-1 << n) + 1 */
-   { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
-     ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
-     ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
-     ((-1)<<13) + 1, ((-1)<<14) + 1, ((-1)<<15) + 1 };
- 
- #endif /* AVOID_TABLES */
- 
- 
- /*
-  * Check for a restart marker & resynchronize decoder.
-  * Returns FALSE if must suspend.
-  */
- 
- LOCAL(boolean)
- process_restart (j_decompress_ptr cinfo)
- {
-   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
-   int ci;
- 
-   /* Throw away any unused bits remaining in bit buffer; */
-   /* include any full bytes in next_marker's count of discarded bytes */
-   cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
-   entropy->bitstate.bits_left = 0;
- 
-   /* Advance past the RSTn marker */
-   if (! (*cinfo->marker->read_restart_marker) (cinfo))
-     return FALSE;
- 
-   /* Re-initialize DC predictions to 0 */
-   for (ci = 0; ci < cinfo->comps_in_scan; ci++)
-     entropy->saved.last_dc_val[ci] = 0;
- 
-   /* Reset restart counter */
-   entropy->restarts_to_go = cinfo->restart_interval;
- 
-   /* Reset out-of-data flag, unless read_restart_marker left us smack up
-    * against a marker.  In that case we will end up treating the next data
-    * segment as empty, and we can avoid producing bogus output pixels by
-    * leaving the flag set.
-    */
-   if (cinfo->unread_marker == 0)
-     entropy->pub.insufficient_data = FALSE;
- 
-   return TRUE;
- }
- 
- 
- /*
-  * Decode and return one MCU's worth of Huffman-compressed coefficients.
-  * The coefficients are reordered from zigzag order into natural array order,
-  * but are not dequantized.
-  *
-  * The i'th block of the MCU is stored into the block pointed to by
-  * MCU_data[i].  WE ASSUME THIS AREA HAS BEEN ZEROED BY THE CALLER.
-  * (Wholesale zeroing is usually a little faster than retail...)
-  *
-  * Returns FALSE if data source requested suspension.  In that case no
-  * changes have been made to permanent state.  (Exception: some output
-  * coefficients may already have been assigned.  This is harmless for
-  * this module, since we'll just re-assign them on the next call.)
-  */
- 
- METHODDEF(boolean)
- decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
- {
-   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
-   int blkn;
-   BITREAD_STATE_VARS;
-   savable_state state;
- 
-   /* Process restart marker if needed; may have to suspend */
-   if (cinfo->restart_interval) {
-     if (entropy->restarts_to_go == 0)
-       if (! process_restart(cinfo))
- 	return FALSE;
-   }
- 
-   /* If we've run out of data, just leave the MCU set to zeroes.
-    * This way, we return uniform gray for the remainder of the segment.
-    */
-   if (! entropy->pub.insufficient_data) {
- 
-     /* Load up working state */
-     BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
-     ASSIGN_STATE(state, entropy->saved);
- 
-     /* Outer loop handles each block in the MCU */
- 
-     for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
-       JBLOCKROW block = MCU_data[blkn];
-       d_derived_tbl * dctbl = entropy->dc_cur_tbls[blkn];
-       d_derived_tbl * actbl = entropy->ac_cur_tbls[blkn];
-       register int s, k, r;
- 
-       /* Decode a single block's worth of coefficients */
- 
-       /* Section F.2.2.1: decode the DC coefficient difference */
-       HUFF_DECODE(s, br_state, dctbl, return FALSE, label1);
-       if (s) {
- 	CHECK_BIT_BUFFER(br_state, s, return FALSE);
- 	r = GET_BITS(s);
- 	s = HUFF_EXTEND(r, s);
-       }
- 
-       if (entropy->dc_needed[blkn]) {
- 	/* Convert DC difference to actual value, update last_dc_val */
- 	int ci = cinfo->MCU_membership[blkn];
- 	s += state.last_dc_val[ci];
- 	state.last_dc_val[ci] = s;
- 	/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */
- 	(*block)[0] = (JCOEF) s;
-       }
- 
-       if (entropy->ac_needed[blkn]) {
- 
- 	/* Section F.2.2.2: decode the AC coefficients */
- 	/* Since zeroes are skipped, output area must be cleared beforehand */
- 	for (k = 1; k < DCTSIZE2; k++) {
- 	  HUFF_DECODE(s, br_state, actbl, return FALSE, label2);
-       
- 	  r = s >> 4;
- 	  s &= 15;
-       
- 	  if (s) {
- 	    k += r;
- 	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
- 	    r = GET_BITS(s);
- 	    s = HUFF_EXTEND(r, s);
- 	    /* Output coefficient in natural (dezigzagged) order.
- 	     * Note: the extra entries in jpeg_natural_order[] will save us
- 	     * if k >= DCTSIZE2, which could happen if the data is corrupted.
- 	     */
- 	    (*block)[jpeg_natural_order[k]] = (JCOEF) s;
- 	  } else {
- 	    if (r != 15)
- 	      break;
- 	    k += 15;
- 	  }
- 	}
- 
-       } else {
- 
- 	/* Section F.2.2.2: decode the AC coefficients */
- 	/* In this path we just discard the values */
- 	for (k = 1; k < DCTSIZE2; k++) {
- 	  HUFF_DECODE(s, br_state, actbl, return FALSE, label3);
-       
- 	  r = s >> 4;
- 	  s &= 15;
-       
- 	  if (s) {
- 	    k += r;
- 	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
- 	    DROP_BITS(s);
- 	  } else {
- 	    if (r != 15)
- 	      break;
- 	    k += 15;
- 	  }
- 	}
- 
-       }
-     }
- 
-     /* Completed MCU, so update state */
-     BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
-     ASSIGN_STATE(entropy->saved, state);
-   }
- 
-   /* Account for restart interval (no-op if not using restarts) */
-   entropy->restarts_to_go--;
- 
-   return TRUE;
- }
- 
- 
- /*
-  * Module initialization routine for Huffman entropy decoding.
-  */
- 
- GLOBAL(void)
- jinit_huff_decoder (j_decompress_ptr cinfo)
- {
-   huff_entropy_ptr entropy;
-   int i;
- 
-   entropy = (huff_entropy_ptr)
-     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
- 				SIZEOF(huff_entropy_decoder));
-   cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
-   entropy->pub.start_pass = start_pass_huff_decoder;
-   entropy->pub.decode_mcu = decode_mcu;
- 
-   /* Mark tables unallocated */
-   for (i = 0; i < NUM_HUFF_TBLS; i++) {
-     entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
-   }
  }
--- 312,315 ----
diff -cN ../jpeg-6b/jdhuff.h ./jdhuff.h
*** ../jpeg-6b/jdhuff.h	Mon Oct 20 20:37:22 1997
--- ./jdhuff.h	Tue Apr 27 14:58:23 1999
***************
*** 1,13 ****
  /*
   * jdhuff.h
   *
!  * Copyright (C) 1991-1997, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
   * This file contains declarations for Huffman entropy decoding routines
!  * that are shared between the sequential decoder (jdhuff.c) and the
!  * progressive decoder (jdphuff.c).  No other modules need to see these.
   */
  
  /* Short forms of external names for systems with brain-damaged linkers. */
--- 1,14 ----
  /*
   * jdhuff.h
   *
!  * Copyright (C) 1991-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
   * This file contains declarations for Huffman entropy decoding routines
!  * that are shared between the sequential decoder (jdhuff.c), the
!  * progressive decoder (jdphuff.c) and the lossless decoder (jdlhuff.c).
!  * No other modules need to see these.
   */
  
  /* Short forms of external names for systems with brain-damaged linkers. */
***************
*** 199,201 ****
--- 200,229 ----
  EXTERN(int) jpeg_huff_decode
  	JPP((bitread_working_state * state, register bit_buf_type get_buffer,
  	     register int bits_left, d_derived_tbl * htbl, int min_bits));
+ 
+ 
+ /* Common fields between sequential, progressive and lossless Huffman entropy
+  * decoder master structs.
+  */
+ 
+ #define huffd_common_fields \
+   boolean insufficient_data;	/* set TRUE after emmitting warning */ \
+   /* These fields are loaded into local variables at start of each MCU. \
+    * In case of suspension, we exit WITHOUT updating them. \
+    */ \
+   bitread_perm_state bitstate	/* Bit buffer at start of MCU */
+ 
+ /* Routines that are to be used by any or all of the entropy decoders are
+  * declared to receive a pointer to this structure.  There are no actual
+  * instances of huffd_common_struct, only of shuff_entropy_decoder,
+  * phuff_entropy_decoder and lhuff_entropy_decoder.
+  */
+ struct huffd_common_struct {
+   huffd_common_fields;		/* Fields common to all decoder struct types */
+   /* Additional fields follow in an actual shuff_entropy_decoder,
+    * phuff_entropy_decoder or lhuff_entropy_decoder struct.  All four structs
+    * must agree on these initial fields!  (This would be a lot cleaner in C++.)
+    */
+ };
+ 
+ typedef struct huffd_common_struct * huffd_common_ptr;
diff -cN ../jpeg-6b/jdinput.c ./jdinput.c
*** ../jpeg-6b/jdinput.c	Fri Nov  7 11:26:04 1997
--- ./jdinput.c	Tue Apr 27 14:58:26 1999
***************
*** 1,14 ****
  /*
   * jdinput.c
   *
!  * Copyright (C) 1991-1997, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
   * This file contains input control logic for the JPEG decompressor.
   * These routines are concerned with controlling the decompressor's input
!  * processing (marker reading and coefficient decoding).  The actual input
!  * reading is done in jdmarker.c, jdhuff.c, and jdphuff.c.
   */
  
  #define JPEG_INTERNALS
--- 1,15 ----
  /*
   * jdinput.c
   *
!  * Copyright (C) 1991-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
   * This file contains input control logic for the JPEG decompressor.
   * These routines are concerned with controlling the decompressor's input
!  * processing (marker reading and coefficient/difference decoding).
!  * The actual input reading is done in jdmarker.c, jdhuff.c, jdphuff.c,
!  * and jdlhuff.c.
   */
  
  #define JPEG_INTERNALS
***************
*** 47,55 ****
        (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)
      ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) JPEG_MAX_DIMENSION);
  
!   /* For now, precision must match compiled-in value... */
!   if (cinfo->data_precision != BITS_IN_JSAMPLE)
!     ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
  
    /* Check that number of components won't exceed internal array sizes */
    if (cinfo->num_components > MAX_COMPONENTS)
--- 48,64 ----
        (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)
      ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) JPEG_MAX_DIMENSION);
  
!   if (cinfo->process == JPROC_LOSSLESS) {
!     /* If precision > compiled-in value, we must downscale */
!     if (cinfo->data_precision > BITS_IN_JSAMPLE)
!       WARNMS2(cinfo, JWRN_MUST_DOWNSCALE,
! 	      cinfo->data_precision, BITS_IN_JSAMPLE);
!   }
!   else {  /* Lossy processes */
!     /* For now, precision must match compiled-in value... */
!     if (cinfo->data_precision != BITS_IN_JSAMPLE)
!       ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
!   }
  
    /* Check that number of components won't exceed internal array sizes */
    if (cinfo->num_components > MAX_COMPONENTS)
***************
*** 70,92 ****
  				   compptr->v_samp_factor);
    }
  
!   /* We initialize DCT_scaled_size and min_DCT_scaled_size to DCTSIZE.
     * In the full decompressor, this will be overridden by jdmaster.c;
     * but in the transcoder, jdmaster.c is not used, so we must do it here.
     */
!   cinfo->min_DCT_scaled_size = DCTSIZE;
  
    /* Compute dimensions of components */
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
         ci++, compptr++) {
!     compptr->DCT_scaled_size = DCTSIZE;
!     /* Size in DCT blocks */
!     compptr->width_in_blocks = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
! 		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
!     compptr->height_in_blocks = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
! 		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
      /* downsampled_width and downsampled_height will also be overridden by
       * jdmaster.c if we are doing full decompression.  The transcoder library
       * doesn't use these values, but the calling application might.
--- 79,101 ----
  				   compptr->v_samp_factor);
    }
  
!   /* We initialize codec_data_unit and min_codec_data_unit to data_unit.
     * In the full decompressor, this will be overridden by jdmaster.c;
     * but in the transcoder, jdmaster.c is not used, so we must do it here.
     */
!   cinfo->min_codec_data_unit = cinfo->data_unit;
  
    /* Compute dimensions of components */
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
         ci++, compptr++) {
!     compptr->codec_data_unit = cinfo->data_unit;
!     /* Size in data units */
!     compptr->width_in_data_units = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
! 		    (long) (cinfo->max_h_samp_factor * cinfo->data_unit));
!     compptr->height_in_data_units = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
! 		    (long) (cinfo->max_v_samp_factor * cinfo->data_unit));
      /* downsampled_width and downsampled_height will also be overridden by
       * jdmaster.c if we are doing full decompression.  The transcoder library
       * doesn't use these values, but the calling application might.
***************
*** 107,116 ****
    /* Compute number of fully interleaved MCU rows. */
    cinfo->total_iMCU_rows = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height,
! 		  (long) (cinfo->max_v_samp_factor*DCTSIZE));
  
    /* Decide whether file contains multiple scans */
!   if (cinfo->comps_in_scan < cinfo->num_components || cinfo->progressive_mode)
      cinfo->inputctl->has_multiple_scans = TRUE;
    else
      cinfo->inputctl->has_multiple_scans = FALSE;
--- 116,126 ----
    /* Compute number of fully interleaved MCU rows. */
    cinfo->total_iMCU_rows = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height,
! 		  (long) (cinfo->max_v_samp_factor*cinfo->data_unit));
  
    /* Decide whether file contains multiple scans */
!   if (cinfo->comps_in_scan < cinfo->num_components ||
!       cinfo->process == JPROC_PROGRESSIVE)
      cinfo->inputctl->has_multiple_scans = TRUE;
    else
      cinfo->inputctl->has_multiple_scans = FALSE;
***************
*** 124,130 ****
  {
    int ci, mcublks, tmp;
    jpeg_component_info *compptr;
!   
    if (cinfo->comps_in_scan == 1) {
      
      /* Noninterleaved (single-component) scan */
--- 134,140 ----
  {
    int ci, mcublks, tmp;
    jpeg_component_info *compptr;
! 
    if (cinfo->comps_in_scan == 1) {
      
      /* Noninterleaved (single-component) scan */
***************
*** 131,154 ****
      compptr = cinfo->cur_comp_info[0];
      
      /* Overall image size in MCUs */
!     cinfo->MCUs_per_row = compptr->width_in_blocks;
!     cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
      
!     /* For noninterleaved scan, always one block per MCU */
      compptr->MCU_width = 1;
      compptr->MCU_height = 1;
!     compptr->MCU_blocks = 1;
!     compptr->MCU_sample_width = compptr->DCT_scaled_size;
      compptr->last_col_width = 1;
      /* For noninterleaved scans, it is convenient to define last_row_height
!      * as the number of block rows present in the last iMCU row.
       */
!     tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
      if (tmp == 0) tmp = compptr->v_samp_factor;
      compptr->last_row_height = tmp;
      
      /* Prepare array describing MCU composition */
!     cinfo->blocks_in_MCU = 1;
      cinfo->MCU_membership[0] = 0;
      
    } else {
--- 141,164 ----
      compptr = cinfo->cur_comp_info[0];
      
      /* Overall image size in MCUs */
!     cinfo->MCUs_per_row = compptr->width_in_data_units;
!     cinfo->MCU_rows_in_scan = compptr->height_in_data_units;
      
!     /* For noninterleaved scan, always one data unit per MCU */
      compptr->MCU_width = 1;
      compptr->MCU_height = 1;
!     compptr->MCU_data_units = 1;
!     compptr->MCU_sample_width = compptr->codec_data_unit;
      compptr->last_col_width = 1;
      /* For noninterleaved scans, it is convenient to define last_row_height
!      * as the number of data unit rows present in the last iMCU row.
       */
!     tmp = (int) (compptr->height_in_data_units % compptr->v_samp_factor);
      if (tmp == 0) tmp = compptr->v_samp_factor;
      compptr->last_row_height = tmp;
      
      /* Prepare array describing MCU composition */
!     cinfo->data_units_in_MCU = 1;
      cinfo->MCU_membership[0] = 0;
      
    } else {
***************
*** 161,193 ****
      /* Overall image size in MCUs */
      cinfo->MCUs_per_row = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_width,
! 		    (long) (cinfo->max_h_samp_factor*DCTSIZE));
      cinfo->MCU_rows_in_scan = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_height,
! 		    (long) (cinfo->max_v_samp_factor*DCTSIZE));
      
!     cinfo->blocks_in_MCU = 0;
      
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
        compptr = cinfo->cur_comp_info[ci];
!       /* Sampling factors give # of blocks of component in each MCU */
        compptr->MCU_width = compptr->h_samp_factor;
        compptr->MCU_height = compptr->v_samp_factor;
!       compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
!       compptr->MCU_sample_width = compptr->MCU_width * compptr->DCT_scaled_size;
!       /* Figure number of non-dummy blocks in last MCU column & row */
!       tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
        if (tmp == 0) tmp = compptr->MCU_width;
        compptr->last_col_width = tmp;
!       tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
        if (tmp == 0) tmp = compptr->MCU_height;
        compptr->last_row_height = tmp;
        /* Prepare array describing MCU composition */
!       mcublks = compptr->MCU_blocks;
!       if (cinfo->blocks_in_MCU + mcublks > D_MAX_BLOCKS_IN_MCU)
  	ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
        while (mcublks-- > 0) {
! 	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
        }
      }
      
--- 171,203 ----
      /* Overall image size in MCUs */
      cinfo->MCUs_per_row = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_width,
! 		    (long) (cinfo->max_h_samp_factor*cinfo->data_unit));
      cinfo->MCU_rows_in_scan = (JDIMENSION)
        jdiv_round_up((long) cinfo->image_height,
! 		    (long) (cinfo->max_v_samp_factor*cinfo->data_unit));
      
!     cinfo->data_units_in_MCU = 0;
      
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
        compptr = cinfo->cur_comp_info[ci];
!       /* Sampling factors give # of data units of component in each MCU */
        compptr->MCU_width = compptr->h_samp_factor;
        compptr->MCU_height = compptr->v_samp_factor;
!       compptr->MCU_data_units = compptr->MCU_width * compptr->MCU_height;
!       compptr->MCU_sample_width = compptr->MCU_width * compptr->codec_data_unit;
!       /* Figure number of non-dummy data units in last MCU column & row */
!       tmp = (int) (compptr->width_in_data_units % compptr->MCU_width);
        if (tmp == 0) tmp = compptr->MCU_width;
        compptr->last_col_width = tmp;
!       tmp = (int) (compptr->height_in_data_units % compptr->MCU_height);
        if (tmp == 0) tmp = compptr->MCU_height;
        compptr->last_row_height = tmp;
        /* Prepare array describing MCU composition */
!       mcublks = compptr->MCU_data_units;
!       if (cinfo->data_units_in_MCU + mcublks > D_MAX_DATA_UNITS_IN_MCU)
  	ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
        while (mcublks-- > 0) {
! 	cinfo->MCU_membership[cinfo->data_units_in_MCU++] = ci;
        }
      }
      
***************
*** 196,249 ****
  
  
  /*
-  * Save away a copy of the Q-table referenced by each component present
-  * in the current scan, unless already saved during a prior scan.
-  *
-  * In a multiple-scan JPEG file, the encoder could assign different components
-  * the same Q-table slot number, but change table definitions between scans
-  * so that each component uses a different Q-table.  (The IJG encoder is not
-  * currently capable of doing this, but other encoders might.)  Since we want
-  * to be able to dequantize all the components at the end of the file, this
-  * means that we have to save away the table actually used for each component.
-  * We do this by copying the table at the start of the first scan containing
-  * the component.
-  * The JPEG spec prohibits the encoder from changing the contents of a Q-table
-  * slot between scans of a component using that slot.  If the encoder does so
-  * anyway, this decoder will simply use the Q-table values that were current
-  * at the start of the first scan for the component.
-  *
-  * The decompressor output side looks only at the saved quant tables,
-  * not at the current Q-table slots.
-  */
- 
- LOCAL(void)
- latch_quant_tables (j_decompress_ptr cinfo)
- {
-   int ci, qtblno;
-   jpeg_component_info *compptr;
-   JQUANT_TBL * qtbl;
- 
-   for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
-     compptr = cinfo->cur_comp_info[ci];
-     /* No work if we already saved Q-table for this component */
-     if (compptr->quant_table != NULL)
-       continue;
-     /* Make sure specified quantization table is present */
-     qtblno = compptr->quant_tbl_no;
-     if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
- 	cinfo->quant_tbl_ptrs[qtblno] == NULL)
-       ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, qtblno);
-     /* OK, save away the quantization table */
-     qtbl = (JQUANT_TBL *)
-       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
- 				  SIZEOF(JQUANT_TBL));
-     MEMCOPY(qtbl, cinfo->quant_tbl_ptrs[qtblno], SIZEOF(JQUANT_TBL));
-     compptr->quant_table = qtbl;
-   }
- }
- 
- 
- /*
   * Initialize the input modules to read a scan of compressed data.
   * The first call to this is done by jdmaster.c after initializing
   * the entire decompressor (during jpeg_start_decompress).
--- 206,211 ----
***************
*** 254,263 ****
  start_input_pass (j_decompress_ptr cinfo)
  {
    per_scan_setup(cinfo);
!   latch_quant_tables(cinfo);
!   (*cinfo->entropy->start_pass) (cinfo);
!   (*cinfo->coef->start_input_pass) (cinfo);
!   cinfo->inputctl->consume_input = cinfo->coef->consume_data;
  }
  
  
--- 216,223 ----
  start_input_pass (j_decompress_ptr cinfo)
  {
    per_scan_setup(cinfo);
!   (*cinfo->codec->start_input_pass) (cinfo);
!   cinfo->inputctl->consume_input = cinfo->codec->consume_data;
  }
  
  
***************
*** 299,304 ****
--- 259,270 ----
    case JPEG_REACHED_SOS:	/* Found SOS */
      if (inputctl->inheaders) {	/* 1st SOS */
        initial_setup(cinfo);
+       /*
+        * Initialize the decompression codec.  We need to do this here so that
+        * any codec-specific fields and function pointers are available to
+        * the rest of the library.
+        */
+       jinit_d_codec(cinfo);
        inputctl->inheaders = FALSE;
        /* Note: start_input_pass must be called by jdmaster.c
         * before any more input can be consumed.  jdapimin.c is
diff -cN ../jpeg-6b/jdlhuff.c ./jdlhuff.c
*** ../jpeg-6b/jdlhuff.c
--- ./jdlhuff.c	Tue Apr 27 14:58:26 1999
***************
*** 0 ****
--- 1,290 ----
+ /*
+  * jdlhuff.c
+  *
+  * Copyright (C) 1991-1998, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+  * This file contains Huffman entropy decoding routines for lossless JPEG.
+  *
+  * Much of the complexity here has to do with supporting input suspension.
+  * If the data source module demands suspension, we want to be able to back
+  * up to the start of the current MCU.  To do this, we copy state variables
+  * into local working storage, and update them back to the permanent
+  * storage only upon successful completion of an MCU.
+  */
+ 
+ #define JPEG_INTERNALS
+ #include "jinclude.h"
+ #include "jpeglib.h"
+ #include "jlossls.h"		/* Private declarations for lossless codec */
+ #include "jdhuff.h"		/* Declarations shared with jd*huff.c */
+ 
+ 
+ #ifdef D_LOSSLESS_SUPPORTED
+ 
+ typedef struct {
+   int ci, yoffset, MCU_width;
+ } lhd_output_ptr_info;
+ 
+ /*
+  * Private entropy decoder object for lossless Huffman decoding.
+  */
+ 
+ typedef struct {
+   huffd_common_fields;		/* Fields shared with other entropy decoders */
+ 
+   /* Pointers to derived tables (these workspaces have image lifespan) */
+   d_derived_tbl * derived_tbls[NUM_HUFF_TBLS];
+ 
+   /* Precalculated info set up by start_pass for use in decode_mcus: */
+ 
+   /* Pointers to derived tables to be used for each data unit within an MCU */
+   d_derived_tbl * cur_tbls[D_MAX_DATA_UNITS_IN_MCU];
+ 
+   /* Pointers to the proper output difference row for each group of data units
+    * within an MCU.  For each component, there are Vi groups of Hi data units.
+    */
+   JDIFFROW output_ptr[D_MAX_DATA_UNITS_IN_MCU];
+ 
+   /* Number of output pointers in use for the current MCU.  This is the sum
+    * of all Vi in the MCU.
+    */
+   int num_output_ptrs;
+ 
+   /* Information used for positioning the output pointers within the output
+    * difference rows.
+    */
+   lhd_output_ptr_info output_ptr_info[D_MAX_DATA_UNITS_IN_MCU];
+ 
+   /* Index of the proper output pointer for each data unit within an MCU */
+   int output_ptr_index[D_MAX_DATA_UNITS_IN_MCU];
+ 
+ } lhuff_entropy_decoder;
+ 
+ typedef lhuff_entropy_decoder * lhuff_entropy_ptr;
+ 
+ 
+ /*
+  * Initialize for a Huffman-compressed scan.
+  */
+ 
+ METHODDEF(void)
+ start_pass_lhuff_decoder (j_decompress_ptr cinfo)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+   lhuff_entropy_ptr entropy = (lhuff_entropy_ptr) losslsd->entropy_private;
+   int ci, dctbl, sampn, ptrn, yoffset, xoffset;
+   jpeg_component_info * compptr;
+ 
+   for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
+     compptr = cinfo->cur_comp_info[ci];
+     dctbl = compptr->dc_tbl_no;
+     /* Make sure requested tables are present */
+     if (dctbl < 0 || dctbl >= NUM_HUFF_TBLS ||
+ 	cinfo->dc_huff_tbl_ptrs[dctbl] == NULL)
+       ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, dctbl);
+     /* Compute derived values for Huffman tables */
+     /* We may do this more than once for a table, but it's not expensive */
+     jpeg_make_d_derived_tbl(cinfo, TRUE, dctbl,
+ 			    & entropy->derived_tbls[dctbl]);
+   }
+ 
+   /* Precalculate decoding info for each sample in an MCU of this scan */
+   for (sampn = 0, ptrn = 0; sampn < cinfo->data_units_in_MCU;) {
+     compptr = cinfo->cur_comp_info[cinfo->MCU_membership[sampn]];
+     ci = compptr->component_index;
+     for (yoffset = 0; yoffset < compptr->MCU_height; yoffset++, ptrn++) {
+       /* Precalculate the setup info for each output pointer */
+       entropy->output_ptr_info[ptrn].ci = ci;
+       entropy->output_ptr_info[ptrn].yoffset = yoffset;
+       entropy->output_ptr_info[ptrn].MCU_width = compptr->MCU_width;
+       for (xoffset = 0; xoffset < compptr->MCU_width; xoffset++, sampn++) {
+ 	/* Precalculate the output pointer index for each sample */
+ 	entropy->output_ptr_index[sampn] = ptrn;
+ 	/* Precalculate which table to use for each sample */
+ 	entropy->cur_tbls[sampn] = entropy->derived_tbls[compptr->dc_tbl_no];
+       }
+     }
+   }
+   entropy->num_output_ptrs = ptrn;
+ 
+   /* Initialize bitread state variables */
+   entropy->bitstate.bits_left = 0;
+   entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
+   entropy->insufficient_data = FALSE;
+ }
+ 
+ 
+ /*
+  * Figure F.12: extend sign bit.
+  * On some machines, a shift and add will be faster than a table lookup.
+  */
+ 
+ #ifdef AVOID_TABLES
+ 
+ #define HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) + (((-1)<<(s)) + 1) : (x))
+ 
+ #else
+ 
+ #define HUFF_EXTEND(x,s)  ((x) < extend_test[s] ? (x) + extend_offset[s] : (x))
+ 
+ static const int extend_test[16] =   /* entry n is 2**(n-1) */
+   { 0, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
+     0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000 };
+ 
+ static const int extend_offset[16] = /* entry n is (-1 << n) + 1 */
+   { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
+     ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
+     ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
+     ((-1)<<13) + 1, ((-1)<<14) + 1, ((-1)<<15) + 1 };
+ 
+ #endif /* AVOID_TABLES */
+ 
+ 
+ /*
+  * Check for a restart marker & resynchronize decoder.
+  * Returns FALSE if must suspend.
+  */
+ 
+ METHODDEF(boolean)
+ process_restart (j_decompress_ptr cinfo)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+   lhuff_entropy_ptr entropy = (lhuff_entropy_ptr) losslsd->entropy_private;
+   int ci;
+ 
+   /* Throw away any unused bits remaining in bit buffer; */
+   /* include any full bytes in next_marker's count of discarded bytes */
+   cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
+   entropy->bitstate.bits_left = 0;
+ 
+   /* Advance past the RSTn marker */
+   if (! (*cinfo->marker->read_restart_marker) (cinfo))
+     return FALSE;
+ 
+   /* Reset out-of-data flag, unless read_restart_marker left us smack up
+    * against a marker.  In that case we will end up treating the next data
+    * segment as empty, and we can avoid producing bogus output pixels by
+    * leaving the flag set.
+    */
+   if (cinfo->unread_marker == 0)
+     entropy->insufficient_data = FALSE;
+ 
+   return TRUE;
+ }
+ 
+ 
+ /*
+  * Decode and return nMCU's worth of Huffman-compressed differences.
+  * Each MCU is also disassembled and placed accordingly in diff_buf.
+  *
+  * MCU_col_num specifies the column of the first MCU being requested within
+  * the MCU-row.  This tells us where to position the output row pointers in
+  * diff_buf.
+  *
+  * Returns the number of MCUs decoded.  This may be less than nMCU if data
+  * source requested suspension.  In that case no changes have been made to
+  * permanent state.  (Exception: some output differences may already have
+  * been assigned.  This is harmless for this module, since we'll just
+  * re-assign them on the next call.)
+  */
+ 
+ METHODDEF(JDIMENSION)
+ decode_mcus (j_decompress_ptr cinfo, JDIFFIMAGE diff_buf,
+ 	     JDIMENSION MCU_row_num, JDIMENSION MCU_col_num, JDIMENSION nMCU)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+   lhuff_entropy_ptr entropy = (lhuff_entropy_ptr) losslsd->entropy_private;
+   int mcu_num, sampn, ci, yoffset, MCU_width, ptrn;
+   BITREAD_STATE_VARS;
+ 
+   /* Set output pointer locations based on MCU_col_num */
+   for (ptrn = 0; ptrn < entropy->num_output_ptrs; ptrn++) {
+     ci = entropy->output_ptr_info[ptrn].ci;
+     yoffset = entropy->output_ptr_info[ptrn].yoffset;
+     MCU_width = entropy->output_ptr_info[ptrn].MCU_width;
+     entropy->output_ptr[ptrn] =
+       diff_buf[ci][MCU_row_num + yoffset] + (MCU_col_num * MCU_width);
+   }
+ 
+   /*
+    * If we've run out of data, zero out the buffers and return.
+    * By resetting the undifferencer, the output samples will be CENTERJSAMPLE.
+    *
+    * NB: We should find a way to do this without interacting with the
+    * undifferencer module directly.
+    */
+   if (entropy->insufficient_data) {
+     for (ptrn = 0; ptrn < entropy->num_output_ptrs; ptrn++)
+       jzero_far((void FAR *) entropy->output_ptr[ptrn],
+ 		nMCU * entropy->output_ptr_info[ptrn].MCU_width * SIZEOF(JDIFF));
+ 
+     (*losslsd->predict_process_restart) (cinfo);
+   }
+ 
+   else {
+ 
+     /* Load up working state */
+     BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
+ 
+     /* Outer loop handles the number of MCU requested */
+ 
+     for (mcu_num = 0; mcu_num < nMCU; mcu_num++) {
+ 
+       /* Inner loop handles the samples in the MCU */
+       for (sampn = 0; sampn < cinfo->data_units_in_MCU; sampn++) {
+ 	d_derived_tbl * dctbl = entropy->cur_tbls[sampn];
+ 	register int s, r;
+ 
+ 	/* Section H.2.2: decode the sample difference */
+ 	HUFF_DECODE(s, br_state, dctbl, return mcu_num, label1);
+ 	if (s) {
+ 	  if (s == 16)	/* special case: always output 32768 */
+ 	    s = 32768;
+ 	  else {	/* normal case: fetch subsequent bits */
+ 	    CHECK_BIT_BUFFER(br_state, s, return mcu_num);
+ 	    r = GET_BITS(s);
+ 	    s = HUFF_EXTEND(r, s);
+ 	  }
+ 	}
+ 
+ 	/* Output the sample difference */
+ 	*entropy->output_ptr[entropy->output_ptr_index[sampn]]++ = (JDIFF) s;
+       }
+ 
+       /* Completed MCU, so update state */
+       BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
+     }
+   }
+ 
+  return nMCU;
+ }
+ 
+ 
+ /*
+  * Module initialization routine for lossless Huffman entropy decoding.
+  */
+ 
+ GLOBAL(void)
+ jinit_lhuff_decoder (j_decompress_ptr cinfo)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+   lhuff_entropy_ptr entropy;
+   int i;
+ 
+   entropy = (lhuff_entropy_ptr)
+     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
+ 				SIZEOF(lhuff_entropy_decoder));
+   losslsd->entropy_private = (void *) entropy;
+   losslsd->entropy_start_pass = start_pass_lhuff_decoder;
+   losslsd->entropy_process_restart = process_restart;
+   losslsd->entropy_decode_mcus = decode_mcus;
+ 
+   /* Mark tables unallocated */
+   for (i = 0; i < NUM_HUFF_TBLS; i++) {
+     entropy->derived_tbls[i] = NULL;
+   }
+ }
+ 
+ #endif /* D_LOSSLESS_SUPPORTED */
diff -cN ../jpeg-6b/jdlossls.c ./jdlossls.c
*** ../jpeg-6b/jdlossls.c
--- ./jdlossls.c	Tue Apr 27 14:58:26 1999
***************
*** 0 ****
--- 1,94 ----
+ /*
+  * jdlossls.c
+  *
+  * Copyright (C) 1998, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+  * This file contains the control logic for the lossless JPEG decompressor.
+  */
+ 
+ #define JPEG_INTERNALS
+ #include "jinclude.h"
+ #include "jpeglib.h"
+ #include "jlossls.h"
+ 
+ 
+ #ifdef D_LOSSLESS_SUPPORTED
+ 
+ /*
+  * Compute output image dimensions and related values.
+  */
+ 
+ METHODDEF(void)
+ calc_output_dimensions (j_decompress_ptr cinfo)
+ {
+   /* Hardwire it to "no scaling" */
+   cinfo->output_width = cinfo->image_width;
+   cinfo->output_height = cinfo->image_height;
+   /* jdinput.c has already initialized codec_data_unit to 1,
+    * and has computed unscaled downsampled_width and downsampled_height.
+    */
+ }
+ 
+ 
+ /*
+  * Initialize for an input processing pass.
+  */
+ 
+ METHODDEF(void)
+ start_input_pass (j_decompress_ptr cinfo)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+ 
+   (*losslsd->entropy_start_pass) (cinfo);
+   (*losslsd->predict_start_pass) (cinfo);
+   (*losslsd->scaler_start_pass) (cinfo);
+   (*losslsd->diff_start_input_pass) (cinfo);
+ }
+ 
+ 
+ /*
+  * Initialize the lossless decompression codec.
+  * This is called only once, during master selection.
+  */
+ 
+ GLOBAL(void) 
+ jinit_lossless_d_codec(j_decompress_ptr cinfo)
+ {
+   j_lossless_d_ptr losslsd;
+   boolean use_c_buffer;
+ 
+   /* Create subobject in permanent pool */
+   losslsd = (j_lossless_d_ptr)
+     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
+ 				SIZEOF(jpeg_lossless_d_codec));
+   cinfo->codec = (struct jpeg_d_codec *) losslsd;
+ 
+   /* Initialize sub-modules */
+   /* Entropy decoding: either Huffman or arithmetic coding. */
+   if (cinfo->arith_code) {
+     ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
+   } else {
+     jinit_lhuff_decoder(cinfo);
+   }
+ 
+   /* Undifferencer */
+   jinit_undifferencer(cinfo);
+ 
+   /* Scaler */
+   jinit_d_scaler(cinfo);
+ 
+   use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;
+   jinit_d_diff_controller(cinfo, use_c_buffer);
+ 
+   /* Initialize method pointers.
+    *
+    * Note: consume_data, start_output_pass and decompress_data are
+    * assigned in jddiffct.c.
+    */
+   losslsd->pub.calc_output_dimensions = calc_output_dimensions;
+   losslsd->pub.start_input_pass = start_input_pass;
+ }
+ 
+ #endif /* D_LOSSLESS_SUPPORTED */
diff -cN ../jpeg-6b/jdlossy.c ./jdlossy.c
*** ../jpeg-6b/jdlossy.c
--- ./jdlossy.c	Tue Apr 27 14:58:27 1999
***************
*** 0 ****
--- 1,228 ----
+ /*
+  * jdlossy.c
+  *
+  * Copyright (C) 1998, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+  * This file contains the control logic for the lossy JPEG decompressor.
+  */
+ 
+ #define JPEG_INTERNALS
+ #include "jinclude.h"
+ #include "jpeglib.h"
+ #include "jlossy.h"
+ 
+ 
+ /*
+  * Compute output image dimensions and related values.
+  */
+ 
+ METHODDEF(void)
+ calc_output_dimensions (j_decompress_ptr cinfo)
+ {
+ #ifdef IDCT_SCALING_SUPPORTED
+   int ci;
+   jpeg_component_info *compptr;
+ 
+   /* Compute actual output image dimensions and DCT scaling choices. */
+   if (cinfo->scale_num * 8 <= cinfo->scale_denom) {
+     /* Provide 1/8 scaling */
+     cinfo->output_width = (JDIMENSION)
+       jdiv_round_up((long) cinfo->image_width, 8L);
+     cinfo->output_height = (JDIMENSION)
+       jdiv_round_up((long) cinfo->image_height, 8L);
+     cinfo->min_codec_data_unit = 1;
+   } else if (cinfo->scale_num * 4 <= cinfo->scale_denom) {
+     /* Provide 1/4 scaling */
+     cinfo->output_width = (JDIMENSION)
+       jdiv_round_up((long) cinfo->image_width, 4L);
+     cinfo->output_height = (JDIMENSION)
+       jdiv_round_up((long) cinfo->image_height, 4L);
+     cinfo->min_codec_data_unit = 2;
+   } else if (cinfo->scale_num * 2 <= cinfo->scale_denom) {
+     /* Provide 1/2 scaling */
+     cinfo->output_width = (JDIMENSION)
+       jdiv_round_up((long) cinfo->image_width, 2L);
+     cinfo->output_height = (JDIMENSION)
+       jdiv_round_up((long) cinfo->image_height, 2L);
+     cinfo->min_codec_data_unit = 4;
+   } else {
+     /* Provide 1/1 scaling */
+     cinfo->output_width = cinfo->image_width;
+     cinfo->output_height = cinfo->image_height;
+     cinfo->min_codec_data_unit = DCTSIZE;
+   }
+   /* In selecting the actual DCT scaling for each component, we try to
+    * scale up the chroma components via IDCT scaling rather than upsampling.
+    * This saves time if the upsampler gets to use 1:1 scaling.
+    * Note this code assumes that the supported DCT scalings are powers of 2.
+    */
+   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
+        ci++, compptr++) {
+     int ssize = cinfo->min_codec_data_unit;
+     while (ssize < DCTSIZE &&
+ 	   (compptr->h_samp_factor * ssize * 2 <=
+ 	    cinfo->max_h_samp_factor * cinfo->min_codec_data_unit) &&
+ 	   (compptr->v_samp_factor * ssize * 2 <=
+ 	    cinfo->max_v_samp_factor * cinfo->min_codec_data_unit)) {
+       ssize = ssize * 2;
+     }
+     compptr->codec_data_unit = ssize;
+   }
+ 
+   /* Recompute downsampled dimensions of components;
+    * application needs to know these if using raw downsampled data.
+    */
+   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
+        ci++, compptr++) {
+     /* Size in samples, after IDCT scaling */
+     compptr->downsampled_width = (JDIMENSION)
+       jdiv_round_up((long) cinfo->image_width *
+ 		    (long) (compptr->h_samp_factor * compptr->codec_data_unit),
+ 		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
+     compptr->downsampled_height = (JDIMENSION)
+       jdiv_round_up((long) cinfo->image_height *
+ 		    (long) (compptr->v_samp_factor * compptr->codec_data_unit),
+ 		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
+   }
+ 
+ #else /* !IDCT_SCALING_SUPPORTED */
+ 
+   /* Hardwire it to "no scaling" */
+   cinfo->output_width = cinfo->image_width;
+   cinfo->output_height = cinfo->image_height;
+   /* jdinput.c has already initialized codec_data_unit to DCTSIZE,
+    * and has computed unscaled downsampled_width and downsampled_height.
+    */
+ 
+ #endif /* IDCT_SCALING_SUPPORTED */
+ }
+ 
+ 
+ /*
+  * Save away a copy of the Q-table referenced by each component present
+  * in the current scan, unless already saved during a prior scan.
+  *
+  * In a multiple-scan JPEG file, the encoder could assign different components
+  * the same Q-table slot number, but change table definitions between scans
+  * so that each component uses a different Q-table.  (The IJG encoder is not
+  * currently capable of doing this, but other encoders might.)  Since we want
+  * to be able to dequantize all the components at the end of the file, this
+  * means that we have to save away the table actually used for each component.
+  * We do this by copying the table at the start of the first scan containing
+  * the component.
+  * The JPEG spec prohibits the encoder from changing the contents of a Q-table
+  * slot between scans of a component using that slot.  If the encoder does so
+  * anyway, this decoder will simply use the Q-table values that were current
+  * at the start of the first scan for the component.
+  *
+  * The decompressor output side looks only at the saved quant tables,
+  * not at the current Q-table slots.
+  */
+ 
+ LOCAL(void)
+ latch_quant_tables (j_decompress_ptr cinfo)
+ {
+   int ci, qtblno;
+   jpeg_component_info *compptr;
+   JQUANT_TBL * qtbl;
+ 
+   for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
+     compptr = cinfo->cur_comp_info[ci];
+     /* No work if we already saved Q-table for this component */
+     if (compptr->quant_table != NULL)
+       continue;
+     /* Make sure specified quantization table is present */
+     qtblno = compptr->quant_tbl_no;
+     if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
+ 	cinfo->quant_tbl_ptrs[qtblno] == NULL)
+       ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, qtblno);
+     /* OK, save away the quantization table */
+     qtbl = (JQUANT_TBL *)
+       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
+ 				  SIZEOF(JQUANT_TBL));
+     MEMCOPY(qtbl, cinfo->quant_tbl_ptrs[qtblno], SIZEOF(JQUANT_TBL));
+     compptr->quant_table = qtbl;
+   }
+ }
+ 
+ 
+ /*
+  * Initialize for an input processing pass.
+  */
+ 
+ METHODDEF(void)
+ start_input_pass (j_decompress_ptr cinfo)
+ {
+   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
+ 
+   latch_quant_tables(cinfo);
+   (*lossyd->entropy_start_pass) (cinfo);
+   (*lossyd->coef_start_input_pass) (cinfo);
+ }
+ 
+ 
+ /*
+  * Initialize for an output processing pass.
+  */
+ 
+ METHODDEF(void)
+ start_output_pass (j_decompress_ptr cinfo)
+ {
+   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
+ 
+   (*lossyd->idct_start_pass) (cinfo);
+   (*lossyd->coef_start_output_pass) (cinfo);
+ }
+ 
+ /*
+  * Initialize the lossy decompression codec.
+  * This is called only once, during master selection.
+  */
+ 
+ GLOBAL(void)
+ jinit_lossy_d_codec (j_decompress_ptr cinfo)
+ {
+   j_lossy_d_ptr lossyd;
+   boolean use_c_buffer;
+ 
+   /* Create subobject in permanent pool */
+   lossyd = (j_lossy_d_ptr)
+     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
+ 				SIZEOF(jpeg_lossy_d_codec));
+   cinfo->codec = (struct jpeg_d_codec *) lossyd;
+ 
+   /* Initialize sub-modules */
+ 
+   /* Inverse DCT */
+   jinit_inverse_dct(cinfo);
+   /* Entropy decoding: either Huffman or arithmetic coding. */
+   if (cinfo->arith_code) {
+     ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
+   } else {
+     if (cinfo->process == JPROC_PROGRESSIVE) {
+ #ifdef D_PROGRESSIVE_SUPPORTED
+       jinit_phuff_decoder(cinfo);
+ #else
+       ERREXIT(cinfo, JERR_NOT_COMPILED);
+ #endif
+     } else
+       jinit_shuff_decoder(cinfo);
+   }
+ 
+   use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;
+   jinit_d_coef_controller(cinfo, use_c_buffer);
+ 
+   /* Initialize method pointers.
+    *
+    * Note: consume_data and decompress_data are assigned in jdcoefct.c.
+    */
+   lossyd->pub.calc_output_dimensions = calc_output_dimensions;
+   lossyd->pub.start_input_pass = start_input_pass;
+   lossyd->pub.start_output_pass = start_output_pass;
+ }
+ 
+ 
+ 
+ 
diff -cN ../jpeg-6b/jdmainct.c ./jdmainct.c
*** ../jpeg-6b/jdmainct.c	Sat Jan  6 18:27:17 1996
--- ./jdmainct.c	Tue Apr 27 14:58:27 1999
***************
*** 1,7 ****
  /*
   * jdmainct.c
   *
!  * Copyright (C) 1994-1996, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jdmainct.c
   *
!  * Copyright (C) 1994-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 26,43 ****
   * rescaling, and doing this in an efficient fashion is a bit tricky.
   *
   * Postprocessor input data is counted in "row groups".  A row group
!  * is defined to be (v_samp_factor * DCT_scaled_size / min_DCT_scaled_size)
!  * sample rows of each component.  (We require DCT_scaled_size values to be
!  * chosen such that these numbers are integers.  In practice DCT_scaled_size
   * values will likely be powers of two, so we actually have the stronger
!  * condition that DCT_scaled_size / min_DCT_scaled_size is an integer.)
   * Upsampling will typically produce max_v_samp_factor pixel rows from each
   * row group (times any additional scale factor that the upsampler is
   * applying).
   *
!  * The coefficient controller will deliver data to us one iMCU row at a time;
!  * each iMCU row contains v_samp_factor * DCT_scaled_size sample rows, or
!  * exactly min_DCT_scaled_size row groups.  (This amount of data corresponds
   * to one row of MCUs when the image is fully interleaved.)  Note that the
   * number of sample rows varies across components, but the number of row
   * groups does not.  Some garbage sample rows may be included in the last iMCU
--- 26,43 ----
   * rescaling, and doing this in an efficient fashion is a bit tricky.
   *
   * Postprocessor input data is counted in "row groups".  A row group
!  * is defined to be (v_samp_factor * codec_data_unit / min_codec_data_unit)
!  * sample rows of each component.  (We require codec_data_unit values to be
!  * chosen such that these numbers are integers.  In practice codec_data_unit
   * values will likely be powers of two, so we actually have the stronger
!  * condition that codec_data_unit / min_codec_data_unit is an integer.)
   * Upsampling will typically produce max_v_samp_factor pixel rows from each
   * row group (times any additional scale factor that the upsampler is
   * applying).
   *
!  * The decompression codec will deliver data to us one iMCU row at a time;
!  * each iMCU row contains v_samp_factor * codec_data_unit sample rows, or
!  * exactly min_codec_data_unit row groups.  (This amount of data corresponds
   * to one row of MCUs when the image is fully interleaved.)  Note that the
   * number of sample rows varies across components, but the number of row
   * groups does not.  Some garbage sample rows may be included in the last iMCU
***************
*** 64,70 ****
   * supporting arbitrary output rescaling might wish for more than one row
   * group of context when shrinking the image; tough, we don't handle that.
   * (This is justified by the assumption that downsizing will be handled mostly
!  * by adjusting the DCT_scaled_size values, so that the actual scale factor at
   * the upsample step needn't be much less than one.)
   *
   * To provide the desired context, we have to retain the last two row groups
--- 64,70 ----
   * supporting arbitrary output rescaling might wish for more than one row
   * group of context when shrinking the image; tough, we don't handle that.
   * (This is justified by the assumption that downsizing will be handled mostly
!  * by adjusting the codec_data_unit values, so that the actual scale factor at
   * the upsample step needn't be much less than one.)
   *
   * To provide the desired context, we have to retain the last two row groups
***************
*** 74,80 ****
   * We could do this most simply by copying data around in our buffer, but
   * that'd be very slow.  We can avoid copying any data by creating a rather
   * strange pointer structure.  Here's how it works.  We allocate a workspace
!  * consisting of M+2 row groups (where M = min_DCT_scaled_size is the number
   * of row groups per iMCU row).  We create two sets of redundant pointers to
   * the workspace.  Labeling the physical row groups 0 to M+1, the synthesized
   * pointer lists look like this:
--- 74,80 ----
   * We could do this most simply by copying data around in our buffer, but
   * that'd be very slow.  We can avoid copying any data by creating a rather
   * strange pointer structure.  Here's how it works.  We allocate a workspace
!  * consisting of M+2 row groups (where M = min_codec_data_unit is the number
   * of row groups per iMCU row).  We create two sets of redundant pointers to
   * the workspace.  Labeling the physical row groups 0 to M+1, the synthesized
   * pointer lists look like this:
***************
*** 99,109 ****
   * the first or last sample row as necessary (this is cheaper than copying
   * sample rows around).
   *
!  * This scheme breaks down if M < 2, ie, min_DCT_scaled_size is 1.  In that
   * situation each iMCU row provides only one row group so the buffering logic
   * must be different (eg, we must read two iMCU rows before we can emit the
   * first row group).  For now, we simply do not support providing context
!  * rows when min_DCT_scaled_size is 1.  That combination seems unlikely to
   * be worth providing --- if someone wants a 1/8th-size preview, they probably
   * want it quick and dirty, so a context-free upsampler is sufficient.
   */
--- 99,109 ----
   * the first or last sample row as necessary (this is cheaper than copying
   * sample rows around).
   *
!  * This scheme breaks down if M < 2, ie, min_codec_data_unit is 1.  In that
   * situation each iMCU row provides only one row group so the buffering logic
   * must be different (eg, we must read two iMCU rows before we can emit the
   * first row group).  For now, we simply do not support providing context
!  * rows when min_codec_data_unit is 1.  That combination seems unlikely to
   * be worth providing --- if someone wants a 1/8th-size preview, they probably
   * want it quick and dirty, so a context-free upsampler is sufficient.
   */
***************
*** 161,167 ****
  {
    my_main_ptr main = (my_main_ptr) cinfo->main;
    int ci, rgroup;
!   int M = cinfo->min_DCT_scaled_size;
    jpeg_component_info *compptr;
    JSAMPARRAY xbuf;
  
--- 161,167 ----
  {
    my_main_ptr main = (my_main_ptr) cinfo->main;
    int ci, rgroup;
!   int M = cinfo->min_codec_data_unit;
    jpeg_component_info *compptr;
    JSAMPARRAY xbuf;
  
***************
*** 175,182 ****
  
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
         ci++, compptr++) {
!     rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
!       cinfo->min_DCT_scaled_size; /* height of a row group of component */
      /* Get space for pointer lists --- M+4 row groups in each list.
       * We alloc both pointer lists with one call to save a few cycles.
       */
--- 175,182 ----
  
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
         ci++, compptr++) {
!     rgroup = (compptr->v_samp_factor * compptr->codec_data_unit) /
!       cinfo->min_codec_data_unit; /* height of a row group of component */
      /* Get space for pointer lists --- M+4 row groups in each list.
       * We alloc both pointer lists with one call to save a few cycles.
       */
***************
*** 202,215 ****
  {
    my_main_ptr main = (my_main_ptr) cinfo->main;
    int ci, i, rgroup;
!   int M = cinfo->min_DCT_scaled_size;
    jpeg_component_info *compptr;
    JSAMPARRAY buf, xbuf0, xbuf1;
  
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
         ci++, compptr++) {
!     rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
!       cinfo->min_DCT_scaled_size; /* height of a row group of component */
      xbuf0 = main->xbuffer[0][ci];
      xbuf1 = main->xbuffer[1][ci];
      /* First copy the workspace pointers as-is */
--- 202,215 ----
  {
    my_main_ptr main = (my_main_ptr) cinfo->main;
    int ci, i, rgroup;
!   int M = cinfo->min_codec_data_unit;
    jpeg_component_info *compptr;
    JSAMPARRAY buf, xbuf0, xbuf1;
  
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
         ci++, compptr++) {
!     rgroup = (compptr->v_samp_factor * compptr->codec_data_unit) /
!       cinfo->min_codec_data_unit; /* height of a row group of component */
      xbuf0 = main->xbuffer[0][ci];
      xbuf1 = main->xbuffer[1][ci];
      /* First copy the workspace pointers as-is */
***************
*** 242,255 ****
  {
    my_main_ptr main = (my_main_ptr) cinfo->main;
    int ci, i, rgroup;
!   int M = cinfo->min_DCT_scaled_size;
    jpeg_component_info *compptr;
    JSAMPARRAY xbuf0, xbuf1;
  
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
         ci++, compptr++) {
!     rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
!       cinfo->min_DCT_scaled_size; /* height of a row group of component */
      xbuf0 = main->xbuffer[0][ci];
      xbuf1 = main->xbuffer[1][ci];
      for (i = 0; i < rgroup; i++) {
--- 242,255 ----
  {
    my_main_ptr main = (my_main_ptr) cinfo->main;
    int ci, i, rgroup;
!   int M = cinfo->min_codec_data_unit;
    jpeg_component_info *compptr;
    JSAMPARRAY xbuf0, xbuf1;
  
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
         ci++, compptr++) {
!     rgroup = (compptr->v_samp_factor * compptr->codec_data_unit) /
!       cinfo->min_codec_data_unit; /* height of a row group of component */
      xbuf0 = main->xbuffer[0][ci];
      xbuf1 = main->xbuffer[1][ci];
      for (i = 0; i < rgroup; i++) {
***************
*** 277,284 ****
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
         ci++, compptr++) {
      /* Count sample rows in one iMCU row and in one row group */
!     iMCUheight = compptr->v_samp_factor * compptr->DCT_scaled_size;
!     rgroup = iMCUheight / cinfo->min_DCT_scaled_size;
      /* Count nondummy sample rows remaining for this component */
      rows_left = (int) (compptr->downsampled_height % (JDIMENSION) iMCUheight);
      if (rows_left == 0) rows_left = iMCUheight;
--- 277,284 ----
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
         ci++, compptr++) {
      /* Count sample rows in one iMCU row and in one row group */
!     iMCUheight = compptr->v_samp_factor * compptr->codec_data_unit;
!     rgroup = iMCUheight / cinfo->min_codec_data_unit;
      /* Count nondummy sample rows remaining for this component */
      rows_left = (int) (compptr->downsampled_height % (JDIMENSION) iMCUheight);
      if (rows_left == 0) rows_left = iMCUheight;
***************
*** 351,363 ****
  
    /* Read input data if we haven't filled the main buffer yet */
    if (! main->buffer_full) {
!     if (! (*cinfo->coef->decompress_data) (cinfo, main->buffer))
        return;			/* suspension forced, can do nothing more */
      main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
    }
  
!   /* There are always min_DCT_scaled_size row groups in an iMCU row. */
!   rowgroups_avail = (JDIMENSION) cinfo->min_DCT_scaled_size;
    /* Note: at the bottom of the image, we may pass extra garbage row groups
     * to the postprocessor.  The postprocessor has to check for bottom
     * of image anyway (at row resolution), so no point in us doing it too.
--- 351,363 ----
  
    /* Read input data if we haven't filled the main buffer yet */
    if (! main->buffer_full) {
!     if (! (*cinfo->codec->decompress_data) (cinfo, main->buffer))
        return;			/* suspension forced, can do nothing more */
      main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
    }
  
!   /* There are always min_codec_data_unit row groups in an iMCU row. */
!   rowgroups_avail = (JDIMENSION) cinfo->min_codec_data_unit;
    /* Note: at the bottom of the image, we may pass extra garbage row groups
     * to the postprocessor.  The postprocessor has to check for bottom
     * of image anyway (at row resolution), so no point in us doing it too.
***************
*** 390,396 ****
  
    /* Read input data if we haven't filled the main buffer yet */
    if (! main->buffer_full) {
!     if (! (*cinfo->coef->decompress_data) (cinfo,
  					   main->xbuffer[main->whichptr]))
        return;			/* suspension forced, can do nothing more */
      main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
--- 390,396 ----
  
    /* Read input data if we haven't filled the main buffer yet */
    if (! main->buffer_full) {
!     if (! (*cinfo->codec->decompress_data) (cinfo,
  					   main->xbuffer[main->whichptr]))
        return;			/* suspension forced, can do nothing more */
      main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
***************
*** 417,423 ****
    case CTX_PREPARE_FOR_IMCU:
      /* Prepare to process first M-1 row groups of this iMCU row */
      main->rowgroup_ctr = 0;
!     main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size - 1);
      /* Check for bottom of image: if so, tweak pointers to "duplicate"
       * the last sample row, and adjust rowgroups_avail to ignore padding rows.
       */
--- 417,423 ----
    case CTX_PREPARE_FOR_IMCU:
      /* Prepare to process first M-1 row groups of this iMCU row */
      main->rowgroup_ctr = 0;
!     main->rowgroups_avail = (JDIMENSION) (cinfo->min_codec_data_unit - 1);
      /* Check for bottom of image: if so, tweak pointers to "duplicate"
       * the last sample row, and adjust rowgroups_avail to ignore padding rows.
       */
***************
*** 440,447 ****
      main->buffer_full = FALSE;
      /* Still need to process last row group of this iMCU row, */
      /* which is saved at index M+1 of the other xbuffer */
!     main->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_scaled_size + 1);
!     main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size + 2);
      main->context_state = CTX_POSTPONED_ROW;
    }
  }
--- 440,447 ----
      main->buffer_full = FALSE;
      /* Still need to process last row group of this iMCU row, */
      /* which is saved at index M+1 of the other xbuffer */
!     main->rowgroup_ctr = (JDIMENSION) (cinfo->min_codec_data_unit + 1);
!     main->rowgroups_avail = (JDIMENSION) (cinfo->min_codec_data_unit + 2);
      main->context_state = CTX_POSTPONED_ROW;
    }
  }
***************
*** 492,512 ****
     * ngroups is the number of row groups we need.
     */
    if (cinfo->upsample->need_context_rows) {
!     if (cinfo->min_DCT_scaled_size < 2) /* unsupported, see comments above */
        ERREXIT(cinfo, JERR_NOTIMPL);
      alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */
!     ngroups = cinfo->min_DCT_scaled_size + 2;
    } else {
!     ngroups = cinfo->min_DCT_scaled_size;
    }
  
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
         ci++, compptr++) {
!     rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
!       cinfo->min_DCT_scaled_size; /* height of a row group of component */
      main->buffer[ci] = (*cinfo->mem->alloc_sarray)
  			((j_common_ptr) cinfo, JPOOL_IMAGE,
! 			 compptr->width_in_blocks * compptr->DCT_scaled_size,
  			 (JDIMENSION) (rgroup * ngroups));
    }
  }
--- 492,512 ----
     * ngroups is the number of row groups we need.
     */
    if (cinfo->upsample->need_context_rows) {
!     if (cinfo->min_codec_data_unit < 2) /* unsupported, see comments above */
        ERREXIT(cinfo, JERR_NOTIMPL);
      alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */
!     ngroups = cinfo->min_codec_data_unit + 2;
    } else {
!     ngroups = cinfo->min_codec_data_unit;
    }
  
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
         ci++, compptr++) {
!     rgroup = (compptr->v_samp_factor * compptr->codec_data_unit) /
!       cinfo->min_codec_data_unit; /* height of a row group of component */
      main->buffer[ci] = (*cinfo->mem->alloc_sarray)
  			((j_common_ptr) cinfo, JPOOL_IMAGE,
! 			 compptr->width_in_data_units * compptr->codec_data_unit,
  			 (JDIMENSION) (rgroup * ngroups));
    }
  }
diff -cN ../jpeg-6b/jdmarker.c ./jdmarker.c
*** ../jpeg-6b/jdmarker.c	Sat Feb 21 15:24:50 1998
--- ./jdmarker.c	Tue Apr 27 14:58:27 1999
***************
*** 234,240 ****
  
  
  LOCAL(boolean)
! get_sof (j_decompress_ptr cinfo, boolean is_prog, boolean is_arith)
  /* Process a SOFn marker */
  {
    INT32 length;
--- 234,241 ----
  
  
  LOCAL(boolean)
! get_sof (j_decompress_ptr cinfo, J_CODEC_PROCESS process, boolean is_arith,
! 	 int data_unit)
  /* Process a SOFn marker */
  {
    INT32 length;
***************
*** 242,248 ****
    jpeg_component_info * compptr;
    INPUT_VARS(cinfo);
  
!   cinfo->progressive_mode = is_prog;
    cinfo->arith_code = is_arith;
  
    INPUT_2BYTES(cinfo, length, return FALSE);
--- 243,250 ----
    jpeg_component_info * compptr;
    INPUT_VARS(cinfo);
  
!   cinfo->data_unit = data_unit;
!   cinfo->process = process;
    cinfo->arith_code = is_arith;
  
    INPUT_2BYTES(cinfo, length, return FALSE);
***************
*** 976,1007 ****
  
      case M_SOF0:		/* Baseline */
      case M_SOF1:		/* Extended sequential, Huffman */
!       if (! get_sof(cinfo, FALSE, FALSE))
  	return JPEG_SUSPENDED;
        break;
  
      case M_SOF2:		/* Progressive, Huffman */
!       if (! get_sof(cinfo, TRUE, FALSE))
  	return JPEG_SUSPENDED;
        break;
  
      case M_SOF9:		/* Extended sequential, arithmetic */
!       if (! get_sof(cinfo, FALSE, TRUE))
  	return JPEG_SUSPENDED;
        break;
  
      case M_SOF10:		/* Progressive, arithmetic */
!       if (! get_sof(cinfo, TRUE, TRUE))
  	return JPEG_SUSPENDED;
        break;
  
      /* Currently unsupported SOFn types */
-     case M_SOF3:		/* Lossless, Huffman */
      case M_SOF5:		/* Differential sequential, Huffman */
      case M_SOF6:		/* Differential progressive, Huffman */
      case M_SOF7:		/* Differential lossless, Huffman */
      case M_JPG:			/* Reserved for JPEG extensions */
-     case M_SOF11:		/* Lossless, arithmetic */
      case M_SOF13:		/* Differential sequential, arithmetic */
      case M_SOF14:		/* Differential progressive, arithmetic */
      case M_SOF15:		/* Differential lossless, arithmetic */
--- 978,1017 ----
  
      case M_SOF0:		/* Baseline */
      case M_SOF1:		/* Extended sequential, Huffman */
!       if (! get_sof(cinfo, JPROC_SEQUENTIAL, FALSE, DCTSIZE))
  	return JPEG_SUSPENDED;
        break;
  
      case M_SOF2:		/* Progressive, Huffman */
!       if (! get_sof(cinfo, JPROC_PROGRESSIVE, FALSE, DCTSIZE))
  	return JPEG_SUSPENDED;
        break;
  
+     case M_SOF3:		/* Lossless, Huffman */
+       if (! get_sof(cinfo, JPROC_LOSSLESS, FALSE, 1))
+ 	return JPEG_SUSPENDED;
+       break;
+ 
      case M_SOF9:		/* Extended sequential, arithmetic */
!       if (! get_sof(cinfo, JPROC_SEQUENTIAL, TRUE, DCTSIZE))
  	return JPEG_SUSPENDED;
        break;
  
      case M_SOF10:		/* Progressive, arithmetic */
!       if (! get_sof(cinfo, JPROC_PROGRESSIVE, TRUE, DCTSIZE))
! 	return JPEG_SUSPENDED;
!       break;
! 
!     case M_SOF11:		/* Lossless, arithmetic */
!       if (! get_sof(cinfo, JPROC_LOSSLESS, TRUE, 1))
  	return JPEG_SUSPENDED;
        break;
  
      /* Currently unsupported SOFn types */
      case M_SOF5:		/* Differential sequential, Huffman */
      case M_SOF6:		/* Differential progressive, Huffman */
      case M_SOF7:		/* Differential lossless, Huffman */
      case M_JPG:			/* Reserved for JPEG extensions */
      case M_SOF13:		/* Differential sequential, arithmetic */
      case M_SOF14:		/* Differential progressive, arithmetic */
      case M_SOF15:		/* Differential lossless, arithmetic */
diff -cN ../jpeg-6b/jdmaster.c ./jdmaster.c
*** ../jpeg-6b/jdmaster.c	Fri Nov  7 11:25:45 1997
--- ./jdmaster.c	Tue Apr 27 14:58:27 1999
***************
*** 1,7 ****
  /*
   * jdmaster.c
   *
!  * Copyright (C) 1991-1997, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jdmaster.c
   *
!  * Copyright (C) 1991-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 60,69 ****
        cinfo->comp_info[1].v_samp_factor != 1 ||
        cinfo->comp_info[2].v_samp_factor != 1)
      return FALSE;
!   /* furthermore, it doesn't work if we've scaled the IDCTs differently */
!   if (cinfo->comp_info[0].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
!       cinfo->comp_info[1].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
!       cinfo->comp_info[2].DCT_scaled_size != cinfo->min_DCT_scaled_size)
      return FALSE;
    /* ??? also need to test for upsample-time rescaling, when & if supported */
    return TRUE;			/* by golly, it'll work... */
--- 60,70 ----
        cinfo->comp_info[1].v_samp_factor != 1 ||
        cinfo->comp_info[2].v_samp_factor != 1)
      return FALSE;
!   /* furthermore, it doesn't work if each component has been
!      processed differently */
!   if (cinfo->comp_info[0].codec_data_unit != cinfo->min_codec_data_unit ||
!       cinfo->comp_info[1].codec_data_unit != cinfo->min_codec_data_unit ||
!       cinfo->comp_info[2].codec_data_unit != cinfo->min_codec_data_unit)
      return FALSE;
    /* ??? also need to test for upsample-time rescaling, when & if supported */
    return TRUE;			/* by golly, it'll work... */
***************
*** 84,172 ****
  jpeg_calc_output_dimensions (j_decompress_ptr cinfo)
  /* Do computations that are needed before master selection phase */
  {
- #ifdef IDCT_SCALING_SUPPORTED
-   int ci;
-   jpeg_component_info *compptr;
- #endif
- 
    /* Prevent application from calling me at wrong times */
    if (cinfo->global_state != DSTATE_READY)
      ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  
! #ifdef IDCT_SCALING_SUPPORTED
! 
!   /* Compute actual output image dimensions and DCT scaling choices. */
!   if (cinfo->scale_num * 8 <= cinfo->scale_denom) {
!     /* Provide 1/8 scaling */
!     cinfo->output_width = (JDIMENSION)
!       jdiv_round_up((long) cinfo->image_width, 8L);
!     cinfo->output_height = (JDIMENSION)
!       jdiv_round_up((long) cinfo->image_height, 8L);
!     cinfo->min_DCT_scaled_size = 1;
!   } else if (cinfo->scale_num * 4 <= cinfo->scale_denom) {
!     /* Provide 1/4 scaling */
!     cinfo->output_width = (JDIMENSION)
!       jdiv_round_up((long) cinfo->image_width, 4L);
!     cinfo->output_height = (JDIMENSION)
!       jdiv_round_up((long) cinfo->image_height, 4L);
!     cinfo->min_DCT_scaled_size = 2;
!   } else if (cinfo->scale_num * 2 <= cinfo->scale_denom) {
!     /* Provide 1/2 scaling */
!     cinfo->output_width = (JDIMENSION)
!       jdiv_round_up((long) cinfo->image_width, 2L);
!     cinfo->output_height = (JDIMENSION)
!       jdiv_round_up((long) cinfo->image_height, 2L);
!     cinfo->min_DCT_scaled_size = 4;
!   } else {
!     /* Provide 1/1 scaling */
!     cinfo->output_width = cinfo->image_width;
!     cinfo->output_height = cinfo->image_height;
!     cinfo->min_DCT_scaled_size = DCTSIZE;
!   }
!   /* In selecting the actual DCT scaling for each component, we try to
!    * scale up the chroma components via IDCT scaling rather than upsampling.
!    * This saves time if the upsampler gets to use 1:1 scaling.
!    * Note this code assumes that the supported DCT scalings are powers of 2.
!    */
!   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
!        ci++, compptr++) {
!     int ssize = cinfo->min_DCT_scaled_size;
!     while (ssize < DCTSIZE &&
! 	   (compptr->h_samp_factor * ssize * 2 <=
! 	    cinfo->max_h_samp_factor * cinfo->min_DCT_scaled_size) &&
! 	   (compptr->v_samp_factor * ssize * 2 <=
! 	    cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size)) {
!       ssize = ssize * 2;
!     }
!     compptr->DCT_scaled_size = ssize;
!   }
! 
!   /* Recompute downsampled dimensions of components;
!    * application needs to know these if using raw downsampled data.
!    */
!   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
!        ci++, compptr++) {
!     /* Size in samples, after IDCT scaling */
!     compptr->downsampled_width = (JDIMENSION)
!       jdiv_round_up((long) cinfo->image_width *
! 		    (long) (compptr->h_samp_factor * compptr->DCT_scaled_size),
! 		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
!     compptr->downsampled_height = (JDIMENSION)
!       jdiv_round_up((long) cinfo->image_height *
! 		    (long) (compptr->v_samp_factor * compptr->DCT_scaled_size),
! 		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
!   }
! 
! #else /* !IDCT_SCALING_SUPPORTED */
! 
!   /* Hardwire it to "no scaling" */
!   cinfo->output_width = cinfo->image_width;
!   cinfo->output_height = cinfo->image_height;
!   /* jdinput.c has already initialized DCT_scaled_size to DCTSIZE,
!    * and has computed unscaled downsampled_width and downsampled_height.
!    */
! 
! #endif /* IDCT_SCALING_SUPPORTED */
  
    /* Report number of components in selected colorspace. */
    /* Probably this should be in the color conversion module... */
--- 85,95 ----
  jpeg_calc_output_dimensions (j_decompress_ptr cinfo)
  /* Do computations that are needed before master selection phase */
  {
    /* Prevent application from calling me at wrong times */
    if (cinfo->global_state != DSTATE_READY)
      ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  
!   (*cinfo->codec->calc_output_dimensions) (cinfo);
  
    /* Report number of components in selected colorspace. */
    /* Probably this should be in the color conversion module... */
***************
*** 288,294 ****
  master_selection (j_decompress_ptr cinfo)
  {
    my_master_ptr master = (my_master_ptr) cinfo->master;
-   boolean use_c_buffer;
    long samplesperrow;
    JDIMENSION jd_samplesperrow;
  
--- 211,216 ----
***************
*** 369,394 ****
      }
      jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);
    }
-   /* Inverse DCT */
-   jinit_inverse_dct(cinfo);
-   /* Entropy decoding: either Huffman or arithmetic coding. */
-   if (cinfo->arith_code) {
-     ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
-   } else {
-     if (cinfo->progressive_mode) {
- #ifdef D_PROGRESSIVE_SUPPORTED
-       jinit_phuff_decoder(cinfo);
- #else
-       ERREXIT(cinfo, JERR_NOT_COMPILED);
- #endif
-     } else
-       jinit_huff_decoder(cinfo);
-   }
  
    /* Initialize principal buffer controllers. */
-   use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;
-   jinit_d_coef_controller(cinfo, use_c_buffer);
- 
    if (! cinfo->raw_data_out)
      jinit_d_main_controller(cinfo, FALSE /* never need full buffer here */);
  
--- 291,298 ----
***************
*** 407,413 ****
        cinfo->inputctl->has_multiple_scans) {
      int nscans;
      /* Estimate number of scans to set pass_limit. */
!     if (cinfo->progressive_mode) {
        /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
        nscans = 2 + 3 * cinfo->num_components;
      } else {
--- 311,317 ----
        cinfo->inputctl->has_multiple_scans) {
      int nscans;
      /* Estimate number of scans to set pass_limit. */
!     if (cinfo->process == JPROC_PROGRESSIVE) {
        /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
        nscans = 2 + 3 * cinfo->num_components;
      } else {
***************
*** 461,468 ****
  	ERREXIT(cinfo, JERR_MODE_CHANGE);
        }
      }
!     (*cinfo->idct->start_pass) (cinfo);
!     (*cinfo->coef->start_output_pass) (cinfo);
      if (! cinfo->raw_data_out) {
        if (! master->using_merged_upsample)
  	(*cinfo->cconvert->start_pass) (cinfo);
--- 365,371 ----
  	ERREXIT(cinfo, JERR_MODE_CHANGE);
        }
      }
!     (*cinfo->codec->start_output_pass) (cinfo);
      if (! cinfo->raw_data_out) {
        if (! master->using_merged_upsample)
  	(*cinfo->cconvert->start_pass) (cinfo);
diff -cN ../jpeg-6b/jdphuff.c ./jdphuff.c
*** ../jpeg-6b/jdphuff.c	Mon Oct 20 20:42:33 1997
--- ./jdphuff.c	Tue Apr 27 14:58:30 1999
***************
*** 1,7 ****
  /*
   * jdphuff.c
   *
!  * Copyright (C) 1995-1997, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jdphuff.c
   *
!  * Copyright (C) 1995-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 17,29 ****
  #define JPEG_INTERNALS
  #include "jinclude.h"
  #include "jpeglib.h"
! #include "jdhuff.h"		/* Declarations shared with jdhuff.c */
  
  
  #ifdef D_PROGRESSIVE_SUPPORTED
  
  /*
!  * Expanded entropy decoder object for progressive Huffman decoding.
   *
   * The savable_state subrecord contains fields that change within an MCU,
   * but must not be updated permanently until we complete the MCU.
--- 17,30 ----
  #define JPEG_INTERNALS
  #include "jinclude.h"
  #include "jpeglib.h"
! #include "jlossy.h"		/* Private declarations for lossy subsystem */
! #include "jdhuff.h"		/* Declarations shared with jd*huff.c */
  
  
  #ifdef D_PROGRESSIVE_SUPPORTED
  
  /*
!  * Private entropy decoder object for progressive Huffman decoding.
   *
   * The savable_state subrecord contains fields that change within an MCU,
   * but must not be updated permanently until we complete the MCU.
***************
*** 54,65 ****
  
  
  typedef struct {
!   struct jpeg_entropy_decoder pub; /* public fields */
  
    /* These fields are loaded into local variables at start of each MCU.
     * In case of suspension, we exit WITHOUT updating them.
     */
-   bitread_perm_state bitstate;	/* Bit buffer at start of MCU */
    savable_state saved;		/* Other state at start of MCU */
  
    /* These fields are NOT loaded into local working state. */
--- 55,65 ----
  
  
  typedef struct {
!   huffd_common_fields;		/* Fields shared with other entropy decoders */
  
    /* These fields are loaded into local variables at start of each MCU.
     * In case of suspension, we exit WITHOUT updating them.
     */
    savable_state saved;		/* Other state at start of MCU */
  
    /* These fields are NOT loaded into local working state. */
***************
*** 91,97 ****
  METHODDEF(void)
  start_pass_phuff_decoder (j_decompress_ptr cinfo)
  {
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
    boolean is_DC_band, bad;
    int ci, coefi, tbl;
    int *coef_bit_ptr;
--- 91,98 ----
  METHODDEF(void)
  start_pass_phuff_decoder (j_decompress_ptr cinfo)
  {
!   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) lossyd->entropy_private;
    boolean is_DC_band, bad;
    int ci, coefi, tbl;
    int *coef_bit_ptr;
***************
*** 148,161 ****
    /* Select MCU decoding routine */
    if (cinfo->Ah == 0) {
      if (is_DC_band)
!       entropy->pub.decode_mcu = decode_mcu_DC_first;
      else
!       entropy->pub.decode_mcu = decode_mcu_AC_first;
    } else {
      if (is_DC_band)
!       entropy->pub.decode_mcu = decode_mcu_DC_refine;
      else
!       entropy->pub.decode_mcu = decode_mcu_AC_refine;
    }
  
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
--- 149,162 ----
    /* Select MCU decoding routine */
    if (cinfo->Ah == 0) {
      if (is_DC_band)
!       lossyd->entropy_decode_mcu = decode_mcu_DC_first;
      else
!       lossyd->entropy_decode_mcu = decode_mcu_AC_first;
    } else {
      if (is_DC_band)
!       lossyd->entropy_decode_mcu = decode_mcu_DC_refine;
      else
!       lossyd->entropy_decode_mcu = decode_mcu_AC_refine;
    }
  
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
***************
*** 183,189 ****
    /* Initialize bitread state variables */
    entropy->bitstate.bits_left = 0;
    entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
!   entropy->pub.insufficient_data = FALSE;
  
    /* Initialize private state variables */
    entropy->saved.EOBRUN = 0;
--- 184,190 ----
    /* Initialize bitread state variables */
    entropy->bitstate.bits_left = 0;
    entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
!   entropy->insufficient_data = FALSE;
  
    /* Initialize private state variables */
    entropy->saved.EOBRUN = 0;
***************
*** 227,233 ****
  LOCAL(boolean)
  process_restart (j_decompress_ptr cinfo)
  {
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
    int ci;
  
    /* Throw away any unused bits remaining in bit buffer; */
--- 228,235 ----
  LOCAL(boolean)
  process_restart (j_decompress_ptr cinfo)
  {
!   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) lossyd->entropy_private;
    int ci;
  
    /* Throw away any unused bits remaining in bit buffer; */
***************
*** 254,260 ****
     * leaving the flag set.
     */
    if (cinfo->unread_marker == 0)
!     entropy->pub.insufficient_data = FALSE;
  
    return TRUE;
  }
--- 256,262 ----
     * leaving the flag set.
     */
    if (cinfo->unread_marker == 0)
!     entropy->insufficient_data = FALSE;
  
    return TRUE;
  }
***************
*** 285,291 ****
  METHODDEF(boolean)
  decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
  {   
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
    int Al = cinfo->Al;
    register int s, r;
    int blkn, ci;
--- 287,294 ----
  METHODDEF(boolean)
  decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
  {   
!   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) lossyd->entropy_private;
    int Al = cinfo->Al;
    register int s, r;
    int blkn, ci;
***************
*** 305,311 ****
    /* If we've run out of data, just leave the MCU set to zeroes.
     * This way, we return uniform gray for the remainder of the segment.
     */
!   if (! entropy->pub.insufficient_data) {
  
      /* Load up working state */
      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
--- 308,314 ----
    /* If we've run out of data, just leave the MCU set to zeroes.
     * This way, we return uniform gray for the remainder of the segment.
     */
!   if (! entropy->insufficient_data) {
  
      /* Load up working state */
      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
***************
*** 313,319 ****
  
      /* Outer loop handles each block in the MCU */
  
!     for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
        block = MCU_data[blkn];
        ci = cinfo->MCU_membership[blkn];
        compptr = cinfo->cur_comp_info[ci];
--- 316,322 ----
  
      /* Outer loop handles each block in the MCU */
  
!     for (blkn = 0; blkn < cinfo->data_units_in_MCU; blkn++) {
        block = MCU_data[blkn];
        ci = cinfo->MCU_membership[blkn];
        compptr = cinfo->cur_comp_info[ci];
***************
*** 356,362 ****
  METHODDEF(boolean)
  decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
  {   
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
    int Se = cinfo->Se;
    int Al = cinfo->Al;
    register int s, k, r;
--- 359,366 ----
  METHODDEF(boolean)
  decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
  {   
!   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) lossyd->entropy_private;
    int Se = cinfo->Se;
    int Al = cinfo->Al;
    register int s, k, r;
***************
*** 375,381 ****
    /* If we've run out of data, just leave the MCU set to zeroes.
     * This way, we return uniform gray for the remainder of the segment.
     */
!   if (! entropy->pub.insufficient_data) {
  
      /* Load up working state.
       * We can avoid loading/saving bitread state if in an EOB run.
--- 379,385 ----
    /* If we've run out of data, just leave the MCU set to zeroes.
     * This way, we return uniform gray for the remainder of the segment.
     */
!   if (! entropy->insufficient_data) {
  
      /* Load up working state.
       * We can avoid loading/saving bitread state if in an EOB run.
***************
*** 441,447 ****
  METHODDEF(boolean)
  decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
  {   
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
    int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
    int blkn;
    JBLOCKROW block;
--- 445,452 ----
  METHODDEF(boolean)
  decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
  {   
!   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) lossyd->entropy_private;
    int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
    int blkn;
    JBLOCKROW block;
***************
*** 463,469 ****
  
    /* Outer loop handles each block in the MCU */
  
!   for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
      block = MCU_data[blkn];
  
      /* Encoded data is simply the next bit of the two's-complement DC value */
--- 468,474 ----
  
    /* Outer loop handles each block in the MCU */
  
!   for (blkn = 0; blkn < cinfo->data_units_in_MCU; blkn++) {
      block = MCU_data[blkn];
  
      /* Encoded data is simply the next bit of the two's-complement DC value */
***************
*** 490,496 ****
  METHODDEF(boolean)
  decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
  {   
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
    int Se = cinfo->Se;
    int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
    int m1 = (-1) << cinfo->Al;	/* -1 in the bit position being coded */
--- 495,502 ----
  METHODDEF(boolean)
  decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
  {   
!   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
!   phuff_entropy_ptr entropy = (phuff_entropy_ptr) lossyd->entropy_private;
    int Se = cinfo->Se;
    int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
    int m1 = (-1) << cinfo->Al;	/* -1 in the bit position being coded */
***************
*** 512,518 ****
  
    /* If we've run out of data, don't modify the MCU.
     */
!   if (! entropy->pub.insufficient_data) {
  
      /* Load up working state */
      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
--- 518,524 ----
  
    /* If we've run out of data, don't modify the MCU.
     */
!   if (! entropy->insufficient_data) {
  
      /* Load up working state */
      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
***************
*** 640,645 ****
--- 646,652 ----
  GLOBAL(void)
  jinit_phuff_decoder (j_decompress_ptr cinfo)
  {
+   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
    phuff_entropy_ptr entropy;
    int *coef_bit_ptr;
    int ci, i;
***************
*** 647,654 ****
    entropy = (phuff_entropy_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
  				SIZEOF(phuff_entropy_decoder));
!   cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
!   entropy->pub.start_pass = start_pass_phuff_decoder;
  
    /* Mark derived tables unallocated */
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
--- 654,661 ----
    entropy = (phuff_entropy_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
  				SIZEOF(phuff_entropy_decoder));
!   lossyd->entropy_private = (void *) entropy;
!   lossyd->entropy_start_pass = start_pass_phuff_decoder;
  
    /* Mark derived tables unallocated */
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
diff -cN ../jpeg-6b/jdpred.c ./jdpred.c
*** ../jpeg-6b/jdpred.c
--- ./jdpred.c	Tue Apr 27 14:58:30 1999
***************
*** 0 ****
--- 1,247 ----
+ /*
+  * jdpred.c
+  *
+  * Copyright (C) 1998, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+  * This file contains sample undifferencing (reconstruction) for lossless JPEG.
+  *
+  * In order to avoid paying the performance penalty of having to check the
+  * predictor being used and the row being processed for each call of the
+  * undifferencer, and to promote optimization, we have separate undifferencing
+  * functions for each case.
+  *
+  * We are able to avoid duplicating source code by implementing the predictors
+  * and undifferencers as macros.  Each of the undifferencing functions are
+  * simply wrappers around an UNDIFFERENCE macro with the appropriate PREDICTOR
+  * macro passed as an argument.
+  */
+ 
+ #define JPEG_INTERNALS
+ #include "jinclude.h"
+ #include "jpeglib.h"
+ #include "jlossls.h"		/* Private declarations for lossless codec */
+ 
+ 
+ #ifdef D_LOSSLESS_SUPPORTED
+ 
+ /* Predictor for the first column of the first row: 2^(P-Pt-1) */
+ #define INITIAL_PREDICTORx	(1 << (cinfo->data_precision - cinfo->Al - 1))
+ 
+ /* Predictor for the first column of the remaining rows: Rb */
+ #define INITIAL_PREDICTOR2	GETJSAMPLE(prev_row[0])
+ 
+ 
+ /*
+  * 1-Dimensional undifferencer routine.
+  *
+  * This macro implements the 1-D horizontal predictor (1).  INITIAL_PREDICTOR
+  * is used as the special case predictor for the first column, which must be
+  * either INITIAL_PREDICTOR2 or INITIAL_PREDICTORx.  The remaining samples
+  * use PREDICTOR1.
+  *
+  * The reconstructed sample is supposed to be calculated modulo 2^16, so we
+  * logically AND the result with 0xFFFF.
+ */
+ 
+ #define UNDIFFERENCE_1D(INITIAL_PREDICTOR) \
+ 	int xindex; \
+ 	int Ra; \
+  \
+ 	Ra = (diff_buf[0] + INITIAL_PREDICTOR) & 0xFFFF; \
+ 	undiff_buf[0] = Ra; \
+  \
+ 	for (xindex = 1; xindex < width; xindex++) { \
+ 	  Ra = (diff_buf[xindex] + PREDICTOR1) & 0xFFFF; \
+ 	  undiff_buf[xindex] = Ra; \
+ 	}
+ 
+ /*
+  * 2-Dimensional undifferencer routine.
+  *
+  * This macro implements the 2-D horizontal predictors (#2-7).  PREDICTOR2 is
+  * used as the special case predictor for the first column.  The remaining
+  * samples use PREDICTOR, which is a function of Ra, Rb, Rc.
+  *
+  * Because prev_row and output_buf may point to the same storage area (in an
+  * interleaved image with Vi=1, for example), we must take care to buffer Rb/Rc
+  * before writing the current reconstructed sample value into output_buf.
+  *
+  * The reconstructed sample is supposed to be calculated modulo 2^16, so we
+  * logically AND the result with 0xFFFF.
+  */
+ 
+ #define UNDIFFERENCE_2D(PREDICTOR) \
+ 	int xindex; \
+ 	int Ra, Rb, Rc; \
+  \
+ 	Rb = GETJSAMPLE(prev_row[0]); \
+ 	Ra = (diff_buf[0] + PREDICTOR2) & 0xFFFF; \
+ 	undiff_buf[0] = Ra; \
+  \
+ 	for (xindex = 1; xindex < width; xindex++) { \
+ 	  Rc = Rb; \
+ 	  Rb = GETJSAMPLE(prev_row[xindex]); \
+ 	  Ra = (diff_buf[xindex] + PREDICTOR) & 0xFFFF; \
+ 	  undiff_buf[xindex] = Ra; \
+ 	}
+ 
+ 
+ /*
+  * Undifferencers for the all rows but the first in a scan or restart interval.
+  * The first sample in the row is undifferenced using the vertical
+  * predictor (2).  The rest of the samples are undifferenced using the
+  * predictor specified in the scan header.
+  */
+ 
+ METHODDEF(void)
+ jpeg_undifference1(j_decompress_ptr cinfo, int comp_index,
+ 		   JDIFFROW diff_buf, JDIFFROW prev_row,
+ 		   JDIFFROW undiff_buf, JDIMENSION width)
+ {
+   UNDIFFERENCE_1D(INITIAL_PREDICTOR2);
+ }
+ 
+ METHODDEF(void)
+ jpeg_undifference2(j_decompress_ptr cinfo, int comp_index,
+ 		   JDIFFROW diff_buf, JDIFFROW prev_row,
+ 		   JDIFFROW undiff_buf, JDIMENSION width)
+ {
+   UNDIFFERENCE_2D(PREDICTOR2);
+ }
+ 
+ METHODDEF(void)
+ jpeg_undifference3(j_decompress_ptr cinfo, int comp_index,
+ 		   JDIFFROW diff_buf, JDIFFROW prev_row,
+ 		   JDIFFROW undiff_buf, JDIMENSION width)
+ {
+   UNDIFFERENCE_2D(PREDICTOR3);
+ }
+ 
+ METHODDEF(void)
+ jpeg_undifference4(j_decompress_ptr cinfo, int comp_index,
+ 		   JDIFFROW diff_buf, JDIFFROW prev_row,
+ 		   JDIFFROW undiff_buf, JDIMENSION width)
+ {
+   UNDIFFERENCE_2D(PREDICTOR4);
+ }
+ 
+ METHODDEF(void)
+ jpeg_undifference5(j_decompress_ptr cinfo, int comp_index,
+ 		   JDIFFROW diff_buf, JDIFFROW prev_row,
+ 		   JDIFFROW undiff_buf, JDIMENSION width)
+ {
+   UNDIFFERENCE_2D(PREDICTOR5);
+ }
+ 
+ METHODDEF(void)
+ jpeg_undifference6(j_decompress_ptr cinfo, int comp_index,
+ 		   JDIFFROW diff_buf, JDIFFROW prev_row,
+ 		   JDIFFROW undiff_buf, JDIMENSION width)
+ {
+   UNDIFFERENCE_2D(PREDICTOR6);
+ }
+ 
+ METHODDEF(void)
+ jpeg_undifference7(j_decompress_ptr cinfo, int comp_index,
+ 		   JDIFFROW diff_buf, JDIFFROW prev_row,
+ 		   JDIFFROW undiff_buf, JDIMENSION width)
+ {
+   UNDIFFERENCE_2D(PREDICTOR7);
+ }
+ 
+ 
+ /*
+  * Undifferencer for the first row in a scan or restart interval.  The first
+  * sample in the row is undifferenced using the special predictor constant
+  * x=2^(P-Pt-1).  The rest of the samples are undifferenced using the
+  * 1-D horizontal predictor (1).
+  */
+ 
+ METHODDEF(void)
+ jpeg_undifference_first_row(j_decompress_ptr cinfo, int comp_index,
+ 			    JDIFFROW diff_buf, JDIFFROW prev_row,
+ 			    JDIFFROW undiff_buf, JDIMENSION width)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+ 
+   UNDIFFERENCE_1D(INITIAL_PREDICTORx);
+ 
+   /*
+    * Now that we have undifferenced the first row, we want to use the
+    * undifferencer which corresponds to the predictor specified in the
+    * scan header.
+    */
+   switch (cinfo->Ss) {
+   case 1:
+     losslsd->predict_undifference[comp_index] = jpeg_undifference1;
+     break;
+   case 2:
+     losslsd->predict_undifference[comp_index] = jpeg_undifference2;
+     break;
+   case 3:
+     losslsd->predict_undifference[comp_index] = jpeg_undifference3;
+     break;
+   case 4:
+     losslsd->predict_undifference[comp_index] = jpeg_undifference4;
+     break;
+   case 5:
+     losslsd->predict_undifference[comp_index] = jpeg_undifference5;
+     break;
+   case 6:
+     losslsd->predict_undifference[comp_index] = jpeg_undifference6;
+     break;
+   case 7:
+     losslsd->predict_undifference[comp_index] = jpeg_undifference7;
+     break;
+   }
+ }
+ 
+ 
+ /*
+  * Initialize for an input processing pass.
+  */
+ 
+ METHODDEF(void)
+ predict_start_pass (j_decompress_ptr cinfo)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+   int ci;
+ 
+   /* Check that the scan parameters Ss, Se, Ah, Al are OK for lossless JPEG.
+    *
+    * Ss is the predictor selection value (psv).  Legal values for sequential
+    * lossless JPEG are: 1 <= psv <= 7.
+    *
+    * Se and Ah are not used and should be zero.
+    *
+    * Al specifies the point transform (Pt).  Legal values are: 0 <= Pt <= 15.
+    */
+   if (cinfo->Ss < 1 || cinfo->Ss > 7 ||
+       cinfo->Se != 0 || cinfo->Ah != 0 ||
+       cinfo->Al > 15)				/* need not check for < 0 */
+     ERREXIT4(cinfo, JERR_BAD_LOSSLESS,
+ 	     cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);
+ 
+   /* Set undifference functions to first row function */
+   for (ci = 0; ci < cinfo->num_components; ci++)
+     losslsd->predict_undifference[ci] = jpeg_undifference_first_row;
+ }
+ 
+ 
+ /*
+  * Module initialization routine for the undifferencer.
+  */
+ 
+ GLOBAL(void)
+ jinit_undifferencer (j_decompress_ptr cinfo)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+ 
+   losslsd->predict_start_pass = predict_start_pass;
+   losslsd->predict_process_restart = predict_start_pass;
+ }
+ 
+ #endif /* D_LOSSLESS_SUPPORTED */
+ 
diff -cN ../jpeg-6b/jdsample.c ./jdsample.c
*** ../jpeg-6b/jdsample.c	Sat Jan  6 18:27:47 1996
--- ./jdsample.c	Tue Apr 27 14:58:31 1999
***************
*** 1,7 ****
  /*
   * jdsample.c
   *
!  * Copyright (C) 1991-1996, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jdsample.c
   *
!  * Copyright (C) 1991-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 8,14 ****
   * This file contains upsampling routines.
   *
   * Upsampling input data is counted in "row groups".  A row group
!  * is defined to be (v_samp_factor * DCT_scaled_size / min_DCT_scaled_size)
   * sample rows of each component.  Upsampling will normally produce
   * max_v_samp_factor pixel rows from each row group (but this could vary
   * if the upsampler is applying a scale factor of its own).
--- 8,14 ----
   * This file contains upsampling routines.
   *
   * Upsampling input data is counted in "row groups".  A row group
!  * is defined to be (v_samp_factor * codec_data_unit / min_codec_data_unit)
   * sample rows of each component.  Upsampling will normally produce
   * max_v_samp_factor pixel rows from each row group (but this could vary
   * if the upsampler is applying a scale factor of its own).
***************
*** 415,424 ****
    if (cinfo->CCIR601_sampling)	/* this isn't supported */
      ERREXIT(cinfo, JERR_CCIR601_NOTIMPL);
  
!   /* jdmainct.c doesn't support context rows when min_DCT_scaled_size = 1,
     * so don't ask for it.
     */
!   do_fancy = cinfo->do_fancy_upsampling && cinfo->min_DCT_scaled_size > 1;
  
    /* Verify we can handle the sampling factors, select per-component methods,
     * and create storage as needed.
--- 415,424 ----
    if (cinfo->CCIR601_sampling)	/* this isn't supported */
      ERREXIT(cinfo, JERR_CCIR601_NOTIMPL);
  
!   /* jdmainct.c doesn't support context rows when min_codec_data_unit = 1,
     * so don't ask for it.
     */
!   do_fancy = cinfo->do_fancy_upsampling && cinfo->min_codec_data_unit > 1;
  
    /* Verify we can handle the sampling factors, select per-component methods,
     * and create storage as needed.
***************
*** 428,437 ****
      /* Compute size of an "input group" after IDCT scaling.  This many samples
       * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.
       */
!     h_in_group = (compptr->h_samp_factor * compptr->DCT_scaled_size) /
! 		 cinfo->min_DCT_scaled_size;
!     v_in_group = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
! 		 cinfo->min_DCT_scaled_size;
      h_out_group = cinfo->max_h_samp_factor;
      v_out_group = cinfo->max_v_samp_factor;
      upsample->rowgroup_height[ci] = v_in_group; /* save for use later */
--- 428,437 ----
      /* Compute size of an "input group" after IDCT scaling.  This many samples
       * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.
       */
!     h_in_group = (compptr->h_samp_factor * compptr->codec_data_unit) /
! 		 cinfo->min_codec_data_unit;
!     v_in_group = (compptr->v_samp_factor * compptr->codec_data_unit) /
! 		 cinfo->min_codec_data_unit;
      h_out_group = cinfo->max_h_samp_factor;
      v_out_group = cinfo->max_v_samp_factor;
      upsample->rowgroup_height[ci] = v_in_group; /* save for use later */
diff -cN ../jpeg-6b/jdscale.c ./jdscale.c
*** ../jpeg-6b/jdscale.c
--- ./jdscale.c	Tue Apr 27 14:58:31 1999
***************
*** 0 ****
--- 1,118 ----
+ /*
+  * jdscale.c
+  *
+  * Copyright (C) 1998, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+  * This file contains sample scaling for lossless JPEG.  This is a
+  * combination of upscaling the undifferenced sample by 2^Pt and downscaling
+  * the sample to fit into JSAMPLE.
+  */
+ 
+ #define JPEG_INTERNALS
+ #include "jinclude.h"
+ #include "jpeglib.h"
+ #include "jlossls.h"		/* Private declarations for lossless codec */
+ 
+ 
+ #ifdef D_LOSSLESS_SUPPORTED
+ 
+ /*
+  * Private scaler object for lossless decoding.
+  */
+ 
+ typedef struct {
+   int scale_factor;
+ } scaler;
+ 
+ typedef scaler * scaler_ptr;
+ 
+ 
+ /*
+  * Scalers for packing sample differences into JSAMPLEs.
+  */
+ 
+ METHODDEF(void)
+ simple_upscale(j_decompress_ptr cinfo,
+ 	       JDIFFROW diff_buf, JSAMPROW output_buf,
+ 	       JDIMENSION width)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+   scaler_ptr scaler = (scaler_ptr) losslsd->scaler_private;
+   int scale_factor = scaler->scale_factor;
+   int xindex;
+ 
+   for (xindex = 0; xindex < width; xindex++)
+     output_buf[xindex] = (JSAMPLE) (diff_buf[xindex] << scale_factor);
+ }
+ 
+ METHODDEF(void)
+ simple_downscale(j_decompress_ptr cinfo,
+ 		 JDIFFROW diff_buf, JSAMPROW output_buf,
+ 		 JDIMENSION width)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+   scaler_ptr scaler = (scaler_ptr) losslsd->scaler_private;
+   int scale_factor = scaler->scale_factor;
+   int xindex;
+ 
+   for (xindex = 0; xindex < width; xindex++)
+     output_buf[xindex] = (JSAMPLE) RIGHT_SHIFT(diff_buf[xindex], scale_factor);
+ }
+ 
+ METHODDEF(void)
+ noscale(j_decompress_ptr cinfo,
+ 	JDIFFROW diff_buf, JSAMPROW output_buf,
+ 	JDIMENSION width)
+ {
+   int xindex;
+ 
+   for (xindex = 0; xindex < width; xindex++)
+     output_buf[xindex] = (JSAMPLE) diff_buf[xindex];
+ }
+ 
+ 
+ METHODDEF(void)
+ scaler_start_pass (j_decompress_ptr cinfo)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+   scaler_ptr scaler = (scaler_ptr) losslsd->scaler_private;
+   int downscale;
+ 
+   /*
+    * Downscale by the difference in the input vs. output precision.  If the
+    * output precision >= input precision, then do not downscale.
+    */
+   downscale = BITS_IN_JSAMPLE < cinfo->data_precision ?
+     cinfo->data_precision - BITS_IN_JSAMPLE : 0;
+ 
+   scaler->scale_factor = cinfo->Al - downscale;
+ 
+   /* Set scaler functions based on scale_factor (positive = left shift) */
+   if (scaler->scale_factor > 0)
+     losslsd->scaler_scale = simple_upscale;
+   else if (scaler->scale_factor < 0) {
+     scaler->scale_factor = -scaler->scale_factor;
+     losslsd->scaler_scale = simple_downscale;
+   }
+   else
+     losslsd->scaler_scale = noscale;
+ }
+ 
+ 
+ GLOBAL(void)
+ jinit_d_scaler (j_decompress_ptr cinfo)
+ {
+   j_lossless_d_ptr losslsd = (j_lossless_d_ptr) cinfo->codec;
+   scaler_ptr scaler;
+ 
+   scaler = (scaler_ptr)
+     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
+ 				SIZEOF(scaler));
+   losslsd->scaler_private = (void *) scaler;
+   losslsd->scaler_start_pass = scaler_start_pass;
+ }
+ 
+ #endif /* D_LOSSLESS_SUPPORTED */
+ 
diff -cN ../jpeg-6b/jdshuff.c ./jdshuff.c
*** ../jpeg-6b/jdshuff.c
--- ./jdshuff.c	Tue Apr 27 14:58:31 1999
***************
*** 0 ****
--- 1,360 ----
+ /*
+  * jdshuff.c
+  *
+  * Copyright (C) 1991-1998, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+  * This file contains Huffman entropy decoding routines for sequential JPEG.
+  *
+  * Much of the complexity here has to do with supporting input suspension.
+  * If the data source module demands suspension, we want to be able to back
+  * up to the start of the current MCU.  To do this, we copy state variables
+  * into local working storage, and update them back to the permanent
+  * storage only upon successful completion of an MCU.
+  */
+ 
+ #define JPEG_INTERNALS
+ #include "jinclude.h"
+ #include "jpeglib.h"
+ #include "jlossy.h"		/* Private declarations for lossy codec */
+ #include "jdhuff.h"		/* Declarations shared with jd*huff.c */
+ 
+ 
+ /*
+  * Private entropy decoder object for Huffman decoding.
+  *
+  * The savable_state subrecord contains fields that change within an MCU,
+  * but must not be updated permanently until we complete the MCU.
+  */
+ 
+ typedef struct {
+   int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */
+ } savable_state;
+ 
+ /* This macro is to work around compilers with missing or broken
+  * structure assignment.  You'll need to fix this code if you have
+  * such a compiler and you change MAX_COMPS_IN_SCAN.
+  */
+ 
+ #ifndef NO_STRUCT_ASSIGN
+ #define ASSIGN_STATE(dest,src)  ((dest) = (src))
+ #else
+ #if MAX_COMPS_IN_SCAN == 4
+ #define ASSIGN_STATE(dest,src)  \
+ 	((dest).last_dc_val[0] = (src).last_dc_val[0], \
+ 	 (dest).last_dc_val[1] = (src).last_dc_val[1], \
+ 	 (dest).last_dc_val[2] = (src).last_dc_val[2], \
+ 	 (dest).last_dc_val[3] = (src).last_dc_val[3])
+ #endif
+ #endif
+ 
+ 
+ typedef struct {
+   huffd_common_fields;		/* Fields shared with other entropy decoders */
+ 
+   /* These fields are loaded into local variables at start of each MCU.
+    * In case of suspension, we exit WITHOUT updating them.
+    */
+   savable_state saved;		/* Other state at start of MCU */
+ 
+   /* These fields are NOT loaded into local working state. */
+   unsigned int restarts_to_go;	/* MCUs left in this restart interval */
+ 
+   /* Pointers to derived tables (these workspaces have image lifespan) */
+   d_derived_tbl * dc_derived_tbls[NUM_HUFF_TBLS];
+   d_derived_tbl * ac_derived_tbls[NUM_HUFF_TBLS];
+ 
+   /* Precalculated info set up by start_pass for use in decode_mcu: */
+ 
+   /* Pointers to derived tables to be used for each block within an MCU */
+   d_derived_tbl * dc_cur_tbls[D_MAX_DATA_UNITS_IN_MCU];
+   d_derived_tbl * ac_cur_tbls[D_MAX_DATA_UNITS_IN_MCU];
+   /* Whether we care about the DC and AC coefficient values for each block */
+   boolean dc_needed[D_MAX_DATA_UNITS_IN_MCU];
+   boolean ac_needed[D_MAX_DATA_UNITS_IN_MCU];
+ } shuff_entropy_decoder;
+ 
+ typedef shuff_entropy_decoder * shuff_entropy_ptr;
+ 
+ 
+ /*
+  * Initialize for a Huffman-compressed scan.
+  */
+ 
+ METHODDEF(void)
+ start_pass_huff_decoder (j_decompress_ptr cinfo)
+ {
+   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
+   shuff_entropy_ptr entropy = (shuff_entropy_ptr) lossyd->entropy_private;
+   int ci, blkn, dctbl, actbl;
+   jpeg_component_info * compptr;
+ 
+   /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
+    * This ought to be an error condition, but we make it a warning because
+    * there are some baseline files out there with all zeroes in these bytes.
+    */
+   if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2-1 ||
+       cinfo->Ah != 0 || cinfo->Al != 0)
+     WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);
+ 
+   for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
+     compptr = cinfo->cur_comp_info[ci];
+     dctbl = compptr->dc_tbl_no;
+     actbl = compptr->ac_tbl_no;
+     /* Compute derived values for Huffman tables */
+     /* We may do this more than once for a table, but it's not expensive */
+     jpeg_make_d_derived_tbl(cinfo, TRUE, dctbl,
+ 			    & entropy->dc_derived_tbls[dctbl]);
+     jpeg_make_d_derived_tbl(cinfo, FALSE, actbl,
+ 			    & entropy->ac_derived_tbls[actbl]);
+     /* Initialize DC predictions to 0 */
+     entropy->saved.last_dc_val[ci] = 0;
+   }
+ 
+   /* Precalculate decoding info for each block in an MCU of this scan */
+   for (blkn = 0; blkn < cinfo->data_units_in_MCU; blkn++) {
+     ci = cinfo->MCU_membership[blkn];
+     compptr = cinfo->cur_comp_info[ci];
+     /* Precalculate which table to use for each block */
+     entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
+     entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
+     /* Decide whether we really care about the coefficient values */
+     if (compptr->component_needed) {
+       entropy->dc_needed[blkn] = TRUE;
+       /* we don't need the ACs if producing a 1/8th-size image */
+       entropy->ac_needed[blkn] = (compptr->codec_data_unit > 1);
+     } else {
+       entropy->dc_needed[blkn] = entropy->ac_needed[blkn] = FALSE;
+     }
+   }
+ 
+   /* Initialize bitread state variables */
+   entropy->bitstate.bits_left = 0;
+   entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
+   entropy->insufficient_data = FALSE;
+ 
+   /* Initialize restart counter */
+   entropy->restarts_to_go = cinfo->restart_interval;
+ }
+ 
+ 
+ /*
+  * Figure F.12: extend sign bit.
+  * On some machines, a shift and add will be faster than a table lookup.
+  */
+ 
+ #ifdef AVOID_TABLES
+ 
+ #define HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) + (((-1)<<(s)) + 1) : (x))
+ 
+ #else
+ 
+ #define HUFF_EXTEND(x,s)  ((x) < extend_test[s] ? (x) + extend_offset[s] : (x))
+ 
+ static const int extend_test[16] =   /* entry n is 2**(n-1) */
+   { 0, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
+     0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000 };
+ 
+ static const int extend_offset[16] = /* entry n is (-1 << n) + 1 */
+   { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
+     ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
+     ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
+     ((-1)<<13) + 1, ((-1)<<14) + 1, ((-1)<<15) + 1 };
+ 
+ #endif /* AVOID_TABLES */
+ 
+ 
+ /*
+  * Check for a restart marker & resynchronize decoder.
+  * Returns FALSE if must suspend.
+  */
+ 
+ LOCAL(boolean)
+ process_restart (j_decompress_ptr cinfo)
+ {
+   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
+   shuff_entropy_ptr entropy = (shuff_entropy_ptr) lossyd->entropy_private;
+   int ci;
+ 
+   /* Throw away any unused bits remaining in bit buffer; */
+   /* include any full bytes in next_marker's count of discarded bytes */
+   cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
+   entropy->bitstate.bits_left = 0;
+ 
+   /* Advance past the RSTn marker */
+   if (! (*cinfo->marker->read_restart_marker) (cinfo))
+     return FALSE;
+ 
+   /* Re-initialize DC predictions to 0 */
+   for (ci = 0; ci < cinfo->comps_in_scan; ci++)
+     entropy->saved.last_dc_val[ci] = 0;
+ 
+   /* Reset restart counter */
+   entropy->restarts_to_go = cinfo->restart_interval;
+ 
+   /* Reset out-of-data flag, unless read_restart_marker left us smack up
+    * against a marker.  In that case we will end up treating the next data
+    * segment as empty, and we can avoid producing bogus output pixels by
+    * leaving the flag set.
+    */
+   if (cinfo->unread_marker == 0)
+     entropy->insufficient_data = FALSE;
+ 
+   return TRUE;
+ }
+ 
+ 
+ /*
+  * Decode and return one MCU's worth of Huffman-compressed coefficients.
+  * The coefficients are reordered from zigzag order into natural array order,
+  * but are not dequantized.
+  *
+  * The i'th block of the MCU is stored into the block pointed to by
+  * MCU_data[i].  WE ASSUME THIS AREA HAS BEEN ZEROED BY THE CALLER.
+  * (Wholesale zeroing is usually a little faster than retail...)
+  *
+  * Returns FALSE if data source requested suspension.  In that case no
+  * changes have been made to permanent state.  (Exception: some output
+  * coefficients may already have been assigned.  This is harmless for
+  * this module, since we'll just re-assign them on the next call.)
+  */
+ 
+ METHODDEF(boolean)
+ decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
+ {
+   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
+   shuff_entropy_ptr entropy = (shuff_entropy_ptr) lossyd->entropy_private;
+   int blkn;
+   BITREAD_STATE_VARS;
+   savable_state state;
+ 
+   /* Process restart marker if needed; may have to suspend */
+   if (cinfo->restart_interval) {
+     if (entropy->restarts_to_go == 0)
+       if (! process_restart(cinfo))
+ 	return FALSE;
+   }
+ 
+   /* If we've run out of data, just leave the MCU set to zeroes.
+    * This way, we return uniform gray for the remainder of the segment.
+    */
+   if (! entropy->insufficient_data) {
+ 
+     /* Load up working state */
+     BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
+     ASSIGN_STATE(state, entropy->saved);
+ 
+     /* Outer loop handles each block in the MCU */
+ 
+     for (blkn = 0; blkn < cinfo->data_units_in_MCU; blkn++) {
+       JBLOCKROW block = MCU_data[blkn];
+       d_derived_tbl * dctbl = entropy->dc_cur_tbls[blkn];
+       d_derived_tbl * actbl = entropy->ac_cur_tbls[blkn];
+       register int s, k, r;
+ 
+       /* Decode a single block's worth of coefficients */
+ 
+       /* Section F.2.2.1: decode the DC coefficient difference */
+       HUFF_DECODE(s, br_state, dctbl, return FALSE, label1);
+       if (s) {
+ 	CHECK_BIT_BUFFER(br_state, s, return FALSE);
+ 	r = GET_BITS(s);
+ 	s = HUFF_EXTEND(r, s);
+       }
+ 
+       if (entropy->dc_needed[blkn]) {
+ 	/* Convert DC difference to actual value, update last_dc_val */
+ 	int ci = cinfo->MCU_membership[blkn];
+ 	s += state.last_dc_val[ci];
+ 	state.last_dc_val[ci] = s;
+ 	/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */
+ 	(*block)[0] = (JCOEF) s;
+       }
+ 
+       if (entropy->ac_needed[blkn]) {
+ 
+ 	/* Section F.2.2.2: decode the AC coefficients */
+ 	/* Since zeroes are skipped, output area must be cleared beforehand */
+ 	for (k = 1; k < DCTSIZE2; k++) {
+ 	  HUFF_DECODE(s, br_state, actbl, return FALSE, label2);
+       
+ 	  r = s >> 4;
+ 	  s &= 15;
+       
+ 	  if (s) {
+ 	    k += r;
+ 	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
+ 	    r = GET_BITS(s);
+ 	    s = HUFF_EXTEND(r, s);
+ 	    /* Output coefficient in natural (dezigzagged) order.
+ 	     * Note: the extra entries in jpeg_natural_order[] will save us
+ 	     * if k >= DCTSIZE2, which could happen if the data is corrupted.
+ 	     */
+ 	    (*block)[jpeg_natural_order[k]] = (JCOEF) s;
+ 	  } else {
+ 	    if (r != 15)
+ 	      break;
+ 	    k += 15;
+ 	  }
+ 	}
+ 
+       } else {
+ 
+ 	/* Section F.2.2.2: decode the AC coefficients */
+ 	/* In this path we just discard the values */
+ 	for (k = 1; k < DCTSIZE2; k++) {
+ 	  HUFF_DECODE(s, br_state, actbl, return FALSE, label3);
+       
+ 	  r = s >> 4;
+ 	  s &= 15;
+       
+ 	  if (s) {
+ 	    k += r;
+ 	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
+ 	    DROP_BITS(s);
+ 	  } else {
+ 	    if (r != 15)
+ 	      break;
+ 	    k += 15;
+ 	  }
+ 	}
+ 
+       }
+     }
+ 
+     /* Completed MCU, so update state */
+     BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
+     ASSIGN_STATE(entropy->saved, state);
+   }
+ 
+   /* Account for restart interval (no-op if not using restarts) */
+   entropy->restarts_to_go--;
+ 
+   return TRUE;
+ }
+ 
+ 
+ /*
+  * Module initialization routine for Huffman entropy decoding.
+  */
+ 
+ GLOBAL(void)
+ jinit_shuff_decoder (j_decompress_ptr cinfo)
+ {
+   j_lossy_d_ptr lossyd = (j_lossy_d_ptr) cinfo->codec;
+   shuff_entropy_ptr entropy;
+   int i;
+ 
+   entropy = (shuff_entropy_ptr)
+     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
+ 				SIZEOF(shuff_entropy_decoder));
+   lossyd->entropy_private = (void *) entropy;
+   lossyd->entropy_start_pass = start_pass_huff_decoder;
+   lossyd->entropy_decode_mcu = decode_mcu;
+ 
+   /* Mark tables unallocated */
+   for (i = 0; i < NUM_HUFF_TBLS; i++) {
+     entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
+   }
+ }
diff -cN ../jpeg-6b/jdtrans.c ./jdtrans.c
*** ../jpeg-6b/jdtrans.c	Sun Aug  3 17:47:58 1997
--- ./jdtrans.c	Tue Apr 27 14:58:31 1999
***************
*** 1,7 ****
  /*
   * jdtrans.c
   *
!  * Copyright (C) 1995-1997, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jdtrans.c
   *
!  * Copyright (C) 1995-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 13,18 ****
--- 13,19 ----
  #define JPEG_INTERNALS
  #include "jinclude.h"
  #include "jpeglib.h"
+ #include "jlossy.h"
  
  
  /* Forward declarations */
***************
*** 44,49 ****
--- 45,58 ----
  GLOBAL(jvirt_barray_ptr *)
  jpeg_read_coefficients (j_decompress_ptr cinfo)
  {
+   j_lossy_d_ptr decomp;
+ 
+   /* Can't read coefficients from lossless streams */
+   if (cinfo->process == JPROC_LOSSLESS) {
+     ERREXIT(cinfo, JERR_CANT_TRANSCODE);
+     return NULL;
+   }
+ 
    if (cinfo->global_state == DSTATE_READY) {
      /* First call: initialize active modules */
      transdecode_master_selection(cinfo);
***************
*** 80,86 ****
     */
    if ((cinfo->global_state == DSTATE_STOPPING ||
         cinfo->global_state == DSTATE_BUFIMAGE) && cinfo->buffered_image) {
!     return cinfo->coef->coef_arrays;
    }
    /* Oops, improper usage */
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
--- 89,95 ----
     */
    if ((cinfo->global_state == DSTATE_STOPPING ||
         cinfo->global_state == DSTATE_BUFIMAGE) && cinfo->buffered_image) {
!     return ((j_lossy_d_ptr) cinfo->codec)->coef_arrays;
    }
    /* Oops, improper usage */
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
***************
*** 99,120 ****
    /* This is effectively a buffered-image operation. */
    cinfo->buffered_image = TRUE;
  
!   /* Entropy decoding: either Huffman or arithmetic coding. */
!   if (cinfo->arith_code) {
!     ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
!   } else {
!     if (cinfo->progressive_mode) {
! #ifdef D_PROGRESSIVE_SUPPORTED
!       jinit_phuff_decoder(cinfo);
! #else
!       ERREXIT(cinfo, JERR_NOT_COMPILED);
! #endif
!     } else
!       jinit_huff_decoder(cinfo);
!   }
! 
!   /* Always get a full-image coefficient buffer. */
!   jinit_d_coef_controller(cinfo, TRUE);
  
    /* We can now tell the memory manager to allocate virtual arrays. */
    (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
--- 108,115 ----
    /* This is effectively a buffered-image operation. */
    cinfo->buffered_image = TRUE;
  
!   /* Initialize decompression codec */
!   jinit_d_codec(cinfo);
  
    /* We can now tell the memory manager to allocate virtual arrays. */
    (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
***************
*** 126,132 ****
    if (cinfo->progress != NULL) {
      int nscans;
      /* Estimate number of scans to set pass_limit. */
!     if (cinfo->progressive_mode) {
        /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
        nscans = 2 + 3 * cinfo->num_components;
      } else if (cinfo->inputctl->has_multiple_scans) {
--- 121,127 ----
    if (cinfo->progress != NULL) {
      int nscans;
      /* Estimate number of scans to set pass_limit. */
!     if (cinfo->process == JPROC_PROGRESSIVE) {
        /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
        nscans = 2 + 3 * cinfo->num_components;
      } else if (cinfo->inputctl->has_multiple_scans) {
diff -cN ../jpeg-6b/jerror.h ./jerror.h
*** ../jpeg-6b/jerror.h	Sat Oct 18 14:59:10 1997
--- ./jerror.h	Tue Apr 27 14:58:32 1999
***************
*** 1,7 ****
  /*
   * jerror.h
   *
!  * Copyright (C) 1994-1997, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jerror.h
   *
!  * Copyright (C) 1994-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 47,52 ****
--- 47,53 ----
  JMESSAGE(JERR_BAD_COMPONENT_ID, "Invalid component ID %d in SOS")
  JMESSAGE(JERR_BAD_DCT_COEF, "DCT coefficient out of range")
  JMESSAGE(JERR_BAD_DCTSIZE, "IDCT output block size %d not supported")
+ JMESSAGE(JERR_BAD_DIFF, "spatial difference out of range")
  JMESSAGE(JERR_BAD_HUFF_TABLE, "Bogus Huffman table definition")
  JMESSAGE(JERR_BAD_IN_COLORSPACE, "Bogus input colorspace")
  JMESSAGE(JERR_BAD_J_COLORSPACE, "Bogus JPEG colorspace")
***************
*** 53,58 ****
--- 54,63 ----
  JMESSAGE(JERR_BAD_LENGTH, "Bogus marker length")
  JMESSAGE(JERR_BAD_LIB_VERSION,
  	 "Wrong JPEG library version: library is %d, caller expects %d")
+ JMESSAGE(JERR_BAD_LOSSLESS,
+ 	 "Invalid lossless parameters Ss=%d Se=%d Ah=%d Al=%d")
+ JMESSAGE(JERR_BAD_LOSSLESS_SCRIPT,
+ 	 "Invalid lossless parameters at scan script entry %d")
  JMESSAGE(JERR_BAD_MCU_SIZE, "Sampling factors too large for interleaved scan")
  JMESSAGE(JERR_BAD_POOL_ID, "Invalid memory pool code %d")
  JMESSAGE(JERR_BAD_PRECISION, "Unsupported JPEG data precision %d")
***************
*** 60,65 ****
--- 65,71 ----
  	 "Invalid progressive parameters Ss=%d Se=%d Ah=%d Al=%d")
  JMESSAGE(JERR_BAD_PROG_SCRIPT,
  	 "Invalid progressive parameters at scan script entry %d")
+ JMESSAGE(JERR_BAD_RESTART, "Invalid restart interval: %d, must be an integer multiple of the number of MCUs in an MCU_row (%d)")
  JMESSAGE(JERR_BAD_SAMPLING, "Bogus sampling factors")
  JMESSAGE(JERR_BAD_SCAN_SCRIPT, "Invalid scan script at entry %d")
  JMESSAGE(JERR_BAD_STATE, "Improper call to JPEG library in state %d")
***************
*** 68,73 ****
--- 74,81 ----
  JMESSAGE(JERR_BAD_VIRTUAL_ACCESS, "Bogus virtual array access")
  JMESSAGE(JERR_BUFFER_SIZE, "Buffer passed to JPEG library is too small")
  JMESSAGE(JERR_CANT_SUSPEND, "Suspension not allowed here")
+ JMESSAGE(JERR_CANT_TRANSCODE,
+ 	 "Cannot transcode to/from lossless JPEG datastreams")
  JMESSAGE(JERR_CCIR601_NOTIMPL, "CCIR601 sampling not implemented yet")
  JMESSAGE(JERR_COMPONENT_COUNT, "Too many color components: %d, max %d")
  JMESSAGE(JERR_CONVERSION_NOTIMPL, "Unsupported color conversion request")
***************
*** 96,101 ****
--- 104,110 ----
  JMESSAGE(JERR_NO_BACKING_STORE, "Backing store not supported")
  JMESSAGE(JERR_NO_HUFF_TABLE, "Huffman table 0x%02x was not defined")
  JMESSAGE(JERR_NO_IMAGE, "JPEG datastream contains no image")
+ JMESSAGE(JERR_NO_LOSSLESS_SCRIPT, "Lossless encoding was requested but no scan script was supplied")
  JMESSAGE(JERR_NO_QUANT_TABLE, "Quantization table 0x%02x was not defined")
  JMESSAGE(JERR_NO_SOI, "Not a JPEG file: starts with 0x%02x 0x%02x")
  JMESSAGE(JERR_OUT_OF_MEMORY, "Insufficient memory (case %d)")
***************
*** 165,171 ****
  	 "JFIF extension marker: palette thumbnail image, length %u")
  JMESSAGE(JTRC_THUMB_RGB,
  	 "JFIF extension marker: RGB thumbnail image, length %u")
! JMESSAGE(JTRC_UNKNOWN_IDS,
  	 "Unrecognized component IDs %d %d %d, assuming YCbCr")
  JMESSAGE(JTRC_XMS_CLOSE, "Freed XMS handle %u")
  JMESSAGE(JTRC_XMS_OPEN, "Obtained XMS handle %u")
--- 174,182 ----
  	 "JFIF extension marker: palette thumbnail image, length %u")
  JMESSAGE(JTRC_THUMB_RGB,
  	 "JFIF extension marker: RGB thumbnail image, length %u")
! JMESSAGE(JTRC_UNKNOWN_LOSSLESS_IDS,
! 	 "Unrecognized component IDs %d %d %d, assuming RGB")
! JMESSAGE(JTRC_UNKNOWN_LOSSY_IDS,
  	 "Unrecognized component IDs %d %d %d, assuming YCbCr")
  JMESSAGE(JTRC_XMS_CLOSE, "Freed XMS handle %u")
  JMESSAGE(JTRC_XMS_OPEN, "Obtained XMS handle %u")
***************
*** 178,183 ****
--- 189,196 ----
  JMESSAGE(JWRN_HUFF_BAD_CODE, "Corrupt JPEG data: bad Huffman code")
  JMESSAGE(JWRN_JFIF_MAJOR, "Warning: unknown JFIF revision number %d.%02d")
  JMESSAGE(JWRN_JPEG_EOF, "Premature end of JPEG file")
+ JMESSAGE(JWRN_MUST_DOWNSCALE,
+ 	 "Must downscale data from %d bits to %d")
  JMESSAGE(JWRN_MUST_RESYNC,
  	 "Corrupt JPEG data: found marker 0x%02x instead of RST%d")
  JMESSAGE(JWRN_NOT_SEQUENTIAL, "Invalid SOS parameters for sequential JPEG")
diff -cN ../jpeg-6b/jlossls.h ./jlossls.h
*** ../jpeg-6b/jlossls.h
--- ./jlossls.h	Tue Apr 27 14:58:32 1999
***************
*** 0 ****
--- 1,149 ----
+ /*
+  * jlossls.h
+  *
+  * Copyright (C) 1998, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+  * This include file contains common declarations for the lossless JPEG
+  * codec modules.
+  */
+ 
+ #ifndef JLOSSLS_H
+ #define JLOSSLS_H
+ 
+ 
+ /*
+  * Table H.1: Predictors for lossless coding.
+  */
+ 
+ #define PREDICTOR1	Ra
+ #define PREDICTOR2	Rb
+ #define PREDICTOR3	Rc
+ #define PREDICTOR4	(int) ((INT32) Ra + (INT32) Rb - (INT32) Rc)
+ #define PREDICTOR5	(int) ((INT32) Ra + RIGHT_SHIFT((INT32) Rb - (INT32) Rc, 1))
+ #define PREDICTOR6	(int) ((INT32) Rb + RIGHT_SHIFT((INT32) Ra - (INT32) Rc, 1))
+ #define PREDICTOR7	(int) RIGHT_SHIFT((INT32) Ra + (INT32) Rb, 1)
+ 
+ 
+ typedef JMETHOD(void, predict_difference_method_ptr,
+ 		(j_compress_ptr cinfo, int ci,
+ 		 JSAMPROW input_buf, JSAMPROW prev_row,
+ 		 JDIFFROW diff_buf, JDIMENSION width));
+ 
+ typedef JMETHOD(void, scaler_method_ptr,
+ 		(j_compress_ptr cinfo, int ci,
+ 		 JSAMPROW input_buf, JSAMPROW output_buf,
+ 		 JDIMENSION width));
+ 
+ /* Lossless-specific compression codec (compressor proper) */
+ typedef struct {
+   struct jpeg_c_codec pub; /* public fields */
+ 
+ 
+   /* Difference buffer control */
+   JMETHOD(void, diff_start_pass, (j_compress_ptr cinfo,
+ 				  J_BUF_MODE pass_mode));
+ 
+   /* Pointer to data which is private to diff controller */
+   void *diff_private;
+ 
+ 
+   /* Entropy encoding */
+   JMETHOD(JDIMENSION, entropy_encode_mcus, (j_compress_ptr cinfo,
+ 					    JDIFFIMAGE diff_buf,
+ 					    JDIMENSION MCU_row_num,
+ 					    JDIMENSION MCU_col_num,
+ 					    JDIMENSION nMCU));
+ 
+   /* Pointer to data which is private to entropy module */
+   void *entropy_private;
+ 
+ 
+   /* Prediction, differencing */
+   JMETHOD(void, predict_start_pass, (j_compress_ptr cinfo));
+ 
+   /* It is useful to allow each component to have a separate diff method. */
+   predict_difference_method_ptr predict_difference[MAX_COMPONENTS];
+ 
+   /* Pointer to data which is private to predictor module */
+   void *pred_private;
+ 
+   /* Sample scaling */
+   JMETHOD(void, scaler_start_pass, (j_compress_ptr cinfo));
+   JMETHOD(void, scaler_scale, (j_compress_ptr cinfo,
+ 			       JSAMPROW input_buf, JSAMPROW output_buf,
+ 			       JDIMENSION width));
+ 
+   /* Pointer to data which is private to scaler module */
+   void *scaler_private;
+ 
+ } jpeg_lossless_c_codec;
+ 
+ typedef jpeg_lossless_c_codec * j_lossless_c_ptr;
+ 
+ 
+ typedef JMETHOD(void, predict_undifference_method_ptr,
+ 		(j_decompress_ptr cinfo, int comp_index,
+ 		 JDIFFROW diff_buf, JDIFFROW prev_row,
+ 		 JDIFFROW undiff_buf, JDIMENSION width));
+ 
+ /* Lossless-specific decompression codec (decompressor proper) */
+ typedef struct {
+   struct jpeg_d_codec pub; /* public fields */
+ 
+ 
+   /* Difference buffer control */
+   JMETHOD(void, diff_start_input_pass, (j_decompress_ptr cinfo));
+ 
+   /* Pointer to data which is private to diff controller */
+   void *diff_private;
+ 
+ 
+   /* Entropy decoding */
+   JMETHOD(void, entropy_start_pass, (j_decompress_ptr cinfo));
+   JMETHOD(boolean, entropy_process_restart, (j_decompress_ptr cinfo));
+   JMETHOD(JDIMENSION, entropy_decode_mcus, (j_decompress_ptr cinfo,
+ 					    JDIFFIMAGE diff_buf,
+ 					    JDIMENSION MCU_row_num,
+ 					    JDIMENSION MCU_col_num,
+ 					    JDIMENSION nMCU));
+ 
+   /* Pointer to data which is private to entropy module */
+   void *entropy_private;
+ 
+ 
+   /* Prediction, undifferencing */
+   JMETHOD(void, predict_start_pass, (j_decompress_ptr cinfo));
+   JMETHOD(void, predict_process_restart, (j_decompress_ptr cinfo));
+ 
+   /* It is useful to allow each component to have a separate undiff method. */
+   predict_undifference_method_ptr predict_undifference[MAX_COMPONENTS];
+ 
+   /* Pointer to data which is private to predictor module */
+   void *pred_private;
+ 
+   /* Sample scaling */
+   JMETHOD(void, scaler_start_pass, (j_decompress_ptr cinfo));
+   JMETHOD(void, scaler_scale, (j_decompress_ptr cinfo,
+ 			       JDIFFROW diff_buf, JSAMPROW output_buf,
+ 			       JDIMENSION width));
+ 
+   /* Pointer to data which is private to scaler module */
+   void *scaler_private;
+ 
+ } jpeg_lossless_d_codec;
+ 
+ typedef jpeg_lossless_d_codec * j_lossless_d_ptr;
+ 
+ 
+ /* Compression module initialization routines */
+ EXTERN(void) jinit_lhuff_encoder JPP((j_compress_ptr cinfo));
+ EXTERN(void) jinit_differencer JPP((j_compress_ptr cinfo));
+ EXTERN(void) jinit_c_scaler JPP((j_compress_ptr cinfo));
+ /* Decompression module initialization routines */
+ EXTERN(void) jinit_lhuff_decoder JPP((j_decompress_ptr cinfo));
+ EXTERN(void) jinit_undifferencer JPP((j_decompress_ptr cinfo));
+ EXTERN(void) jinit_d_scaler JPP((j_decompress_ptr cinfo));
+ 
+ #endif /* JLOSSLS_H */
diff -cN ../jpeg-6b/jlossy.h ./jlossy.h
*** ../jpeg-6b/jlossy.h
--- ./jlossy.h	Tue Apr 27 14:58:32 1999
***************
*** 0 ****
--- 1,120 ----
+ /*
+  * jlossy.h
+  *
+  * Copyright (C) 1998, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+  * This include file contains common declarations for the lossy (DCT-based)
+  * JPEG codec modules.
+  */
+ 
+ #ifndef JLOSSY_H
+ #define JLOSSY_H
+ 
+ 
+ /* Lossy-specific compression codec (compressor proper) */
+ typedef struct {
+   struct jpeg_c_codec pub; /* public fields */
+ 
+ 
+   /* Coefficient buffer control */
+   JMETHOD(void, coef_start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
+   /*  JMETHOD(boolean, coef_compress_data, (j_compress_ptr cinfo,
+ 					JSAMPIMAGE input_buf));*/
+ 
+   /* Pointer to data which is private to coef module */
+   void *coef_private;
+ 
+ 
+   /* Forward DCT (also controls coefficient quantization) */
+   JMETHOD(void, fdct_start_pass, (j_compress_ptr cinfo));
+   /* perhaps this should be an array??? */
+   JMETHOD(void, fdct_forward_DCT, (j_compress_ptr cinfo,
+ 				   jpeg_component_info * compptr,
+ 				   JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
+ 				   JDIMENSION start_row, JDIMENSION start_col,
+ 				   JDIMENSION num_blocks));
+ 
+   /* Pointer to data which is private to fdct module */
+   void *fdct_private;
+ 
+ 
+   /* Entropy encoding */
+   JMETHOD(boolean, entropy_encode_mcu, (j_compress_ptr cinfo,
+ 					JBLOCKROW *MCU_data));
+ 
+   /* Pointer to data which is private to entropy module */
+   void *entropy_private;
+ 
+ } jpeg_lossy_c_codec;
+ 
+ typedef jpeg_lossy_c_codec * j_lossy_c_ptr;
+ 
+ 
+ 
+ typedef JMETHOD(void, inverse_DCT_method_ptr,
+ 		(j_decompress_ptr cinfo, jpeg_component_info * compptr,
+ 		 JCOEFPTR coef_block,
+ 		 JSAMPARRAY output_buf, JDIMENSION output_col));
+ 
+ /* Lossy-specific decompression codec (decompressor proper) */
+ typedef struct {
+   struct jpeg_d_codec pub; /* public fields */
+ 
+ 
+   /* Coefficient buffer control */
+   JMETHOD(void, coef_start_input_pass, (j_decompress_ptr cinfo));
+   JMETHOD(void, coef_start_output_pass, (j_decompress_ptr cinfo));
+ 
+   /* Pointer to array of coefficient virtual arrays, or NULL if none */
+   jvirt_barray_ptr *coef_arrays;
+ 
+   /* Pointer to data which is private to coef module */
+   void *coef_private;
+ 
+ 
+   /* Entropy decoding */
+   JMETHOD(void, entropy_start_pass, (j_decompress_ptr cinfo));
+   JMETHOD(boolean, entropy_decode_mcu, (j_decompress_ptr cinfo,
+ 					JBLOCKROW *MCU_data));
+ 
+   /* This is here to share code between baseline and progressive decoders; */
+   /* other modules probably should not use it */
+   boolean entropy_insufficient_data;	/* set TRUE after emitting warning */
+ 
+   /* Pointer to data which is private to entropy module */
+   void *entropy_private;
+ 
+ 
+   /* Inverse DCT (also performs dequantization) */
+   JMETHOD(void, idct_start_pass, (j_decompress_ptr cinfo));
+ 
+   /* It is useful to allow each component to have a separate IDCT method. */
+   inverse_DCT_method_ptr inverse_DCT[MAX_COMPONENTS];
+ 
+   /* Pointer to data which is private to idct module */
+   void *idct_private;
+ 
+ } jpeg_lossy_d_codec;
+ 
+ typedef jpeg_lossy_d_codec * j_lossy_d_ptr;
+ 
+ 
+ /* Compression module initialization routines */
+ EXTERN(void) jinit_lossy_c_codec JPP((j_compress_ptr cinfo));
+ EXTERN(void) jinit_c_coef_controller JPP((j_compress_ptr cinfo,
+ 					  boolean need_full_buffer));
+ EXTERN(void) jinit_forward_dct JPP((j_compress_ptr cinfo));
+ EXTERN(void) jinit_shuff_encoder JPP((j_compress_ptr cinfo));
+ EXTERN(void) jinit_phuff_encoder JPP((j_compress_ptr cinfo));
+ 
+ /* Decompression module initialization routines */
+ EXTERN(void) jinit_lossy_d_codec JPP((j_decompress_ptr cinfo));
+ EXTERN(void) jinit_d_coef_controller JPP((j_decompress_ptr cinfo,
+ 					  boolean need_full_buffer));
+ EXTERN(void) jinit_shuff_decoder JPP((j_decompress_ptr cinfo));
+ EXTERN(void) jinit_phuff_decoder JPP((j_decompress_ptr cinfo));
+ EXTERN(void) jinit_inverse_dct JPP((j_decompress_ptr cinfo));
+ 
+ #endif /* JLOSSY_H */
diff -cN ../jpeg-6b/jmemmgr.c ./jmemmgr.c
*** ../jpeg-6b/jmemmgr.c	Mon Apr 14 20:56:37 1997
--- ./jmemmgr.c	Tue Apr 27 14:58:33 1999
***************
*** 1,7 ****
  /*
   * jmemmgr.c
   *
!  * Copyright (C) 1991-1997, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jmemmgr.c
   *
!  * Copyright (C) 1991-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 42,52 ****
   *   The allocation routines provided here must never return NULL.
   *   They should exit to error_exit if unsuccessful.
   *
!  *   It's not a good idea to try to merge the sarray and barray routines,
!  *   even though they are textually almost the same, because samples are
!  *   usually stored as bytes while coefficients are shorts or ints.  Thus,
!  *   in machines where byte pointers have a different representation from
!  *   word pointers, the resulting machine code could not be the same.
   */
  
  
--- 42,53 ----
   *   The allocation routines provided here must never return NULL.
   *   They should exit to error_exit if unsuccessful.
   *
!  *   It's not a good idea to try to merge the sarray, barray and darray
!  *   routines, even though they are textually almost the same, because
!  *   samples are usually stored as bytes while coefficients and differenced
!  *   are shorts or ints.  Thus, in machines where byte pointers have a
!  *   different representation from word pointers, the resulting machine
!  *   code could not be the same.
   */
  
  
***************
*** 482,487 ****
--- 483,540 ----
  }
  
  
+ #ifdef NEED_DARRAY
+ 
+ /*
+  * Creation of 2-D difference arrays.
+  * This is essentially the same as the code for sample arrays, above.
+  */
+ 
+ METHODDEF(JDIFFARRAY)
+ alloc_darray (j_common_ptr cinfo, int pool_id,
+ 	      JDIMENSION diffsperrow, JDIMENSION numrows)
+ /* Allocate a 2-D difference array */
+ {
+   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
+   JDIFFARRAY result;
+   JDIFFROW workspace;
+   JDIMENSION rowsperchunk, currow, i;
+   long ltemp;
+ 
+   /* Calculate max # of rows allowed in one allocation chunk */
+   ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
+ 	  ((long) diffsperrow * SIZEOF(JDIFF));
+   if (ltemp <= 0)
+     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
+   if (ltemp < (long) numrows)
+     rowsperchunk = (JDIMENSION) ltemp;
+   else
+     rowsperchunk = numrows;
+   mem->last_rowsperchunk = rowsperchunk;
+ 
+   /* Get space for row pointers (small object) */
+   result = (JDIFFARRAY) alloc_small(cinfo, pool_id,
+ 				    (size_t) (numrows * SIZEOF(JDIFFROW)));
+ 
+   /* Get the rows themselves (large objects) */
+   currow = 0;
+   while (currow < numrows) {
+     rowsperchunk = MIN(rowsperchunk, numrows - currow);
+     workspace = (JDIFFROW) alloc_large(cinfo, pool_id,
+ 	(size_t) ((size_t) rowsperchunk * (size_t) diffsperrow
+ 		  * SIZEOF(JDIFF)));
+     for (i = rowsperchunk; i > 0; i--) {
+       result[currow++] = workspace;
+       workspace += diffsperrow;
+     }
+   }
+ 
+   return result;
+ }
+ 
+ #endif
+ 
+ 
  /*
   * About virtual array management:
   *
***************
*** 1068,1073 ****
--- 1121,1129 ----
    mem->pub.alloc_large = alloc_large;
    mem->pub.alloc_sarray = alloc_sarray;
    mem->pub.alloc_barray = alloc_barray;
+ #ifdef NEED_DARRAY
+   mem->pub.alloc_darray = alloc_darray;
+ #endif
    mem->pub.request_virt_sarray = request_virt_sarray;
    mem->pub.request_virt_barray = request_virt_barray;
    mem->pub.realize_virt_arrays = realize_virt_arrays;
diff -cN ../jpeg-6b/jmorecfg.h ./jmorecfg.h
*** ../jpeg-6b/jmorecfg.h	Sat Aug  9 19:58:56 1997
--- ./jmorecfg.h	Tue Apr 27 14:58:33 1999
***************
*** 1,7 ****
  /*
   * jmorecfg.h
   *
!  * Copyright (C) 1991-1997, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jmorecfg.h
   *
!  * Copyright (C) 1991-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 90,95 ****
--- 90,122 ----
  #endif /* BITS_IN_JSAMPLE == 12 */
  
  
+ #if BITS_IN_JSAMPLE == 16
+ /* JSAMPLE should be the smallest type that will hold the values 0..65535.
+  * You can use a signed short by having GETJSAMPLE mask it with 0xFFFF.
+  */
+ 
+ #ifdef HAVE_UNSIGNED_SHORT
+ 
+ typedef unsigned short JSAMPLE;
+ #define GETJSAMPLE(value)  ((int) (value))
+ 
+ #else /* not HAVE_UNSIGNED_SHORT */
+ 
+ typedef short JSAMPLE;
+ #ifdef SHORT_IS_UNSIGNED
+ #define GETJSAMPLE(value)  ((int) (value))
+ #else
+ #define GETJSAMPLE(value)  ((int) (value) & 0xFFFF)
+ #endif /* SHORT_IS_UNSIGNED */
+ 
+ #endif /* HAVE_UNSIGNED_SHORT */
+ 
+ #define MAXJSAMPLE	65535
+ #define CENTERJSAMPLE	32768
+ 
+ #endif /* BITS_IN_JSAMPLE == 16 */
+ 
+ 
  /* Representation of a DCT frequency coefficient.
   * This should be a signed value of at least 16 bits; "short" is usually OK.
   * Again, we allocate large arrays of these, but you can change to int
***************
*** 99,104 ****
--- 126,138 ----
  typedef short JCOEF;
  
  
+ /* Representation of a spatial difference value.
+  * This should be a signed value of at least 16 bits; int is usually OK.
+  */
+ 
+ typedef int JDIFF;
+ 
+ 
  /* Compressed datastreams are represented as arrays of JOCTET.
   * These must be EXACTLY 8 bits wide, at least once they are written to
   * external storage.  Note that when using the stdio data source/destination
***************
*** 269,282 ****
  #undef  C_ARITH_CODING_SUPPORTED    /* Arithmetic coding back end? */
  #define C_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
  #define C_PROGRESSIVE_SUPPORTED	    /* Progressive JPEG? (Requires MULTISCAN)*/
  #define ENTROPY_OPT_SUPPORTED	    /* Optimization of entropy coding parms? */
  /* Note: if you selected 12-bit data precision, it is dangerous to turn off
   * ENTROPY_OPT_SUPPORTED.  The standard Huffman tables are only good for 8-bit
!  * precision, so jchuff.c normally uses entropy optimization to compute
   * usable tables for higher precision.  If you don't want to do optimization,
   * you'll have to supply different default Huffman tables.
!  * The exact same statements apply for progressive JPEG: the default tables
!  * don't work for progressive mode.  (This may get fixed, however.)
   */
  #define INPUT_SMOOTHING_SUPPORTED   /* Input image smoothing option? */
  
--- 303,318 ----
  #undef  C_ARITH_CODING_SUPPORTED    /* Arithmetic coding back end? */
  #define C_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
  #define C_PROGRESSIVE_SUPPORTED	    /* Progressive JPEG? (Requires MULTISCAN)*/
+ #define C_LOSSLESS_SUPPORTED	    /* Lossless JPEG? */
  #define ENTROPY_OPT_SUPPORTED	    /* Optimization of entropy coding parms? */
  /* Note: if you selected 12-bit data precision, it is dangerous to turn off
   * ENTROPY_OPT_SUPPORTED.  The standard Huffman tables are only good for 8-bit
!  * precision, so jcshuff.c normally uses entropy optimization to compute
   * usable tables for higher precision.  If you don't want to do optimization,
   * you'll have to supply different default Huffman tables.
!  * The exact same statements apply for progressive and lossless JPEG:
!  * the default tables don't work for progressive mode or lossless mode.
!  * (This may get fixed, however.)
   */
  #define INPUT_SMOOTHING_SUPPORTED   /* Input image smoothing option? */
  
***************
*** 285,290 ****
--- 321,327 ----
  #undef  D_ARITH_CODING_SUPPORTED    /* Arithmetic coding back end? */
  #define D_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
  #define D_PROGRESSIVE_SUPPORTED	    /* Progressive JPEG? (Requires MULTISCAN)*/
+ #define D_LOSSLESS_SUPPORTED	    /* Lossless JPEG? */
  #define SAVE_MARKERS_SUPPORTED	    /* jpeg_save_markers() needed? */
  #define BLOCK_SMOOTHING_SUPPORTED   /* Block smoothing? (Progressive only) */
  #define IDCT_SCALING_SUPPORTED	    /* Output rescaling via IDCT? */
diff -cN ../jpeg-6b/jpegint.h ./jpegint.h
*** ../jpeg-6b/jpegint.h	Sat Apr 19 19:44:35 1997
--- ./jpegint.h	Tue Apr 27 14:58:33 1999
***************
*** 1,7 ****
  /*
   * jpegint.h
   *
!  * Copyright (C) 1991-1997, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * jpegint.h
   *
!  * Copyright (C) 1991-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 72,79 ****
  				   JDIMENSION out_row_groups_avail));
  };
  
! /* Coefficient buffer control */
! struct jpeg_c_coef_controller {
    JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
    JMETHOD(boolean, compress_data, (j_compress_ptr cinfo,
  				   JSAMPIMAGE input_buf));
--- 72,83 ----
  				   JDIMENSION out_row_groups_avail));
  };
  
! /* Compression codec (compressor proper) */
! struct jpeg_c_codec {
!   JMETHOD(void, entropy_start_pass, (j_compress_ptr cinfo,
! 				     boolean gather_statistics));
!   JMETHOD(void, entropy_finish_pass, (j_compress_ptr cinfo));
!   JMETHOD(boolean, need_optimization_pass, (j_compress_ptr cinfo));
    JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
    JMETHOD(boolean, compress_data, (j_compress_ptr cinfo,
  				   JSAMPIMAGE input_buf));
***************
*** 98,121 ****
    boolean need_context_rows;	/* TRUE if need rows above & below */
  };
  
- /* Forward DCT (also controls coefficient quantization) */
- struct jpeg_forward_dct {
-   JMETHOD(void, start_pass, (j_compress_ptr cinfo));
-   /* perhaps this should be an array??? */
-   JMETHOD(void, forward_DCT, (j_compress_ptr cinfo,
- 			      jpeg_component_info * compptr,
- 			      JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
- 			      JDIMENSION start_row, JDIMENSION start_col,
- 			      JDIMENSION num_blocks));
- };
- 
- /* Entropy encoding */
- struct jpeg_entropy_encoder {
-   JMETHOD(void, start_pass, (j_compress_ptr cinfo, boolean gather_statistics));
-   JMETHOD(boolean, encode_mcu, (j_compress_ptr cinfo, JBLOCKROW *MCU_data));
-   JMETHOD(void, finish_pass, (j_compress_ptr cinfo));
- };
- 
  /* Marker writing */
  struct jpeg_marker_writer {
    JMETHOD(void, write_file_header, (j_compress_ptr cinfo));
--- 102,107 ----
***************
*** 162,176 ****
  			       JDIMENSION out_rows_avail));
  };
  
! /* Coefficient buffer control */
! struct jpeg_d_coef_controller {
    JMETHOD(void, start_input_pass, (j_decompress_ptr cinfo));
    JMETHOD(int, consume_data, (j_decompress_ptr cinfo));
    JMETHOD(void, start_output_pass, (j_decompress_ptr cinfo));
    JMETHOD(int, decompress_data, (j_decompress_ptr cinfo,
  				 JSAMPIMAGE output_buf));
-   /* Pointer to array of coefficient virtual arrays, or NULL if none */
-   jvirt_barray_ptr *coef_arrays;
  };
  
  /* Decompression postprocessing (color quantization buffer control) */
--- 148,161 ----
  			       JDIMENSION out_rows_avail));
  };
  
! /* Decompression codec (decompressor proper) */
! struct jpeg_d_codec {
!   JMETHOD(void, calc_output_dimensions, (j_decompress_ptr cinfo));
    JMETHOD(void, start_input_pass, (j_decompress_ptr cinfo));
    JMETHOD(int, consume_data, (j_decompress_ptr cinfo));
    JMETHOD(void, start_output_pass, (j_decompress_ptr cinfo));
    JMETHOD(int, decompress_data, (j_decompress_ptr cinfo,
  				 JSAMPIMAGE output_buf));
  };
  
  /* Decompression postprocessing (color quantization buffer control) */
***************
*** 205,233 ****
    unsigned int discarded_bytes;	/* # of bytes skipped looking for a marker */
  };
  
- /* Entropy decoding */
- struct jpeg_entropy_decoder {
-   JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
-   JMETHOD(boolean, decode_mcu, (j_decompress_ptr cinfo,
- 				JBLOCKROW *MCU_data));
- 
-   /* This is here to share code between baseline and progressive decoders; */
-   /* other modules probably should not use it */
-   boolean insufficient_data;	/* set TRUE after emitting warning */
- };
- 
- /* Inverse DCT (also performs dequantization) */
- typedef JMETHOD(void, inverse_DCT_method_ptr,
- 		(j_decompress_ptr cinfo, jpeg_component_info * compptr,
- 		 JCOEFPTR coef_block,
- 		 JSAMPARRAY output_buf, JDIMENSION output_col));
- 
- struct jpeg_inverse_dct {
-   JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
-   /* It is useful to allow each component to have a separate IDCT method. */
-   inverse_DCT_method_ptr inverse_DCT[MAX_COMPONENTS];
- };
- 
  /* Upsampling (note that upsampler must also call color converter) */
  struct jpeg_upsampler {
    JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
--- 190,195 ----
***************
*** 294,299 ****
--- 256,263 ----
  /* Short forms of external names for systems with brain-damaged linkers. */
  
  #ifdef NEED_SHORT_EXTERNAL_NAMES
+ #define jinit_c_codec		jICCodec
+ #define jinit_lossy_c_codec	jILossyC
  #define jinit_compress_master	jICompress
  #define jinit_c_master_control	jICMaster
  #define jinit_c_main_controller	jICMainC
***************
*** 302,318 ****
  #define jinit_color_converter	jICColor
  #define jinit_downsampler	jIDownsampler
  #define jinit_forward_dct	jIFDCT
! #define jinit_huff_encoder	jIHEncoder
  #define jinit_phuff_encoder	jIPHEncoder
  #define jinit_marker_writer	jIMWriter
  #define jinit_master_decompress	jIDMaster
  #define jinit_d_main_controller	jIDMainC
  #define jinit_d_coef_controller	jIDCoefC
  #define jinit_d_post_controller	jIDPostC
  #define jinit_input_controller	jIInCtlr
  #define jinit_marker_reader	jIMReader
! #define jinit_huff_decoder	jIHDecoder
  #define jinit_phuff_decoder	jIPHDecoder
  #define jinit_inverse_dct	jIIDCT
  #define jinit_upsampler		jIUpsampler
  #define jinit_color_deconverter	jIDColor
--- 266,289 ----
  #define jinit_color_converter	jICColor
  #define jinit_downsampler	jIDownsampler
  #define jinit_forward_dct	jIFDCT
! #define jinit_shuff_encoder	jISHEncoder
  #define jinit_phuff_encoder	jIPHEncoder
  #define jinit_marker_writer	jIMWriter
+ #define jinit_d_codec		jIDCodec
+ #define jinit_lossy_d_codec	jILossyD
+ #define jinit_lossless_d_codec	jILosslsD
  #define jinit_master_decompress	jIDMaster
  #define jinit_d_main_controller	jIDMainC
  #define jinit_d_coef_controller	jIDCoefC
+ #define jinit_d_diff_controller	jIDDiffC
  #define jinit_d_post_controller	jIDPostC
  #define jinit_input_controller	jIInCtlr
  #define jinit_marker_reader	jIMReader
! #define jinit_shuff_decoder	jISHDecoder
  #define jinit_phuff_decoder	jIPHDecoder
+ #define jinit_lhuff_decoder	jILHDecoder
+ #define jinit_undifferencer	jIUndiff
+ #define jinit_d_scaler		jIDScaler
  #define jinit_inverse_dct	jIIDCT
  #define jinit_upsampler		jIUpsampler
  #define jinit_color_deconverter	jIDColor
***************
*** 338,364 ****
  					  boolean need_full_buffer));
  EXTERN(void) jinit_c_prep_controller JPP((j_compress_ptr cinfo,
  					  boolean need_full_buffer));
! EXTERN(void) jinit_c_coef_controller JPP((j_compress_ptr cinfo,
! 					  boolean need_full_buffer));
  EXTERN(void) jinit_color_converter JPP((j_compress_ptr cinfo));
  EXTERN(void) jinit_downsampler JPP((j_compress_ptr cinfo));
- EXTERN(void) jinit_forward_dct JPP((j_compress_ptr cinfo));
- EXTERN(void) jinit_huff_encoder JPP((j_compress_ptr cinfo));
- EXTERN(void) jinit_phuff_encoder JPP((j_compress_ptr cinfo));
  EXTERN(void) jinit_marker_writer JPP((j_compress_ptr cinfo));
  /* Decompression module initialization routines */
  EXTERN(void) jinit_master_decompress JPP((j_decompress_ptr cinfo));
  EXTERN(void) jinit_d_main_controller JPP((j_decompress_ptr cinfo,
  					  boolean need_full_buffer));
! EXTERN(void) jinit_d_coef_controller JPP((j_decompress_ptr cinfo,
! 					  boolean need_full_buffer));
  EXTERN(void) jinit_d_post_controller JPP((j_decompress_ptr cinfo,
  					  boolean need_full_buffer));
  EXTERN(void) jinit_input_controller JPP((j_decompress_ptr cinfo));
  EXTERN(void) jinit_marker_reader JPP((j_decompress_ptr cinfo));
- EXTERN(void) jinit_huff_decoder JPP((j_decompress_ptr cinfo));
- EXTERN(void) jinit_phuff_decoder JPP((j_decompress_ptr cinfo));
- EXTERN(void) jinit_inverse_dct JPP((j_decompress_ptr cinfo));
  EXTERN(void) jinit_upsampler JPP((j_decompress_ptr cinfo));
  EXTERN(void) jinit_color_deconverter JPP((j_decompress_ptr cinfo));
  EXTERN(void) jinit_1pass_quantizer JPP((j_decompress_ptr cinfo));
--- 309,327 ----
  					  boolean need_full_buffer));
  EXTERN(void) jinit_c_prep_controller JPP((j_compress_ptr cinfo,
  					  boolean need_full_buffer));
! EXTERN(void) jinit_compressor JPP((j_compress_ptr cinfo));
  EXTERN(void) jinit_color_converter JPP((j_compress_ptr cinfo));
  EXTERN(void) jinit_downsampler JPP((j_compress_ptr cinfo));
  EXTERN(void) jinit_marker_writer JPP((j_compress_ptr cinfo));
  /* Decompression module initialization routines */
  EXTERN(void) jinit_master_decompress JPP((j_decompress_ptr cinfo));
  EXTERN(void) jinit_d_main_controller JPP((j_decompress_ptr cinfo,
  					  boolean need_full_buffer));
! EXTERN(void) jinit_decompressor JPP((j_decompress_ptr cinfo));
  EXTERN(void) jinit_d_post_controller JPP((j_decompress_ptr cinfo,
  					  boolean need_full_buffer));
  EXTERN(void) jinit_input_controller JPP((j_decompress_ptr cinfo));
  EXTERN(void) jinit_marker_reader JPP((j_decompress_ptr cinfo));
  EXTERN(void) jinit_upsampler JPP((j_decompress_ptr cinfo));
  EXTERN(void) jinit_color_deconverter JPP((j_decompress_ptr cinfo));
  EXTERN(void) jinit_1pass_quantizer JPP((j_decompress_ptr cinfo));
diff -cN ../jpeg-6b/jpeglib.h ./jpeglib.h
*** ../jpeg-6b/jpeglib.h	Sat Feb 21 14:48:14 1998
--- ./jpeglib.h	Tue Apr 27 14:58:34 1999
***************
*** 46,60 ****
  #define MAX_COMPS_IN_SCAN   4	/* JPEG limit on # of components in one scan */
  #define MAX_SAMP_FACTOR     4	/* JPEG limit on sampling factors */
  /* Unfortunately, some bozo at Adobe saw no reason to be bound by the standard;
!  * the PostScript DCT filter can emit files with many more than 10 blocks/MCU.
!  * If you happen to run across such a file, you can up D_MAX_BLOCKS_IN_MCU
   * to handle it.  We even let you do this from the jconfig.h file.  However,
!  * we strongly discourage changing C_MAX_BLOCKS_IN_MCU; just because Adobe
   * sometimes emits noncompliant files doesn't mean you should too.
   */
! #define C_MAX_BLOCKS_IN_MCU   10 /* compressor's limit on blocks per MCU */
! #ifndef D_MAX_BLOCKS_IN_MCU
! #define D_MAX_BLOCKS_IN_MCU   10 /* decompressor's limit on blocks per MCU */
  #endif
  
  
--- 46,61 ----
  #define MAX_COMPS_IN_SCAN   4	/* JPEG limit on # of components in one scan */
  #define MAX_SAMP_FACTOR     4	/* JPEG limit on sampling factors */
  /* Unfortunately, some bozo at Adobe saw no reason to be bound by the standard;
!  * the PostScript DCT filter can emit files with many more than 10 data units
!  * per MCU.
!  * If you happen to run across such a file, you can up D_MAX_DATA_UNITS_IN_MCU
   * to handle it.  We even let you do this from the jconfig.h file.  However,
!  * we strongly discourage changing C_MAX_DATA_UNITS_IN_MCU; just because Adobe
   * sometimes emits noncompliant files doesn't mean you should too.
   */
! #define C_MAX_DATA_UNITS_IN_MCU   10 /* compressor's limit on data units/MCU */
! #ifndef D_MAX_DATA_UNITS_IN_MCU
! #define D_MAX_DATA_UNITS_IN_MCU   10 /* decompressor's limit on data units/MCU */
  #endif
  
  
***************
*** 74,80 ****
--- 75,85 ----
  
  typedef JCOEF FAR *JCOEFPTR;	/* useful in a couple of places */
  
+ typedef JDIFF FAR *JDIFFROW;	/* pointer to one row of difference values */
+ typedef JDIFFROW *JDIFFARRAY;	/* ptr to some rows (a 2-D diff array) */
+ typedef JDIFFARRAY *JDIFFIMAGE;	/* a 3-D diff array: top index is color */
  
+ 
  /* Types for JPEG compression parameters and working tables. */
  
  
***************
*** 132,155 ****
    /* Remaining fields should be treated as private by applications. */
    
    /* These values are computed during compression or decompression startup: */
!   /* Component's size in DCT blocks.
!    * Any dummy blocks added to complete an MCU are not counted; therefore
     * these values do not depend on whether a scan is interleaved or not.
     */
!   JDIMENSION width_in_blocks;
!   JDIMENSION height_in_blocks;
!   /* Size of a DCT block in samples.  Always DCTSIZE for compression.
!    * For decompression this is the size of the output from one DCT block,
!    * reflecting any scaling we choose to apply during the IDCT step.
!    * Values of 1,2,4,8 are likely to be supported.  Note that different
!    * components may receive different IDCT scalings.
     */
!   int DCT_scaled_size;
    /* The downsampled dimensions are the component's actual, unpadded number
     * of samples at the main buffer (preprocessing/compression interface), thus
     * downsampled_width = ceil(image_width * Hi/Hmax)
!    * and similarly for height.  For decompression, IDCT scaling is included, so
!    * downsampled_width = ceil(image_width * Hi/Hmax * DCT_scaled_size/DCTSIZE)
     */
    JDIMENSION downsampled_width;	 /* actual width in samples */
    JDIMENSION downsampled_height; /* actual height in samples */
--- 137,162 ----
    /* Remaining fields should be treated as private by applications. */
    
    /* These values are computed during compression or decompression startup: */
!   /* Component's size in data units.
!    * Any dummy data units added to complete an MCU are not counted; therefore
     * these values do not depend on whether a scan is interleaved or not.
     */
!   JDIMENSION width_in_data_units;
!   JDIMENSION height_in_data_units;
!   /* Size of a data unit in/output by the codec (in samples).  Always
!    * data_unit for compression.  For decompression this is the size of the
!    * output from one data_unit, reflecting any processing performed by the
!    * codec.  For example, in the DCT-based codec, scaling may be applied
!    * during the IDCT step.  Values of 1,2,4,8 are likely to be supported.
!    * Note that different components may have different codec_data_unit sizes.
     */
!   int codec_data_unit;
    /* The downsampled dimensions are the component's actual, unpadded number
     * of samples at the main buffer (preprocessing/compression interface), thus
     * downsampled_width = ceil(image_width * Hi/Hmax)
!    * and similarly for height.  For decompression, codec-based processing is
!    * included (ie, IDCT scaling), so
!    * downsampled_width = ceil(image_width * Hi/Hmax * codec_data_unit/data_unit)
     */
    JDIMENSION downsampled_width;	 /* actual width in samples */
    JDIMENSION downsampled_height; /* actual height in samples */
***************
*** 161,172 ****
  
    /* These values are computed before starting a scan of the component. */
    /* The decompressor output side may not use these variables. */
!   int MCU_width;		/* number of blocks per MCU, horizontally */
!   int MCU_height;		/* number of blocks per MCU, vertically */
!   int MCU_blocks;		/* MCU_width * MCU_height */
!   int MCU_sample_width;		/* MCU width in samples, MCU_width*DCT_scaled_size */
!   int last_col_width;		/* # of non-dummy blocks across in last MCU */
!   int last_row_height;		/* # of non-dummy blocks down in last MCU */
  
    /* Saved quantization table for component; NULL if none yet saved.
     * See jdinput.c comments about the need for this information.
--- 168,179 ----
  
    /* These values are computed before starting a scan of the component. */
    /* The decompressor output side may not use these variables. */
!   int MCU_width;		/* number of data units per MCU, horizontally */
!   int MCU_height;		/* number of data units per MCU, vertically */
!   int MCU_data_units;		/* MCU_width * MCU_height */
!   int MCU_sample_width;		/* MCU width in samples, MCU_width*codec_data_unit */
!   int last_col_width;		/* # of non-dummy data_units across in last MCU */
!   int last_row_height;		/* # of non-dummy data_units down in last MCU */
  
    /* Saved quantization table for component; NULL if none yet saved.
     * See jdinput.c comments about the need for this information.
***************
*** 184,191 ****
  typedef struct {
    int comps_in_scan;		/* number of components encoded in this scan */
    int component_index[MAX_COMPS_IN_SCAN]; /* their SOF/comp_info[] indexes */
!   int Ss, Se;			/* progressive JPEG spectral selection parms */
!   int Ah, Al;			/* progressive JPEG successive approx. parms */
  } jpeg_scan_info;
  
  /* The decompressor can save APPn and COM markers in a list of these: */
--- 191,200 ----
  typedef struct {
    int comps_in_scan;		/* number of components encoded in this scan */
    int component_index[MAX_COMPS_IN_SCAN]; /* their SOF/comp_info[] indexes */
!   int Ss, Se;			/* progressive JPEG spectral selection parms
! 				   lossless JPEG predictor select parm (Ss) */
!   int Ah, Al;			/* progressive JPEG successive approx. parms
! 				   lossless JPEG point transform parm (Al) */
  } jpeg_scan_info;
  
  /* The decompressor can save APPn and COM markers in a list of these: */
***************
*** 201,206 ****
--- 210,223 ----
    /* the marker length word is not counted in data_length or original_length */
  };
  
+ /* Known codec processes. */
+ 
+ typedef enum {
+ 	JPROC_SEQUENTIAL,	/* baseline/extended sequential DCT */
+ 	JPROC_PROGRESSIVE,	/* progressive DCT */
+ 	JPROC_LOSSLESS		/* lossless (sequential) */
+ } J_CODEC_PROCESS;
+ 
  /* Known color spaces. */
  
  typedef enum {
***************
*** 291,296 ****
--- 308,315 ----
     * helper routines to simplify changing parameters.
     */
  
+   boolean lossless;		/* TRUE=lossless encoding, FALSE=lossy */
+ 
    int data_precision;		/* bits of precision in image data */
  
    int num_components;		/* # of color components in JPEG image */
***************
*** 360,373 ****
    /*
     * These fields are computed during compression startup
     */
!   boolean progressive_mode;	/* TRUE if scan script uses progressive mode */
    int max_h_samp_factor;	/* largest h_samp_factor */
    int max_v_samp_factor;	/* largest v_samp_factor */
  
!   JDIMENSION total_iMCU_rows;	/* # of iMCU rows to be input to coef ctlr */
!   /* The coefficient controller receives data in units of MCU rows as defined
!    * for fully interleaved scans (whether the JPEG file is interleaved or not).
!    * There are v_samp_factor * DCTSIZE sample rows of each component in an
     * "iMCU" (interleaved MCU) row.
     */
    
--- 379,394 ----
    /*
     * These fields are computed during compression startup
     */
!   int data_unit;		/* size of data unit in samples */
!   J_CODEC_PROCESS process;	/* encoding process of JPEG image */
! 
    int max_h_samp_factor;	/* largest h_samp_factor */
    int max_v_samp_factor;	/* largest v_samp_factor */
  
!   JDIMENSION total_iMCU_rows;	/* # of iMCU rows to be input to codec */
!   /* The codec receives data in units of MCU rows as defined for fully
!    * interleaved scans (whether the JPEG file is interleaved or not).
!    * There are v_samp_factor * data_unit sample rows of each component in an
     * "iMCU" (interleaved MCU) row.
     */
    
***************
*** 382,393 ****
    JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
    JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
    
!   int blocks_in_MCU;		/* # of DCT blocks per MCU */
!   int MCU_membership[C_MAX_BLOCKS_IN_MCU];
    /* MCU_membership[i] is index in cur_comp_info of component owning */
    /* i'th block in an MCU */
  
!   int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */
  
    /*
     * Links to compression subobjects (methods and private variables of modules)
--- 403,414 ----
    JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
    JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
    
!   int data_units_in_MCU;	/* # of data units per MCU */
!   int MCU_membership[C_MAX_DATA_UNITS_IN_MCU];
    /* MCU_membership[i] is index in cur_comp_info of component owning */
    /* i'th block in an MCU */
  
!   int Ss, Se, Ah, Al;		/* progressive/lossless JPEG parameters for scan */
  
    /*
     * Links to compression subobjects (methods and private variables of modules)
***************
*** 395,406 ****
    struct jpeg_comp_master * master;
    struct jpeg_c_main_controller * main;
    struct jpeg_c_prep_controller * prep;
!   struct jpeg_c_coef_controller * coef;
    struct jpeg_marker_writer * marker;
    struct jpeg_color_converter * cconvert;
    struct jpeg_downsampler * downsample;
-   struct jpeg_forward_dct * fdct;
-   struct jpeg_entropy_encoder * entropy;
    jpeg_scan_info * script_space; /* workspace for jpeg_simple_progression */
    int script_space_size;
  };
--- 416,425 ----
    struct jpeg_comp_master * master;
    struct jpeg_c_main_controller * main;
    struct jpeg_c_prep_controller * prep;
!   struct jpeg_c_codec * codec;
    struct jpeg_marker_writer * marker;
    struct jpeg_color_converter * cconvert;
    struct jpeg_downsampler * downsample;
    jpeg_scan_info * script_space; /* workspace for jpeg_simple_progression */
    int script_space_size;
  };
***************
*** 535,541 ****
    jpeg_component_info * comp_info;
    /* comp_info[i] describes component that appears i'th in SOF */
  
-   boolean progressive_mode;	/* TRUE if SOFn specifies progressive mode */
    boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
  
    UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
--- 554,559 ----
***************
*** 572,589 ****
    /*
     * These fields are computed during decompression startup
     */
    int max_h_samp_factor;	/* largest h_samp_factor */
    int max_v_samp_factor;	/* largest v_samp_factor */
  
!   int min_DCT_scaled_size;	/* smallest DCT_scaled_size of any component */
  
    JDIMENSION total_iMCU_rows;	/* # of iMCU rows in image */
!   /* The coefficient controller's input and output progress is measured in
!    * units of "iMCU" (interleaved MCU) rows.  These are the same as MCU rows
!    * in fully interleaved JPEG scans, but are used whether the scan is
!    * interleaved or not.  We define an iMCU row as v_samp_factor DCT block
!    * rows of each component.  Therefore, the IDCT output contains
!    * v_samp_factor*DCT_scaled_size sample rows of a component per iMCU row.
     */
  
    JSAMPLE * sample_range_limit; /* table for fast range-limiting */
--- 590,610 ----
    /*
     * These fields are computed during decompression startup
     */
+   int data_unit;		/* size of data unit in samples */
+   J_CODEC_PROCESS process;	/* decoding process of JPEG image */
+ 
    int max_h_samp_factor;	/* largest h_samp_factor */
    int max_v_samp_factor;	/* largest v_samp_factor */
  
!   int min_codec_data_unit;	/* smallest codec_data_unit of any component */
  
    JDIMENSION total_iMCU_rows;	/* # of iMCU rows in image */
!   /* The codec's input and output progress is measured in units of "iMCU"
!    * (interleaved MCU) rows.  These are the same as MCU rows in fully
!    * interleaved JPEG scans, but are used whether the scan is interleaved
!    * or not.  We define an iMCU row as v_samp_factor data_unit rows of each
!    * component.  Therefore, the codec output contains
!    * v_samp_factor*codec_data_unit sample rows of a component per iMCU row.
     */
  
    JSAMPLE * sample_range_limit; /* table for fast range-limiting */
***************
*** 600,611 ****
    JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
    JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
  
!   int blocks_in_MCU;		/* # of DCT blocks per MCU */
!   int MCU_membership[D_MAX_BLOCKS_IN_MCU];
    /* MCU_membership[i] is index in cur_comp_info of component owning */
!   /* i'th block in an MCU */
  
!   int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */
  
    /* This field is shared between entropy decoder and marker parser.
     * It is either zero or the code of a JPEG marker that has been
--- 621,632 ----
    JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
    JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
  
!   int data_units_in_MCU;	/* # of data _units per MCU */
!   int MCU_membership[D_MAX_DATA_UNITS_IN_MCU];
    /* MCU_membership[i] is index in cur_comp_info of component owning */
!   /* i'th data unit in an MCU */
  
!   int Ss, Se, Ah, Al;		/* progressive/lossless JPEG parms for scan */
  
    /* This field is shared between entropy decoder and marker parser.
     * It is either zero or the code of a JPEG marker that has been
***************
*** 618,629 ****
     */
    struct jpeg_decomp_master * master;
    struct jpeg_d_main_controller * main;
!   struct jpeg_d_coef_controller * coef;
    struct jpeg_d_post_controller * post;
    struct jpeg_input_controller * inputctl;
    struct jpeg_marker_reader * marker;
-   struct jpeg_entropy_decoder * entropy;
-   struct jpeg_inverse_dct * idct;
    struct jpeg_upsampler * upsample;
    struct jpeg_color_deconverter * cconvert;
    struct jpeg_color_quantizer * cquantize;
--- 639,648 ----
     */
    struct jpeg_decomp_master * master;
    struct jpeg_d_main_controller * main;
!   struct jpeg_d_codec * codec;
    struct jpeg_d_post_controller * post;
    struct jpeg_input_controller * inputctl;
    struct jpeg_marker_reader * marker;
    struct jpeg_upsampler * upsample;
    struct jpeg_color_deconverter * cconvert;
    struct jpeg_color_quantizer * cquantize;
***************
*** 753,758 ****
--- 772,785 ----
  typedef struct jvirt_barray_control * jvirt_barray_ptr;
  
  
+ #ifdef C_LOSSLESS_SUPPORTED
+ #define NEED_DARRAY
+ #else
+ #ifdef D_LOSSLESS_SUPPORTED
+ #define NEED_DARRAY
+ #endif
+ #endif
+ 
  struct jpeg_memory_mgr {
    /* Method pointers */
    JMETHOD(void *, alloc_small, (j_common_ptr cinfo, int pool_id,
***************
*** 765,770 ****
--- 792,802 ----
    JMETHOD(JBLOCKARRAY, alloc_barray, (j_common_ptr cinfo, int pool_id,
  				      JDIMENSION blocksperrow,
  				      JDIMENSION numrows));
+ #ifdef NEED_DARRAY
+   JMETHOD(JDIFFARRAY, alloc_darray, (j_common_ptr cinfo, int pool_id,
+ 				     JDIMENSION diffsperrow,
+ 				     JDIMENSION numrows));
+ #endif
    JMETHOD(jvirt_sarray_ptr, request_virt_sarray, (j_common_ptr cinfo,
  						  int pool_id,
  						  boolean pre_zero,
***************
*** 843,848 ****
--- 875,881 ----
  #define jpeg_set_linear_quality	jSetLQuality
  #define jpeg_add_quant_table	jAddQuantTable
  #define jpeg_quality_scaling	jQualityScaling
+ #define jpeg_simple_lossless	jSimLossless
  #define jpeg_simple_progression	jSimProgress
  #define jpeg_suppress_tables	jSuppressTables
  #define jpeg_alloc_quant_table	jAlcQTable
***************
*** 926,931 ****
--- 959,966 ----
  				       int scale_factor,
  				       boolean force_baseline));
  EXTERN(int) jpeg_quality_scaling JPP((int quality));
+ EXTERN(void) jpeg_simple_lossless JPP((j_compress_ptr cinfo,
+ 				       int predictor, int point_transform));
  EXTERN(void) jpeg_simple_progression JPP((j_compress_ptr cinfo));
  EXTERN(void) jpeg_suppress_tables JPP((j_compress_ptr cinfo,
  				       boolean suppress));
diff -cN ../jpeg-6b/libjpeg.doc ./libjpeg.doc
*** ../jpeg-6b/libjpeg.doc	Sat Feb 21 16:08:54 1998
--- ./libjpeg.doc	Tue Apr 27 14:58:34 1999
***************
*** 92,98 ****
  JPEG processes are supported.  (Our subset includes all features now in common
  use.)  Unsupported ISO options include:
  	* Hierarchical storage
- 	* Lossless JPEG
  	* Arithmetic entropy coding (unsupported for legal reasons)
  	* DNL marker
  	* Nonintegral subsampling ratios
--- 92,97 ----
***************
*** 867,872 ****
--- 866,877 ----
  jpeg_simple_progression (j_compress_ptr cinfo)
  	Generates a default scan script for writing a progressive-JPEG file.
  	This is the recommended method of creating a progressive file,
+ 	unless you want to make a custom scan sequence.  You must ensure that
+ 	the JPEG color space is set correctly before calling this routine.
+ 
+ jpeg_simple_lossless (j_compress_ptr cinfo, int predictor, int point_transform)
+ 	Generates a default scan script for writing a lossless-JPEG file.
+ 	This is the recommended method of creating a lossless file,
  	unless you want to make a custom scan sequence.  You must ensure that
  	the JPEG color space is set correctly before calling this routine.
  
diff -cN ../jpeg-6b/makefile.cfg ./makefile.cfg
*** ../jpeg-6b/makefile.cfg	Sat Mar 21 14:08:57 1998
--- ./makefile.cfg	Tue Apr 27 14:58:34 1999
***************
*** 73,86 ****
  
  
  # source files: JPEG library proper
! LIBSOURCES= jcapimin.c jcapistd.c jccoefct.c jccolor.c jcdctmgr.c jchuff.c \
!         jcinit.c jcmainct.c jcmarker.c jcmaster.c jcomapi.c jcparam.c \
!         jcphuff.c jcprepct.c jcsample.c jctrans.c jdapimin.c jdapistd.c \
!         jdatadst.c jdatasrc.c jdcoefct.c jdcolor.c jddctmgr.c jdhuff.c \
!         jdinput.c jdmainct.c jdmarker.c jdmaster.c jdmerge.c jdphuff.c \
!         jdpostct.c jdsample.c jdtrans.c jerror.c jfdctflt.c jfdctfst.c \
!         jfdctint.c jidctflt.c jidctfst.c jidctint.c jidctred.c jquant1.c \
!         jquant2.c jutils.c jmemmgr.c
  # memmgr back ends: compile only one of these into a working library
  SYSDEPSOURCES= jmemansi.c jmemname.c jmemnobs.c jmemdos.c jmemmac.c
  # source files: cjpeg/djpeg/jpegtran applications, also rdjpgcom/wrjpgcom
--- 73,88 ----
  
  
  # source files: JPEG library proper
! LIBSOURCES= jcapimin.c jcapistd.c jccoefct.c jccolor.c jcdctmgr.c jcdiffct.c \
! 	jchuff.c jcinit.c jclhuff.c jclossls.c jclossy.c jcmainct.c \
! 	jcmarker.c jcmaster.c jcodec.c jcomapi.c jcparam.c jcphuff.c jcpred.c \
! 	jcprepct.c jcsample.c jcscale.c jcshuff.c jctrans.c jdapimin.c \
! 	jdapistd.c jdatadst.c jdatasrc.c jdcoefct.c jdcolor.c jddctmgr.c \
! 	jddiffct.c jdhuff.c jdinput.c jdlhuff.c jdlossls.c jdlossy.c \
! 	jdmainct.c jdmarker.c jdmaster.c jdmerge.c jdphuff.c jdpostct.c \
! 	jdpred.c jdsample.c jdscale.c jdshuff.c jdtrans.c jerror.c jfdctflt.c \
! 	jfdctfst.c jfdctint.c jidctflt.c jidctfst.c jidctint.c jidctred.c \
! 	jquant1.c jquant2.c jutils.c jmemmgr.c
  # memmgr back ends: compile only one of these into a working library
  SYSDEPSOURCES= jmemansi.c jmemname.c jmemnobs.c jmemdos.c jmemmac.c
  # source files: cjpeg/djpeg/jpegtran applications, also rdjpgcom/wrjpgcom
***************
*** 89,96 ****
          rdtarga.c wrtarga.c rdbmp.c wrbmp.c rdrle.c wrrle.c
  SOURCES= $(LIBSOURCES) $(SYSDEPSOURCES) $(APPSOURCES)
  # files included by source files
! INCLUDES= jchuff.h jdhuff.h jdct.h jerror.h jinclude.h jmemsys.h jmorecfg.h \
!         jpegint.h jpeglib.h jversion.h cdjpeg.h cderror.h transupp.h
  # documentation, test, and support files
  DOCS= README install.doc usage.doc cjpeg.1 djpeg.1 jpegtran.1 rdjpgcom.1 \
          wrjpgcom.1 wizard.doc example.c libjpeg.doc structure.doc \
--- 91,99 ----
          rdtarga.c wrtarga.c rdbmp.c wrbmp.c rdrle.c wrrle.c
  SOURCES= $(LIBSOURCES) $(SYSDEPSOURCES) $(APPSOURCES)
  # files included by source files
! INCLUDES= jchuff.h jdhuff.h jdct.h jerror.h jinclude.h jlossls.h jlossy.h \
! 	jmemsys.h jmorecfg.h jpegint.h jpeglib.h jversion.h cdjpeg.h \
! 	cderror.h transupp.h
  # documentation, test, and support files
  DOCS= README install.doc usage.doc cjpeg.1 djpeg.1 jpegtran.1 rdjpgcom.1 \
          wrjpgcom.1 wizard.doc example.c libjpeg.doc structure.doc \
***************
*** 110,127 ****
  DISTFILES= $(DOCS) $(MKFILES) $(CONFIGFILES) $(SOURCES) $(INCLUDES) \
          $(CONFIGUREFILES) $(OTHERFILES) $(TESTFILES)
  # library object files common to compression and decompression
! COMOBJECTS= jcomapi.$(O) jutils.$(O) jerror.$(O) jmemmgr.$(O) $(SYSDEPMEM)
  # compression library object files
  CLIBOBJECTS= jcapimin.$(O) jcapistd.$(O) jctrans.$(O) jcparam.$(O) \
          jdatadst.$(O) jcinit.$(O) jcmaster.$(O) jcmarker.$(O) jcmainct.$(O) \
!         jcprepct.$(O) jccoefct.$(O) jccolor.$(O) jcsample.$(O) jchuff.$(O) \
!         jcphuff.$(O) jcdctmgr.$(O) jfdctfst.$(O) jfdctflt.$(O) \
!         jfdctint.$(O)
  # decompression library object files
  DLIBOBJECTS= jdapimin.$(O) jdapistd.$(O) jdtrans.$(O) jdatasrc.$(O) \
!         jdmaster.$(O) jdinput.$(O) jdmarker.$(O) jdhuff.$(O) jdphuff.$(O) \
!         jdmainct.$(O) jdcoefct.$(O) jdpostct.$(O) jddctmgr.$(O) \
!         jidctfst.$(O) jidctflt.$(O) jidctint.$(O) jidctred.$(O) \
          jdsample.$(O) jdcolor.$(O) jquant1.$(O) jquant2.$(O) jdmerge.$(O)
  # These objectfiles are included in libjpeg.a
  LIBOBJECTS= $(CLIBOBJECTS) $(DLIBOBJECTS) $(COMOBJECTS)
--- 113,133 ----
  DISTFILES= $(DOCS) $(MKFILES) $(CONFIGFILES) $(SOURCES) $(INCLUDES) \
          $(CONFIGUREFILES) $(OTHERFILES) $(TESTFILES)
  # library object files common to compression and decompression
! COMOBJECTS= jcomapi.$(O) jcodec.$(O) jutils.$(O) jerror.$(O) jmemmgr.$(O) \
! 	$(SYSDEPMEM)
  # compression library object files
  CLIBOBJECTS= jcapimin.$(O) jcapistd.$(O) jctrans.$(O) jcparam.$(O) \
          jdatadst.$(O) jcinit.$(O) jcmaster.$(O) jcmarker.$(O) jcmainct.$(O) \
!         jcprepct.$(O) jclossls.$(O) jclossy.o jccoefct.$(O) jccolor.$(O) \
! 	jcsample.$(O) jchuff.$(O) jcphuff.$(O) jcshuff.$(O) jclhuff.$(O) \
! 	jcpred.$(O) jcscale.$(O) jcdiffct.$(O) jcdctmgr.$(O) jfdctfst.$(O) \
! 	jfdctflt.$(O) jfdctint.$(O)
  # decompression library object files
  DLIBOBJECTS= jdapimin.$(O) jdapistd.$(O) jdtrans.$(O) jdatasrc.$(O) \
!         jdmaster.$(O) jdinput.$(O) jdmarker.$(O) jdlossls.$(O) jdlossy.$(O) \
! 	jdhuff.$(O) jdlhuff.$(O) jdphuff.$(O) jdshuff.$(O) jdpred.$(O) \
! 	jdscale.$(O) jddiffct.$(O) jdmainct.$(O) jdcoefct.$(O) jdpostct.$(O) \
! 	jddctmgr.$(O) jidctfst.$(O) jidctflt.$(O) jidctint.$(O) jidctred.$(O) \
          jdsample.$(O) jdcolor.$(O) jquant1.$(O) jquant2.$(O) jdmerge.$(O)
  # These objectfiles are included in libjpeg.a
  LIBOBJECTS= $(CLIBOBJECTS) $(DLIBOBJECTS) $(COMOBJECTS)
***************
*** 228,233 ****
--- 234,241 ----
  	./djpeg -dct int -ppm -outfile testoutp.ppm $(srcdir)/testprog.jpg
  	./cjpeg -dct int -progressive -opt -outfile testoutp.jpg $(srcdir)/testimg.ppm
  	./jpegtran -outfile testoutt.jpg $(srcdir)/testprog.jpg
+ 	./djpeg -ppm -outfile testoutl.ppm $(srcdir)/testimgl.jpg
+ 	./cjpeg -lossless 4,1 -outfile testoutl.jpg $(srcdir)/testimg.ppm
  	cmp $(srcdir)/testimg.ppm testout.ppm
  	cmp $(srcdir)/testimg.bmp testout.bmp
  	cmp $(srcdir)/testimg.jpg testout.jpg
***************
*** 234,239 ****
--- 242,249 ----
  	cmp $(srcdir)/testimg.ppm testoutp.ppm
  	cmp $(srcdir)/testimgp.jpg testoutp.jpg
  	cmp $(srcdir)/testorig.jpg testoutt.jpg
+ 	cmp $(srcdir)/testimgl.ppm testoutl.ppm
+ 	cmp $(srcdir)/testimgl.jpg testoutl.jpg
  
  check: test
  
***************
*** 250,286 ****
  
  jcapimin.$(O): jcapimin.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jcapistd.$(O): jcapistd.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
! jccoefct.$(O): jccoefct.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jccolor.$(O): jccolor.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
! jcdctmgr.$(O): jcdctmgr.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jdct.h
! jchuff.$(O): jchuff.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jchuff.h
  jcinit.$(O): jcinit.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jcmainct.$(O): jcmainct.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jcmarker.$(O): jcmarker.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jcmaster.$(O): jcmaster.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jcomapi.$(O): jcomapi.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jcparam.$(O): jcparam.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
! jcphuff.$(O): jcphuff.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jchuff.h
  jcprepct.$(O): jcprepct.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jcsample.$(O): jcsample.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
! jctrans.$(O): jctrans.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jdapimin.$(O): jdapimin.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jdapistd.$(O): jdapistd.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jdatadst.$(O): jdatadst.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jerror.h
  jdatasrc.$(O): jdatasrc.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jerror.h
! jdcoefct.$(O): jdcoefct.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jdcolor.$(O): jdcolor.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
! jddctmgr.$(O): jddctmgr.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jdct.h
! jdhuff.$(O): jdhuff.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jdhuff.h
  jdinput.$(O): jdinput.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jdmainct.$(O): jdmainct.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jdmarker.$(O): jdmarker.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jdmaster.$(O): jdmaster.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jdmerge.$(O): jdmerge.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
! jdphuff.$(O): jdphuff.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jdhuff.h
  jdpostct.$(O): jdpostct.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jdsample.$(O): jdsample.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
! jdtrans.$(O): jdtrans.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jerror.$(O): jerror.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jversion.h jerror.h
  jfdctflt.$(O): jfdctflt.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jdct.h
  jfdctfst.$(O): jfdctfst.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jdct.h
--- 260,311 ----
  
  jcapimin.$(O): jcapimin.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jcapistd.$(O): jcapistd.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
! jccoefct.$(O): jccoefct.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossy.h
! jcodec.$(O): jcodec.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossy.h jlossls.h
  jccolor.$(O): jccolor.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
! jcdctmgr.$(O): jcdctmgr.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossy.h jdct.h
! jcdiffct.$(O): jcdiffct.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossls.h
! jchuff.$(O): jchuff.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossy.h jlossls.h jchuff.h
  jcinit.$(O): jcinit.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
+ jclhuff.$(O): jclhuff.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossls.h jchuff.h
+ jclossls.$(O): jclossls.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossls.h
+ jclossy.$(O): jclossy.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossy.h
  jcmainct.$(O): jcmainct.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jcmarker.$(O): jcmarker.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jcmaster.$(O): jcmaster.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jcomapi.$(O): jcomapi.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jcparam.$(O): jcparam.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
! jcphuff.$(O): jcphuff.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossy.h jchuff.h
! jcpred.$(O): jcpred.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossls.h
  jcprepct.$(O): jcprepct.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jcsample.$(O): jcsample.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
! jcscale.$(O): jcscale.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossls.h
! jcshuff.$(O): jcshuff.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossy.h jlossls.h jchuff.h
! jctrans.$(O): jctrans.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossy.h
  jdapimin.$(O): jdapimin.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jdapistd.$(O): jdapistd.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jdatadst.$(O): jdatadst.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jerror.h
  jdatasrc.$(O): jdatasrc.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jerror.h
! jdcoefct.$(O): jdcoefct.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossy.h
  jdcolor.$(O): jdcolor.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
! jddctmgr.$(O): jddctmgr.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossy.h jdct.h
! jddiffct.$(O): jddiffct.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossls.h
! jdhuff.$(O): jdhuff.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossy.h jlossls.h jdhuff.h
  jdinput.$(O): jdinput.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
+ jdlhuff.$(O): jdlhuff.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossls.h jdhuff.h
+ jdlossls.$(O): jdlossls.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossls.h
+ jdlossy.$(O): jdlossy.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossy.h
  jdmainct.$(O): jdmainct.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jdmarker.$(O): jdmarker.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jdmaster.$(O): jdmaster.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
  jdmerge.$(O): jdmerge.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
! jdphuff.$(O): jdphuff.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossy.h jdhuff.h
  jdpostct.$(O): jdpostct.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
+ jdpred.$(O): jdpred.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossls.h
  jdsample.$(O): jdsample.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h
! jdscale.$(O): jdscale.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossls.h
! jdshuff.$(O): jdshuff.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossy.h jdhuff.h
! jdtrans.$(O): jdtrans.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jlossy.h
  jerror.$(O): jerror.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jversion.h jerror.h
  jfdctflt.$(O): jfdctflt.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jdct.h
  jfdctfst.$(O): jfdctfst.c jinclude.h jconfig.h jpeglib.h jmorecfg.h jpegint.h jerror.h jdct.h
diff -cN ../jpeg-6b/rdswitch.c ./rdswitch.c
*** ../jpeg-6b/rdswitch.c	Sat Jan 13 14:42:45 1996
--- ./rdswitch.c	Tue Apr 27 14:58:35 1999
***************
*** 330,332 ****
--- 330,358 ----
    }
    return TRUE;
  }
+ 
+ 
+ #ifdef C_LOSSLESS_SUPPORTED
+ 
+ GLOBAL(boolean)
+ set_simple_lossless (j_compress_ptr cinfo, char *arg)
+ {
+   int pred, pt = 0;
+   char ch;
+ 
+   ch = ',';		/* if not set by sscanf, will be ',' */
+   if (sscanf(arg, "%d%c", &pred, &ch) < 1)
+     return FALSE;
+   if (ch != ',')		/* syntax check */
+     return FALSE;
+   while (*arg && *arg++ != ',') /* advance to next segment of arg string */
+     ;
+   if (*arg) {
+     if (sscanf(arg, "%d", &pt) != 1)
+       pt = 0;
+   }
+   jpeg_simple_lossless(cinfo, pred, pt);
+   return TRUE;
+ }
+ 
+ #endif /* C_LOSSLESS_SUPPORTED */
diff -cN ../jpeg-6b/structure.doc ./structure.doc
*** ../jpeg-6b/structure.doc	Tue Nov 21 12:00:39 1995
--- ./structure.doc	Tue Apr 27 14:58:35 1999
***************
*** 21,28 ****
    A "sample" is a single component value (i.e., one number in the image data).
    A "coefficient" is a frequency coefficient (a DCT transform output number).
    A "block" is an 8x8 group of samples or coefficients.
!   An "MCU" (minimum coded unit) is an interleaved set of blocks of size
! 	determined by the sampling factors, or a single block in a
  	noninterleaved scan.
  We do not use the terms "pixel" and "sample" interchangeably.  When we say
  pixel, we mean an element of the full-size image, while a sample is an element
--- 21,30 ----
    A "sample" is a single component value (i.e., one number in the image data).
    A "coefficient" is a frequency coefficient (a DCT transform output number).
    A "block" is an 8x8 group of samples or coefficients.
!   A "data unit" is an abstract data type which is either a block for lossy
! 	(DCT-based) codecs or a sample for lossless (predictive) codecs.
!   An "MCU" (minimum coded unit) is an interleaved set of data units of size
! 	determined by the sampling factors, or a single data unit in a
  	noninterleaved scan.
  We do not use the terms "pixel" and "sample" interchangeably.  When we say
  pixel, we mean an element of the full-size image, while a sample is an element
***************
*** 43,56 ****
  formats.  This document concentrates on the library itself.
  
  We desire the library to be capable of supporting all JPEG baseline, extended
! sequential, and progressive DCT processes.  Hierarchical processes are not
! supported.
  
- The library does not support the lossless (spatial) JPEG process.  Lossless
- JPEG shares little or no code with lossy JPEG, and would normally be used
- without the extensive pre- and post-processing provided by this library.
- We feel that lossless JPEG is better handled by a separate library.
- 
  Within these limits, any set of compression parameters allowed by the JPEG
  spec should be readable for decompression.  (We can be more restrictive about
  what formats we can generate.)  Although the system design allows for all
--- 45,53 ----
  formats.  This document concentrates on the library itself.
  
  We desire the library to be capable of supporting all JPEG baseline, extended
! sequential, and progressive DCT processes, as well as the lossless (spatial)
! process.  Hierarchical processes are not supported.
  
  Within these limits, any set of compression parameters allowed by the JPEG
  spec should be readable for decompression.  (We can be more restrictive about
  what formats we can generate.)  Although the system design allows for all
***************
*** 134,142 ****
      * Color space conversion (e.g., RGB to YCbCr).
      * Edge expansion and downsampling.  Optionally, this step can do simple
        smoothing --- this is often helpful for low-quality source data.
!   JPEG proper:
      * MCU assembly, DCT, quantization.
      * Entropy coding (sequential or progressive, Huffman or arithmetic).
  
  In addition to these modules we need overall control, marker generation,
  and support code (memory management & error handling).  There is also a
--- 131,143 ----
      * Color space conversion (e.g., RGB to YCbCr).
      * Edge expansion and downsampling.  Optionally, this step can do simple
        smoothing --- this is often helpful for low-quality source data.
!   Lossy JPEG proper:
      * MCU assembly, DCT, quantization.
      * Entropy coding (sequential or progressive, Huffman or arithmetic).
+   Lossless JPEG proper:
+     * Point transform.
+     * Prediction, differencing.
+     * Entropy coding (Huffman or arithmetic)
  
  In addition to these modules we need overall control, marker generation,
  and support code (memory management & error handling).  There is also a
***************
*** 146,154 ****
  
  The decompressor library contains the following main elements:
  
!   JPEG proper:
      * Entropy decoding (sequential or progressive, Huffman or arithmetic).
      * Dequantization, inverse DCT, MCU disassembly.
    Postprocessing:
      * Upsampling.  Optionally, this step may be able to do more general
        rescaling of the image.
--- 147,159 ----
  
  The decompressor library contains the following main elements:
  
!   Lossy JPEG proper:
      * Entropy decoding (sequential or progressive, Huffman or arithmetic).
      * Dequantization, inverse DCT, MCU disassembly.
+   Lossless JPEG proper:
+     * Entropy decoding (Huffman or arithmetic).
+     * Prediction, undifferencing.
+     * Point transform, sample size scaling.
    Postprocessing:
      * Upsampling.  Optionally, this step may be able to do more general
        rescaling of the image.
***************
*** 312,317 ****
--- 317,337 ----
  task performed by any one controller.
  
  
+ *** Codec object structure ***
+ 
+ As noted above, this library supports both the lossy (DCT-based) and lossless
+ JPEG processes.  Because these processes have little in common with one another
+ (and their implementations share very little code), we need to provide a way to
+ isloate the underlying JPEG process from the rest of the library.  This is
+ accomplished by introducing an abstract "codec object" which acts a generic
+ interface to the JPEG (de)compressor proper.  
+ 
+ Using the power of the object-oriented scheme described above, we build the
+ lossy and lossless modules as two separate implementations of the codec object.
+ Switching between lossy and lossless processes then becomes as trivial as
+ assigning the appropriate method pointers during initialization of the library.
+ 
+ 
  *** Compression object structure ***
  
  Here is a sketch of the logical structure of the JPEG compression library:
***************
*** 319,329 ****
                                                   |-- Colorspace conversion
                    |-- Preprocessing controller --|
                    |                              |-- Downsampling
  Main controller --|
!                   |                            |-- Forward DCT, quantize
!                   |-- Coefficient controller --|
!                                                |-- Entropy encoding
  
  This sketch also describes the flow of control (subroutine calls) during
  typical image data processing.  Each of the components shown in the diagram is
  an "object" which may have several different implementations available.  One
--- 339,369 ----
                                                   |-- Colorspace conversion
                    |-- Preprocessing controller --|
                    |                              |-- Downsampling
+                   |
  Main controller --|
!                   |                       /--> Lossy codec
!                   |                      /
!                   |-- Compression codec <          *OR*
!                                          \
!                                           \--> Lossless codec
! 
! 
! where the lossy codec looks like:
  
+                              |-- Forward DCT, quantize
+ <-- Coefficient controller --|
+                              |-- Entropy encoding
+ 
+ 
+ and the lossless codec looks like:
+ 
+                             |-- Point transformation
+                             |
+ <-- Difference controller --|-- Prediction, differencing
+                             |
+                             |-- Lossless entropy encoding
+ 
+ 
  This sketch also describes the flow of control (subroutine calls) during
  typical image data processing.  Each of the components shown in the diagram is
  an "object" which may have several different implementations available.  One
***************
*** 377,382 ****
--- 417,439 ----
    during each pass, and the coder must emit the appropriate subset of
    coefficients.
  
+ * Difference controller: buffer controller for the spatial difference data.
+   When emitting a multiscan JPEG file, this controller is responsible for
+   buffering the full image.  The equivalent of one fully interleaved MCU row
+   of subsampled data is processed per call, even when the JPEG file is
+   noninterleaved.
+ 
+ * Point transformation: Scale the data down by the point transformation
+   parameter.
+ 
+ * Prediction and differencing: Calculate the predictor and subtract it
+   from the input.  Works on one scanline per call.  The difference
+   controller supplies the prior scanline which is used for prediction.
+ 
+ * Lossless entropy encoding: Perform Huffman or arithmetic entropy coding and
+   emit the coded data to the data destination module.  This module handles MCU
+   assembly.  Works on one MCU-row per call.
+ 
  In addition to the above objects, the compression library includes these
  objects:
  
***************
*** 418,432 ****
  
  Here is a sketch of the logical structure of the JPEG decompression library:
  
!                                                |-- Entropy decoding
!                   |-- Coefficient controller --|
!                   |                            |-- Dequantize, Inverse DCT
  Main controller --|
                    |                               |-- Upsampling
                    |-- Postprocessing controller --|   |-- Colorspace conversion
                                                    |-- Color quantization
                                                    |-- Color precision reduction
  
  As before, this diagram also represents typical control flow.  The objects
  shown are:
  
--- 475,509 ----
  
  Here is a sketch of the logical structure of the JPEG decompression library:
  
!                                             /--> Lossy codec
!                                            /
!                   |-- Decompression codec <          *OR*
!                   |                        \
!                   |                         \--> Lossless codec
  Main controller --|
+                   |
                    |                               |-- Upsampling
                    |-- Postprocessing controller --|   |-- Colorspace conversion
                                                    |-- Color quantization
                                                    |-- Color precision reduction
  
+ 
+ where the lossy codec looks like:
+ 
+                              |-- Entropy decoding
+ <-- Coefficient controller --|
+                              |-- Dequantize, Inverse DCT
+ 
+ 
+ and the lossless codec looks like:
+ 
+                             |-- Lossless entropy decoding
+                             |
+ <-- Difference controller --|-- Prediction, undifferencing
+                             |
+                             |-- Point transformation, sample size scaling
+ 
+ 
  As before, this diagram also represents typical control flow.  The objects
  shown are:
  
***************
*** 459,464 ****
--- 536,558 ----
    When scaled-down output is asked for, simplified DCT algorithms may be used
    that emit only 1x1, 2x2, or 4x4 samples per DCT block, not the full 8x8.
    Works on one DCT block at a time.
+ 
+ * Difference controller: buffer controller for the spatial difference data.
+   When reading a multiscan JPEG file, this controller is responsible for
+   buffering the full image. The equivalent of one fully interleaved MCU row
+   is processed per call, even when the source JPEG file is noninterleaved.
+ 
+ * Lossless entropy decoding: Read coded data from the data source module and
+   perform Huffman or arithmetic entropy decoding.  Works on one MCU-row per
+   call.
+ 
+ * Prediction and undifferencing: Calculate the predictor and add it to the
+   decoded difference.  Works on one scanline per call.  The difference
+   controller supplies the prior scanline which is used for prediction.
+ 
+ * Point transform and sample size scaling: Scale the data up by the point
+   transformation parameter and scale it down to fit into the compiled-in
+   sample size.
  
  * Postprocessing controller: buffer controller for the color quantization
    input buffer, when quantization is in use.  (Without quantization, this
diff -cN ../jpeg-6b/transupp.c ./transupp.c
*** ../jpeg-6b/transupp.c	Sat Aug  9 20:15:26 1997
--- ./transupp.c	Tue Apr 27 15:08:05 1999
***************
*** 1,7 ****
  /*
   * transupp.c
   *
!  * Copyright (C) 1997, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
--- 1,7 ----
  /*
   * transupp.c
   *
!  * Copyright (C) 1997-1998, Thomas G. Lane.
   * This file is part of the Independent JPEG Group's software.
   * For conditions of distribution and use, see the accompanying README file.
   *
***************
*** 84,90 ****
    for (ci = 0; ci < dstinfo->num_components; ci++) {
      compptr = dstinfo->comp_info + ci;
      comp_width = MCU_cols * compptr->h_samp_factor;
!     for (blk_y = 0; blk_y < compptr->height_in_blocks;
  	 blk_y += compptr->v_samp_factor) {
        buffer = (*srcinfo->mem->access_virt_barray)
  	((j_common_ptr) srcinfo, src_coef_arrays[ci], blk_y,
--- 84,90 ----
    for (ci = 0; ci < dstinfo->num_components; ci++) {
      compptr = dstinfo->comp_info + ci;
      comp_width = MCU_cols * compptr->h_samp_factor;
!     for (blk_y = 0; blk_y < compptr->height_in_data_units;
  	 blk_y += compptr->v_samp_factor) {
        buffer = (*srcinfo->mem->access_virt_barray)
  	((j_common_ptr) srcinfo, src_coef_arrays[ci], blk_y,
***************
*** 136,142 ****
    for (ci = 0; ci < dstinfo->num_components; ci++) {
      compptr = dstinfo->comp_info + ci;
      comp_height = MCU_rows * compptr->v_samp_factor;
!     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
  	 dst_blk_y += compptr->v_samp_factor) {
        dst_buffer = (*srcinfo->mem->access_virt_barray)
  	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
--- 136,142 ----
    for (ci = 0; ci < dstinfo->num_components; ci++) {
      compptr = dstinfo->comp_info + ci;
      comp_height = MCU_rows * compptr->v_samp_factor;
!     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_data_units;
  	 dst_blk_y += compptr->v_samp_factor) {
        dst_buffer = (*srcinfo->mem->access_virt_barray)
  	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
***************
*** 158,164 ****
  	  /* Row is within the mirrorable area. */
  	  dst_row_ptr = dst_buffer[offset_y];
  	  src_row_ptr = src_buffer[compptr->v_samp_factor - offset_y - 1];
! 	  for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
  	       dst_blk_x++) {
  	    dst_ptr = dst_row_ptr[dst_blk_x];
  	    src_ptr = src_row_ptr[dst_blk_x];
--- 158,164 ----
  	  /* Row is within the mirrorable area. */
  	  dst_row_ptr = dst_buffer[offset_y];
  	  src_row_ptr = src_buffer[compptr->v_samp_factor - offset_y - 1];
! 	  for (dst_blk_x = 0; dst_blk_x < compptr->width_in_data_units;
  	       dst_blk_x++) {
  	    dst_ptr = dst_row_ptr[dst_blk_x];
  	    src_ptr = src_row_ptr[dst_blk_x];
***************
*** 174,180 ****
  	} else {
  	  /* Just copy row verbatim. */
  	  jcopy_block_row(src_buffer[offset_y], dst_buffer[offset_y],
! 			  compptr->width_in_blocks);
  	}
        }
      }
--- 174,180 ----
  	} else {
  	  /* Just copy row verbatim. */
  	  jcopy_block_row(src_buffer[offset_y], dst_buffer[offset_y],
! 			  compptr->width_in_data_units);
  	}
        }
      }
***************
*** 201,213 ****
     */
    for (ci = 0; ci < dstinfo->num_components; ci++) {
      compptr = dstinfo->comp_info + ci;
!     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
  	 dst_blk_y += compptr->v_samp_factor) {
        dst_buffer = (*srcinfo->mem->access_virt_barray)
  	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
  	 (JDIMENSION) compptr->v_samp_factor, TRUE);
        for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
! 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
  	     dst_blk_x += compptr->h_samp_factor) {
  	  src_buffer = (*srcinfo->mem->access_virt_barray)
  	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
--- 201,213 ----
     */
    for (ci = 0; ci < dstinfo->num_components; ci++) {
      compptr = dstinfo->comp_info + ci;
!     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_data_units;
  	 dst_blk_y += compptr->v_samp_factor) {
        dst_buffer = (*srcinfo->mem->access_virt_barray)
  	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
  	 (JDIMENSION) compptr->v_samp_factor, TRUE);
        for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
! 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_data_units;
  	     dst_blk_x += compptr->h_samp_factor) {
  	  src_buffer = (*srcinfo->mem->access_virt_barray)
  	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
***************
*** 251,263 ****
    for (ci = 0; ci < dstinfo->num_components; ci++) {
      compptr = dstinfo->comp_info + ci;
      comp_width = MCU_cols * compptr->h_samp_factor;
!     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
  	 dst_blk_y += compptr->v_samp_factor) {
        dst_buffer = (*srcinfo->mem->access_virt_barray)
  	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
  	 (JDIMENSION) compptr->v_samp_factor, TRUE);
        for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
! 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
  	     dst_blk_x += compptr->h_samp_factor) {
  	  src_buffer = (*srcinfo->mem->access_virt_barray)
  	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
--- 251,263 ----
    for (ci = 0; ci < dstinfo->num_components; ci++) {
      compptr = dstinfo->comp_info + ci;
      comp_width = MCU_cols * compptr->h_samp_factor;
!     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_data_units;
  	 dst_blk_y += compptr->v_samp_factor) {
        dst_buffer = (*srcinfo->mem->access_virt_barray)
  	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
  	 (JDIMENSION) compptr->v_samp_factor, TRUE);
        for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
! 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_data_units;
  	     dst_blk_x += compptr->h_samp_factor) {
  	  src_buffer = (*srcinfo->mem->access_virt_barray)
  	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
***************
*** 315,327 ****
    for (ci = 0; ci < dstinfo->num_components; ci++) {
      compptr = dstinfo->comp_info + ci;
      comp_height = MCU_rows * compptr->v_samp_factor;
!     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
  	 dst_blk_y += compptr->v_samp_factor) {
        dst_buffer = (*srcinfo->mem->access_virt_barray)
  	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
  	 (JDIMENSION) compptr->v_samp_factor, TRUE);
        for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
! 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
  	     dst_blk_x += compptr->h_samp_factor) {
  	  src_buffer = (*srcinfo->mem->access_virt_barray)
  	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
--- 315,327 ----
    for (ci = 0; ci < dstinfo->num_components; ci++) {
      compptr = dstinfo->comp_info + ci;
      comp_height = MCU_rows * compptr->v_samp_factor;
!     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_data_units;
  	 dst_blk_y += compptr->v_samp_factor) {
        dst_buffer = (*srcinfo->mem->access_virt_barray)
  	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
  	 (JDIMENSION) compptr->v_samp_factor, TRUE);
        for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
! 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_data_units;
  	     dst_blk_x += compptr->h_samp_factor) {
  	  src_buffer = (*srcinfo->mem->access_virt_barray)
  	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
***************
*** 378,384 ****
      compptr = dstinfo->comp_info + ci;
      comp_width = MCU_cols * compptr->h_samp_factor;
      comp_height = MCU_rows * compptr->v_samp_factor;
!     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
  	 dst_blk_y += compptr->v_samp_factor) {
        dst_buffer = (*srcinfo->mem->access_virt_barray)
  	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
--- 378,384 ----
      compptr = dstinfo->comp_info + ci;
      comp_width = MCU_cols * compptr->h_samp_factor;
      comp_height = MCU_rows * compptr->v_samp_factor;
!     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_data_units;
  	 dst_blk_y += compptr->v_samp_factor) {
        dst_buffer = (*srcinfo->mem->access_virt_barray)
  	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
***************
*** 418,424 ****
  	    }
  	  }
  	  /* Any remaining right-edge blocks are only mirrored vertically. */
! 	  for (; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
  	    dst_ptr = dst_row_ptr[dst_blk_x];
  	    src_ptr = src_row_ptr[dst_blk_x];
  	    for (i = 0; i < DCTSIZE; i += 2) {
--- 418,424 ----
  	    }
  	  }
  	  /* Any remaining right-edge blocks are only mirrored vertically. */
! 	  for (; dst_blk_x < compptr->width_in_data_units; dst_blk_x++) {
  	    dst_ptr = dst_row_ptr[dst_blk_x];
  	    src_ptr = src_row_ptr[dst_blk_x];
  	    for (i = 0; i < DCTSIZE; i += 2) {
***************
*** 442,448 ****
  	    }
  	  }
  	  /* Any remaining right-edge blocks are only copied. */
! 	  for (; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
  	    dst_ptr = dst_row_ptr[dst_blk_x];
  	    src_ptr = src_row_ptr[dst_blk_x];
  	    for (i = 0; i < DCTSIZE2; i++)
--- 442,448 ----
  	    }
  	  }
  	  /* Any remaining right-edge blocks are only copied. */
! 	  for (; dst_blk_x < compptr->width_in_data_units; dst_blk_x++) {
  	    dst_ptr = dst_row_ptr[dst_blk_x];
  	    src_ptr = src_row_ptr[dst_blk_x];
  	    for (i = 0; i < DCTSIZE2; i++)
***************
*** 482,494 ****
      compptr = dstinfo->comp_info + ci;
      comp_width = MCU_cols * compptr->h_samp_factor;
      comp_height = MCU_rows * compptr->v_samp_factor;
!     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
  	 dst_blk_y += compptr->v_samp_factor) {
        dst_buffer = (*srcinfo->mem->access_virt_barray)
  	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
  	 (JDIMENSION) compptr->v_samp_factor, TRUE);
        for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
! 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
  	     dst_blk_x += compptr->h_samp_factor) {
  	  src_buffer = (*srcinfo->mem->access_virt_barray)
  	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
--- 482,494 ----
      compptr = dstinfo->comp_info + ci;
      comp_width = MCU_cols * compptr->h_samp_factor;
      comp_height = MCU_rows * compptr->v_samp_factor;
!     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_data_units;
  	 dst_blk_y += compptr->v_samp_factor) {
        dst_buffer = (*srcinfo->mem->access_virt_barray)
  	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
  	 (JDIMENSION) compptr->v_samp_factor, TRUE);
        for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
! 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_data_units;
  	     dst_blk_x += compptr->h_samp_factor) {
  	  src_buffer = (*srcinfo->mem->access_virt_barray)
  	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
***************
*** 600,608 ****
        compptr = srcinfo->comp_info + ci;
        coef_arrays[ci] = (*srcinfo->mem->request_virt_barray)
  	((j_common_ptr) srcinfo, JPOOL_IMAGE, FALSE,
! 	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
  				(long) compptr->h_samp_factor),
! 	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
  				(long) compptr->v_samp_factor),
  	 (JDIMENSION) compptr->v_samp_factor);
      }
--- 600,608 ----
        compptr = srcinfo->comp_info + ci;
        coef_arrays[ci] = (*srcinfo->mem->request_virt_barray)
  	((j_common_ptr) srcinfo, JPOOL_IMAGE, FALSE,
! 	 (JDIMENSION) jround_up((long) compptr->width_in_data_units,
  				(long) compptr->h_samp_factor),
! 	 (JDIMENSION) jround_up((long) compptr->height_in_data_units,
  				(long) compptr->v_samp_factor),
  	 (JDIMENSION) compptr->v_samp_factor);
      }
***************
*** 622,630 ****
        compptr = srcinfo->comp_info + ci;
        coef_arrays[ci] = (*srcinfo->mem->request_virt_barray)
  	((j_common_ptr) srcinfo, JPOOL_IMAGE, FALSE,
! 	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
  				(long) compptr->v_samp_factor),
! 	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
  				(long) compptr->h_samp_factor),
  	 (JDIMENSION) compptr->h_samp_factor);
      }
--- 622,630 ----
        compptr = srcinfo->comp_info + ci;
        coef_arrays[ci] = (*srcinfo->mem->request_virt_barray)
  	((j_common_ptr) srcinfo, JPOOL_IMAGE, FALSE,
! 	 (JDIMENSION) jround_up((long) compptr->height_in_data_units,
  				(long) compptr->v_samp_factor),
! 	 (JDIMENSION) jround_up((long) compptr->width_in_data_units,
  				(long) compptr->h_samp_factor),
  	 (JDIMENSION) compptr->h_samp_factor);
      }
